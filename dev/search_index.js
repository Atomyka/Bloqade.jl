var documenterSearchIndex = {"docs":
[{"location":"topics/blockade/#blockade","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"","category":"section"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The Rydberg blockade mechanism is a crucial component of the operation of neutral atom computers. By including a term in the effective Hamiltonian which adds an interaction between adjacent Rydberg atoms, we may construct gates and nontrivial dynamics which create entanglement and correlation across the system.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The term is a van der Waals interaction where there is an energy shift if two adjacent atoms are in the Rydberg state. The Van der Waals interaction is","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"V_ij = fracC_6vec r_i - vec r_j^6hat n_i hat n_j","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"where hat n_i=r_iranglelangle r_i is the number operator on the ith site, which is 1 if the atom is in the Rydberg state, and zero if the atom is in the ground state. The coefficeint C_6 = 2pitimes 862690 MHzmu m^6 is the interaction strength; characteristically, this interaction has a strength approx 10MHz for two atoms seperated by 10mu m, a similar scale to the Rabi coupling between the ground and Rydberg state. Crucially, this can be seen as an energy shift on atom j, conditional on the state of atom i, and so can be used, in a loose sense, as a conditional logical gate. This is because the adjacent atom forces the atom to be off-resonant with the laser field.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"This conditional drive can be seen given the following dynamics. Suppose two atoms are close to each other ( 10 mu m) and so interact under van der Waals. The left atom is either in a Rydberg state, or in the ground state, and the right atom is originally in the ground state. Then, a Rabi drive is applied to the right atom, which couples the atom's ground state to the Rydberg state. For this example, we choose a Rabi drive of Omega=2pitimes 05MHz and distance between atoms vec r_i- vec r_j = 7mu m, which gives a conditional detuning of approx 50MHz. When the left atom is in the ground state (black, top), there are no interactions and the state of the right atom oscillates between the ground state and Rydberg state; for a particular choice of timing this executes a pi pulse, flipping the right atom from the ground to Rydberg state. However, when the left atom is in the Rydberg state (red, bottom), there is a large detuning on the right atom, which causes the transfer to the Rydberg state to be strongly suppressed. In this case, the right atom (up to perturbative corrections) is never in the Rydberg state.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"(Image: RydbergBlockade)","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"This conditional energy shift is the basis of the Rydberg Blockade. Because of the large energy shift from having two adjacent atoms in the Rydberg state, evolution from an atomic ground state with local Rabi couplings between ground and Rydberg is restricted to a low energy subspace of states where no two adjacent atoms are in the Rydberg state. Furthermore, because the interaction strength with distance is a large power law, one can define a characteristic scale set by the Rabi coupling. If two atoms are close such that the conditional detuning is much larger than the Rabi coupling, one can consider the atoms to be blockading each other, and both atoms cannot simultaniously be in the Rydberg state. In contrast, if two atoms are far away, the two atoms never blockade each other and both atoms can simultaniously be in the Rydberg state.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The allowed states are then independent sets of a unit disk graph defined by the positions of the atoms. A unit disk graph is a set of vertices and edges, where vertices represent every atom, and there are edges if the distance between vertices is less than some radius vec r_i- vec r_jR, given by the characteristic Rabi frequency and van der Walls detuning. The blockade constraint is incoded by independent sets, which are subsets  S of vertices of the unit disk graph such that no two vertices in S are adjacent. The number of independent sets in a graph is much smaller than the number of subsets of the graph, so correspondingly the Hilbert space of quantum evolution is much smaller. This subspace constraint can thus speed quantum simulation considerably, at very little cost.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"To emphisize the effectiveness of this independent set subspace, some example nonequilibrium dynamics are shown below, for a ring of 12 atoms seperated by 7mu m. This set of atoms can be defined by","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"using Bloqade\nnsites = 12;    # 12 site chain\ndistance = 7    # Distance between atoms, in microns\n\nR = distance/(2*sin(2*pi/(nsites)/2))                                       # Radius of the circle, using a little trigonometry\npos = [(R*sin(i*2*pi/(nsites)), R*cos(i*2*pi/(nsites)) ) for i in 1:nsites] # Positions of each atom\natoms = AtomList(pos)                                                       # Define the atom positions as an AtomList.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The system is driven by a constant 2pi times 05MHz Rabi drive, which couples each atom's ground and Rydberg state. This can be defined using a Hamiltonian","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"h = rydberg_h(atoms;C = 2π * 858386, Ω=π)","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"The system is initialized into the ground state of all atoms. We have two choices of basis: the first choice is the full Hilbert space of 2^12 elements, wheras the second basis is the blockade subspace, which excludes Rydberg excitations within the unit disk radius. The blockade subspace has D=322 elements, which means that computation is much faster.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"init_state = zero_state(nsites)                       # Initial state in the full space\nspace = blockade_subspace(atoms,distance*1.1)   # Compute the blockade subspace\ninit_state2 = zero_state(space)                       # Define the initial state in the blockade subspace.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"If the atoms were far apart and non-interacting, each atom would oscillate completely between its ground state and Rydberg state with a period of 05 mus. However, because adjacent atoms shift to the Rydberg state concurrently, they are dynamically blockaded, causing the maximum Rydberg density to only be 1/2, corresponding to an antiferromagnetic Z_2 state. Note that because the ring has a translation symmetry, the Rydberg density is equal on all sites.","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"# Define the time steps\nTmax = 10.\nnsteps = 5001\ntimes = LinRange(0,Tmax,nsteps)\n\n\n# Time evolve the system in the full space\nprob = SchrodingerProblem(init_state, Tmax, h, dt = Tmax/(nsteps-1) , adaptive = false);\nintegrator = init(prob, Vern6());\n\ndensities = []\nfor _ in TimeChoiceIterator(integrator, 0.0:Tmax/(nsteps-1):Tmax)\n    push!(densities, expect(put(nsites, 1=>Op.n), init_state))\nend\n\n\n# Time evolve the system in the subspace\nprob2 = SchrodingerProblem(init_state2, Tmax, h, dt = Tmax/(nsteps-1) , adaptive = false);\nintegrator2 = init(prob2, Vern8());\n\ndensities2 = []\nfor _ in TimeChoiceIterator(integrator2, 0.0:Tmax/(nsteps-1):Tmax)\n    push!(densities2, expect(put(nsites, 1=>Op.n), init_state2))#, SubspaceArrayReg(u, space)))\nend\n\n\n# Plot the data\nfig = plt.figure(figsize=(8,6))\nax  = plt.subplot(1,1,1)\n\nplt.plot(times,real(densities),\"k\",label=\"Full space\")\nplt.plot(times,real(densities2),\"r--\",label=\"Subspace\")\nax.axis([0,Tmax,0,0.45])\nplt.xlabel(\"Time (us)\")\nplt.ylabel(\"Rydberg density\")\nplt.tight_layout()\nplt.legend()\n\n# Using matplotlib plots\ninset_axes = pyimport(\"mpl_toolkits.axes_grid1.inset_locator\")\nax2 = inset_axes.inset_axes(ax,width=\"20%\",height=\"30%\",loc=\"lower right\",borderpad=1)\nplt.plot(times,real(densities - densities2))\nplt.axis([0,0.6,-0.0008,0.0008])\nplt.ylabel(\"Difference\",fontsize=12)\nplt.yticks(LinRange(-0.0008,0.0008,5),fontsize=12)\nplt.xticks([0,0.2,0.4,0.6],fontsize=12)","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"(Image: RydbergBlockadeSubspace)","category":"page"},{"location":"topics/blockade/","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"Data for this evolution is shown above, where exact evolution in the full space is shown in black, and the truncated evolution in the subspace is shown by red dashed. It is clear that even though the Hilbert space is 12times smaller, the dynamics are faithfully reproduced, up to high frequency oscillations (inset) from adjacent atoms in the Rydberg state, similar to the high frequency oscillations of the 2 atom conditional blockade example. However, at longer times this subspace approximation fails to reproduce the full space (shown by divergence between black and red dashed). Note that for this example, the distance between atoms was chosen to be in an intermediate regime (eg, at the edge of the unit disk), which reduces the blockade effect and amplifies the approximate nature of the blockade. If the atoms were chosen to be closer together (say, 5mu m) or the Rabi strength was reduced, the blockade approximation becomes much stronger.","category":"page"},{"location":"install/#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"You can copy the following line to your Julia REPL to install latest stable version this package.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add Bloqade","category":"page"},{"location":"install/#Build-System-Image-to-Accelerate-Start-up-Time","page":"Installation","title":"Build System Image to Accelerate Start-up Time","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Since Bloqade is a very large package, its loading time and time-to-first-emulation can be very long. You can build system images to save all the compilation results in a binary to accelerate its loading/compilation time.","category":"page"},{"location":"install/#Build-System-Image-Via-VSCode-Julia-Plugin-(Recommended)","page":"Installation","title":"Build System Image Via VSCode Julia Plugin (Recommended)","text":"","category":"section"},{"location":"install/#Build-System-Image-Via-PackageCompiler","page":"Installation","title":"Build System Image Via PackageCompiler","text":"","category":"section"},{"location":"install/#Try-Latest-Version-of-Bloqade","page":"Installation","title":"Try Latest Version of Bloqade","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Some users may want to try the latest version of Bloqade for bugfixes, new features etc. One can use git to clone the repo to try the latest version of the entire package. This requires one to setup the local project environment via dev. Please refer to Contributing for more reference.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you only want to try the latest version of a specific Bloqade package, just add #master behind the package name, e.g","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add BloqadeExpr#master","category":"page"},{"location":"contrib/#Contributing","page":"Contributing Bloqade","title":"Contributing","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"If you are interested in contributing to this package, please consider going through this guide to help you smooth your developing workflow.","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"Contributing to documentation is always a good start to get familiar with the community and workflows.","category":"page"},{"location":"contrib/#Documentation","page":"Contributing Bloqade","title":"Documentation","text":"","category":"section"},{"location":"contrib/#Setup-Documentation","page":"Contributing Bloqade","title":"Setup Documentation","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"If you are editing the documentation, you can use the serve command","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run doc serve","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"to serve the documentation locally, and it will automatically update the served webpage while you editing. ","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"If you wish to just build the documentation, you can use build command, which will run the build","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run doc build","category":"page"},{"location":"contrib/#Light-weight-Documentation-Build","page":"Contributing Bloqade","title":"Light-weight Documentation Build","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"Due to the ancient technology used by Documenter, it cannot render single page while editing, thus causing the doc serve command to be very slow when editing. We provide a light-weight build setup to workaround this by removing all literate examples from the documentation. You can enable this by","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run doc build --light\n.ci/run doc serve --light","category":"page"},{"location":"contrib/#Setting-Up-Environments","page":"Contributing Bloqade","title":"Setting Up Environments","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"The Bloqade package itself is a meta-package that simply re-exports component packages lives in lib directory. Thus one will need to dev the corresponding component package to make sure they are using the master branch version while developing, you can always do this manually in Julia's Pkg mode via dev command, e.g in the Bloqade environment (the Bloqade/Project.toml file), one will need to run the following command","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"pkg> dev lib/BloqadeExpr lib/BloqadeKrylov lib/BloqadeLattices lib/BloqadeMIS lib/BloqadeODE lib/BloqadeWaveforms","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"this can be done automatically using the CLI tool introduced in the following.","category":"page"},{"location":"contrib/#Components","page":"Contributing Bloqade","title":"Components","text":"","category":"section"},{"location":"contrib/#The-CLI-Tool","page":"Contributing Bloqade","title":"The CLI Tool","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"There is a CLI tool in this repository at .ci/run that can help you simplify the workflow a lot. You can run .ci/run -h in your terminal to see the help message. or run .ci/run <command> -h to see the help message of each command. Here are some common examples of it.","category":"page"},{"location":"contrib/#Create-New-Examples","page":"Contributing Bloqade","title":"Create New Examples","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"create a new example project called my_new_examples in examples and setup the dependencies of Bloqade.","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run example create my_new_example","category":"page"},{"location":"contrib/#Build-Single-Example","page":"Contributing Bloqade","title":"Build Single Example","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"build a single example at build/my_example to jupyter notebook.","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run example build my_example","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"EditURL = \"https://github.com/Happy-Diode/Bloqade.jl/blob/master/examples/adiabatic/main.jl\"","category":"page"},{"location":"tutorials/adiabatic/main/#Adiabatic-Evolution","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"","category":"section"},{"location":"tutorials/adiabatic/main/#Background","page":"Adiabatic Evolution","title":"Background","text":"","category":"section"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"In this example, we will show how to use Bloqade to prepare ordered ground states in the Rydberg system. The example is based on the experimental works in a 1D system and 2D system. The Rydberg Hamiltonian can be found in Bloqade.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Due to the strong Rydberg interactions, only one Rydberg excitation is allowed within the blockade radius (see Rydberg Blockade). With a positive detuning Δ, more Rydberg excitations are favored (to lower the ground state(s) energy). The interplay of these two mechanisms allows the creation of different ordered states depending on the strength of the blockade radius and the detunings, such as the Z_N ordered states in 1D and the checkerboard phase, the star phase, and a pure quantum phase (the striated phase) in 2D (see the experimental and theory papers).","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Here, we use the Quantum Adiabatic Algorithm (QAA) to prepare these quantum many-body ground states. To do that, we can start with all atoms in the ground state  0 rangle, which is the ground state of the many-body Hamiltonian with a large negative detuning Delta. Then, the Rabi frequency Omega is turned on, and the detuning strength is ramped up from a large negative value to postive values. If this process is slow enough, the quantum state of the system stays close to the ground state of the instantaneous Hamiltonian. At the end of this process, we arrive at a target Hamiltonian, and correspondingly, the prepared state is approximately the ground state for the final Hamiltonian. A quantum phase transition typically occurs during this process and one can probe the phase transition and critical phenomena by simulating and understanding the quantum dynamics.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Let's start by importing the required libraries:","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"using Bloqade\nusing PythonCall\nusing BloqadePlots\nusing KrylovKit\nusing SparseArrays\n\nplt = pyimport(\"matplotlib.pyplot\")","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Python module: <module 'matplotlib.pyplot' from '/home/runner/work/Bloqade.jl/Bloqade.jl/examples/adiabatic/.CondaPkg/env/lib/python3.10/site-packages/matplotlib/pyplot.py'>","category":"page"},{"location":"tutorials/adiabatic/main/#Ground-state-properties","page":"Adiabatic Evolution","title":"Ground state properties","text":"","category":"section"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We start by probing the ground state properties of the Rydberg Hamiltonian in a 1D system. Let's use the 1D chain for simplicity and vary the parameters of the Rydberg Hamiltonian and calculate the corresponding ground state properties. Here, we consider a chain with 9 atoms, where nearby atoms are seperated by a distance of 5.72 mu m. Please refer to the Rydberg Blockade page on tips for setting the separation distance for the atoms in preparing different ordered states. One can generate the system as follows using the function generate_sites:","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nsites = 9\natoms = generate_sites(ChainLattice(), nsites, scale = 5.72)","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"47.27mm\" viewBox=\"0 0 120 47.27\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.88\" id=\"img-9b1228ce-1\">\n  <g transform=\"translate(23.64,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.82,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">11.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">22.88μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.18,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">34.32μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.36,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">45.76μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.82,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"0.44\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-9b1228ce-2\">\n  <g transform=\"translate(23.64,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(32.73,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(41.82,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(50.91,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(69.09,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(78.18,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(87.27,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(96.36,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"2.57\" id=\"img-9b1228ce-3\">\n  <g transform=\"translate(23.64,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(32.73,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.82,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(50.91,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(69.09,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.18,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(87.27,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.36,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We fix the Rabi frequency to be Ω = 2π * 4 MHz, and study the ground state as a function of the detuning Δ.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Ω = 2π * 4\nΔ_step = 30\nΔ = LinRange(-2π * 10, 2π * 10, Δ_step);","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The Rydberg density profile can be computed for each parameter of Delta.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"density_g = zeros(Δ_step, nsites)\n\nfor ii in 1:Δ_step\n    h_ii = rydberg_h(atoms; Δ=Δ[ii], Ω) # create the Rydberg Hamiltonian\n    h_m = mat(h_ii) # convert the Hamiltonian into a matrix\n    vals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR) # find the ground state eigenvalue and eigenvector\n    g_state = ArrayReg(vecs[1]) # creates the initial state with all atoms in ``| 0 \\rangle`` state\n\n    for jj in 1:nsites\n        density_g[ii, jj] = real(expect(put(nsites, jj=>Op.n), g_state)) # measure the density of Rydberg excitations on each site\n    end\nend","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"To compare, we first plot the density profile when Delta= -2π * 10 MHz,","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, ax = plt.subplots(figsize = (10, 4))\nax.bar(1:nsites, density_g[1, :])\nax.set_xticks(1:nsites)\nax.set_xlabel(\"Sites\")\nax.set_ylabel(\"Rydberg density\")\nax.set_title(\"Density Profile: 1D Chain, Δ = -2π * 10\")\nfig","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We can see that the Rydberg densities in this case is close to 0 for all sites. In contrast, for Delta= 2π * 10 MHz, the density shows a clear Z_2 ordered profile","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, ax = plt.subplots(figsize = (10, 4))\nax.bar(1:nsites, density_g[30, :])\nax.set_xticks(1:nsites)\nax.set_xlabel(\"Sites\")\nax.set_ylabel(\"Rydberg density\")\nax.set_title(\"Density Profile: 1D Chain, Δ = -2π * 10 MHz\")\nfig","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"More generally, we can plot an order parameter as a function of Delta to clearly see the onset of phase transition. The order parameter can be defined as the difference of Rydberg densities on even and odd sites.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"order_para = map(1: Δ_step) do ii\n    sum(density_g[ii, 1:2:nsites]) - sum(density_g[ii, 2:2:nsites])\nend\n\nfig, ax = plt.subplots(figsize = (10,4))\nax.plot(Δ/2π, order_para)\nax.set_xlabel(\"Δ/2π (MHz) \")\nax.set_ylabel(\"Order parameter\")\nfig","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"From the density profile of ground states and the change in the order parameter, we can observe a phase transition with changing Delta. Below, we show that by slowly changing the parameters of the Hamiltonian, we can follow the trajectory of the ground states and adiabatically evolve the atoms from the ground state to the Z_2 ordered state.","category":"page"},{"location":"tutorials/adiabatic/main/#Preparation-of-ordered-states-in-1D","page":"Adiabatic Evolution","title":"Preparation of ordered states in 1D","text":"","category":"section"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We first specify the adiabatic pulse sequence for Rabi frequency by using the built-in waveform function piecewise_linear.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"total_time = 3.0;\nΩ_max = 2π * 4;\nΩ = piecewise_linear(clocks = [0.0, 0.1, 2.1, 2.2, total_time], values = [0.0, Ω_max, Ω_max, 0, 0]);","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The detuning sequence can also be created in a similar way.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"U1 = -2π * 10;\nU2 = 2π * 10;\nΔ = piecewise_linear(clocks = [0.0, 0.6, 2.1, total_time], values = [U1, U1, U2, U2]);","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We plot the two waveforms:","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, (ax1, ax2) = plt.subplots(ncols = 2, figsize = (12, 4))\ndraw!(ax1, Ω/2π)\nax1.set_ylabel(\"Ω/2π MHz\")\ndraw!(ax2, Δ/2π)\nax2.set_ylabel(\"Δ/2π MHz\")\nfig","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We generate the positions of a 1D atomic chain again:","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nsites = 9\natoms = generate_sites(ChainLattice(), nsites, scale = 5.72)","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"47.27mm\" viewBox=\"0 0 120 47.27\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.88\" id=\"img-86237d0f-1\">\n  <g transform=\"translate(23.64,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.82,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">11.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">22.88μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.18,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">34.32μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.36,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">45.76μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.82,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"0.44\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-86237d0f-2\">\n  <g transform=\"translate(23.64,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(32.73,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(41.82,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(50.91,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(69.09,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(78.18,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(87.27,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(96.36,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"2.57\" id=\"img-86237d0f-3\">\n  <g transform=\"translate(23.64,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(32.73,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.82,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(50.91,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(69.09,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.18,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(87.27,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.36,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Note that we have specified the nearest-neighbor atoms to be seperated by 5.72 mu m in order to prepare a Z_2 ordered state. With the waveforms and atomic coordinates specified, the time-dependent Hamiltonian can be simply generated by","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"h = rydberg_h(atoms; Δ, Ω)","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nqubits: 9\n+\n├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n├─ [+] Ω(t) ⋅ ∑ σ^x_i\n└─ [-] Δ(t) ⋅ ∑ n_i\n","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We then specify all atoms to be in the ground state initially, and set up the emulation problem by choosing an ODE solver","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"reg = zero_state(9);\nprob = SchrodingerProblem(reg, total_time, h);\nintegrator = init(prob, Vern8());","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The default for the integrator is to use adaptive steps. One can use TimeChoiceIterator to specify the time points one would like to measure some observables. Here, we measure the Rydberg density on each site","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"densities = []\nfor _ in TimeChoiceIterator(integrator, 0.0:1e-3:total_time)\n    push!(densities, [expect(put(nsites, i=>Op.n), reg) for i in 1:nsites])\nend\nD = hcat(densities...);","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"and finally plot the time-dependent dynamics of Rydberg density for each site","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"fig, ax = plt.subplots(figsize = (10,4))\nshw = ax.imshow(real(D), interpolation=\"nearest\", aspect=\"auto\", extent=[0,total_time,0.5,nsites+0.5])\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"site\")\nax.set_xticks(0:0.2:total_time)\nax.set_yticks(1:nsites)\nbar = fig.colorbar(shw)\nfig","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We can clearly see that a Z_2 ordered state has been generated by the specified adiabatic pulse sequence. We can also confirm it by plotting the bitstring distribution at the final time step","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"bitstring_hist(reg; nlargest = 20)","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"To prepare the Z_3 or Z_4 states, we can reduce the separation between nearby atoms to 3.57 mu m or 2.87 mu m respectively. Please refer to the Rydberg Blockade page on how to set the separation distance for preparing the ordered states.","category":"page"},{"location":"tutorials/adiabatic/main/#Emulation-in-the-blockade-subspace","page":"Adiabatic Evolution","title":"Emulation in the blockade subspace","text":"","category":"section"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"In the above example, we have run the fullspace emulation, without truncating the Hilbert space. To speed up the emulation, we can also run it in the blockade subspace, throwing out the configurations of the Hilbert space that violate the blockade constraint. See subspace for more details. This can be done by changing the register to a RydbergReg by feeding a subspace object.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The subspace can be found by looking up the independent sets of the graph constructed by a subspace radius; here we choose the subspace radius to be 5.73 mu m","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"space = blockade_subspace(atoms, 5.73);","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Then create our register in the subspace","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"reg = zero_state(space)","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"YaoSubspaceArrayReg.SubspaceArrayReg{Vector{ComplexF64}, BloqadeExpr.Subspace{Vector{Int64}}}(9, ComplexF64[1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im], BloqadeExpr.Subspace{Vector{Int64}}(9, Dict(5 => 5, 265 => 62, 325 => 81, 32 => 14, 136 => 40, 145 => 44, 73 => 28, 272 => 64, 164 => 51, 320 => 77, 337 => 86, 64 => 22, 324 => 80, 4 => 4, 168 => 53, 328 => 82, 148 => 46, 256 => 56, 277 => 68, 264 => 61, 41 => 20, 69 => 26, 36 => 17, 68 => 25, 82 => 32, 85 => 34, 130 => 37, 162 => 50, 84 => 33, 321 => 78, 66 => 24, 292 => 72, 34 => 16, 2 => 3, 10 => 8, 18 => 11, 261 => 60, 296 => 74, 336 => 85, 42 => 21, 144 => 43, 132 => 38, 273 => 65, 257 => 57, 169 => 54, 16 => 9, 20 => 12, 81 => 31, 290 => 71, 341 => 89, 160 => 48, 340 => 88, 0 => 1, 289 => 70, 329 => 83, 266 => 63, 9 => 7, 146 => 45, 74 => 29, 138 => 42, 161 => 49, 276 => 67, 128 => 35, 21 => 13, 170 => 55, 129 => 36, 260 => 59, 297 => 75, 133 => 39, 72 => 27, 258 => 58, 8 => 6, 17 => 10, 37 => 18, 1 => 2, 137 => 41, 338 => 87, 288 => 69, 80 => 30, 33 => 15, 274 => 66, 149 => 47, 40 => 19, 65 => 23, 330 => 84, 293 => 73, 165 => 52, 298 => 76, 322 => 79), [0, 1, 2, 4, 5, 8, 9, 10, 16, 17, 18, 20, 21, 32, 33, 34, 36, 37, 40, 41, 42, 64, 65, 66, 68, 69, 72, 73, 74, 80, 81, 82, 84, 85, 128, 129, 130, 132, 133, 136, 137, 138, 144, 145, 146, 148, 149, 160, 161, 162, 164, 165, 168, 169, 170, 256, 257, 258, 260, 261, 264, 265, 266, 272, 273, 274, 276, 277, 288, 289, 290, 292, 293, 296, 297, 298, 320, 321, 322, 324, 325, 328, 329, 330, 336, 337, 338, 340, 341]))","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"The rest of codes will be the same as the fullspace","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"prob = SchrodingerProblem(reg, total_time, h)\nemulate!(prob)\nbitstring_hist(prob.reg; nlargest = 20)","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/#State-preparation-in-2D","page":"Adiabatic Evolution","title":"State preparation in 2D","text":"","category":"section"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Now we show how to prepare a 2D checkerboard phase. Most of codes will be the same as the 1D case, except that we will choose slightly different parameters and specify a square lattice instead of a chain","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nx, ny = 3, 3\nnsites = nx*ny\natoms = generate_sites(SquareLattice(), nx, ny, scale = 6.7)\n\ntotal_time = 2.9\nΩ_max = 2π * 4.3\nΩ = piecewise_linear(clocks=[0.0, 0.3, 2.6, total_time], values=[0.0, Ω_max , Ω_max , 0]);\n\nU = 2π * 15.0\nΔ = piecewise_linear(clocks=[0.0, 0.3, 2.6, total_time], values=[-U, -U, U , U]);\n\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(10, 4))\ndraw!(ax1, Ω/2π)\nax1.set_ylabel(\"Ω/2π MHz\")\ndraw!(ax2, Δ/2π)\nax2.set_ylabel(\"Δ/2π MHz\")\nfig\n\nh = rydberg_h(atoms; Δ, Ω)\n\nreg = zero_state(9);\nprob = SchrodingerProblem(reg, total_time, h);\nintegrator = init(prob, Vern8());","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Again, we can use TimeChoiceIterator to specify the time points for measuring some observables.","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"densities = [];\nfor _ in TimeChoiceIterator(integrator, 0.0:1e-3:total_time)\n    push!(densities, [expect(put(nsites, i=>Op.n), reg) for i in 1:nsites])\nend\nD = hcat(densities...)\n\nfig, ax = plt.subplots(figsize = (10,4))\nshw = ax.imshow(real(D), interpolation=\"nearest\", aspect=\"auto\", extent=[0,total_time,0.5,nsites+0.5])\nax.set_xlabel(\"time (μs)\")\nax.set_ylabel(\"site\")\nax.set_xticks(0:0.2:total_time)\nax.set_yticks(1:nsites)\nbar = fig.colorbar(shw)\nfig","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"","category":"page"},{"location":"tutorials/adiabatic/main/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"This page was generated using Literate.jl.","category":"page"},{"location":"cuda/#CUDA-Acceleration","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"","category":"section"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"The emulator supports CUDA acceleration, to use CUDA acceleration, you will need NVIDIA graphic card.","category":"page"},{"location":"cuda/#Installation","page":"CUDA Acceleration","title":"Installation","text":"","category":"section"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"To use CUDA accelerators, you need to install CUDA package","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"pkg> add CUDA","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"This will automatically download all needed dependencies of CUDA toolkit.","category":"page"},{"location":"cuda/#Using-CUDA","page":"CUDA Acceleration","title":"Using CUDA","text":"","category":"section"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"Converting your CPU-based simulation to CUDA-based simulation is simple, just use the cu function from CUDA on the register object, which will convert the CPU-based register to a CUDA-based register, e.g","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"using CUDA\nreg = zero_state(5)\ndreg = cu(reg) # device register","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"For emulation, you can call cu on your emulation object to convert everything (emulation intermediate memory etc.) into GPU memory, e.g","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"cu(KrylovEvolution(reg, clocks, h))","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"other code in the emulator should adapt to CUDA automatically.","category":"page"},{"location":"topics/ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables/#Yao-Register-Interface","page":"Observables","title":"Yao Register Interface","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"Bloqade register are Yao registers, thus they support all the interfaces Yao supports, this including","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"measure: measure the register.\nexpect: calculate the expectation on given observable operator.","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"the observable operator can be constructed in the same way of hamiltonian expression, e.g","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"using Bloqade\nr = rand_state(10) # create a register with random state\nexpect(SumOfN(nsites=10), r) # calculates rydberg density","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"one can also measure on the register","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"measure(r; nshots=10)","category":"page"},{"location":"observables/#Convenient-Wrappers","page":"Observables","title":"Convenient Wrappers","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"Bloqade also provides a few convenient wrappers on commonly used observables","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"rydberg_density\nrydberg_corr","category":"page"},{"location":"observables/#Bloqade.rydberg_density","page":"Observables","title":"Bloqade.rydberg_density","text":"rydberg_density(reg, i::Int) -> Real\n\nCalculates the rydberg density at site i.\n\nlangle n_i rangle\n\n\n\n\n\nrydberg_density(reg) -> Vector\n\nReturn the rydberg density at each site.\n\n\n\n\n\n","category":"function"},{"location":"observables/#Bloqade.rydberg_corr","page":"Observables","title":"Bloqade.rydberg_corr","text":"rydberg_corr([op=Op.n], reg) -> Matrix\n\nCalculates the rydberg correlation matrix.\n\nlangle textop_i textop_j rangle\n\nhere op can be Op.n, X or Y.\n\nArguments\n\nop: the correlation function, default is Op.n.\nreg: required, the register object.\n\n\n\n\n\n","category":"function"},{"location":"observables/#Create-general-observables-using-operator-expression","page":"Observables","title":"Create general observables using operator expression","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"Bloqade make use of Yao's block system to represent operator expression, e.g one can construct the Rydberg correlation operator as","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"corr(n, i, j) = chain(n, put(i=>Op.n), put(j=>Op.n))","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"You can make up any kind of quantum operator in this way and use it with the expect or measure function.","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"And because the hamiltonian is also an operator expression, thus it can be used as an observable too","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"r = rand_state(5)\npos = [(i, ) for i in 1:5]\nh = rydberg_h(pos; Ω=0.1)\nexpect(h, r)","category":"page"},{"location":"observables/#Reference","page":"Observables","title":"Reference","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"Here are some common operators re-exported from Yao.","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"expect\nmeasure\nX\nY\nZ","category":"page"},{"location":"observables/#YaoAPI.expect","page":"Observables","title":"YaoAPI.expect","text":"expect(op::AbstractBlock, reg) -> Vector\nexpect(op::AbstractBlock, reg => circuit) -> Vector\nexpect(op::AbstractBlock, density_matrix) -> Vector\n\nGet the expectation value of an operator, the second parameter can be a register reg or a pair of input register and circuit reg => circuit.\n\nexpect'(op::AbstractBlock, reg=>circuit) -> Pair expect'(op::AbstractBlock, reg) -> AbstracRegister\n\nObtain the gradient with respect to registers and circuit parameters. For pair input, the second return value is a pair of gψ=>gparams, with gψ the gradient of input state and gparams the gradients of circuit parameters. For register input, the return value is a register.\n\nnote: Note\nFor batched register, expect(op, reg=>circuit) returns a vector of size number of batch as output. However, one can not differentiate over a vector loss, so expect'(op, reg=>circuit) accumulates the gradient over batch, rather than returning a batched gradient of parameters.\n\n\n\n\n\n","category":"function"},{"location":"observables/#YaoAPI.measure","page":"Observables","title":"YaoAPI.measure","text":"measure([, operator], register[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -> Vector{Int}\n\nReturn measurement results of qudits in locs. If locs is not provided, all current active qudits are measured (regarding to active qudits, see focus! and relax!).\n\n\n\n\n\n","category":"function"},{"location":"observables/#YaoBlocks.ConstGate.X","page":"Observables","title":"YaoBlocks.ConstGate.X","text":"X\nXGate <: ConstantGate{1,2}\n\nPauli X gate. X is the instance of XGate.\n\n\n\n\n\n","category":"constant"},{"location":"observables/#YaoBlocks.ConstGate.Y","page":"Observables","title":"YaoBlocks.ConstGate.Y","text":"Y\nYGate  <: ConstantGate{1,2}\n\nPauli Y gate. Y is the instance of YGate.\n\n\n\n\n\n","category":"constant"},{"location":"observables/#YaoBlocks.ConstGate.Z","page":"Observables","title":"YaoBlocks.ConstGate.Z","text":"Z\nZGate  <: ConstantGate{1,2}\n\nPauli Z gate. Z is the instance of YGate.\n\n\n\n\n\n","category":"constant"},{"location":"topics/bravais/#bravais-lattice","page":"Bravais Lattice","title":"Bravais Lattice","text":"","category":"section"},{"location":"registers/#Registers","page":"Registers","title":"Registers","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"Bloqade follows the register interface in Yao. It uses register to  represent a device and its internal quantum state. As for our Rydberg emulator, the most commonly used register types are ArrayReg and SubspaceArrayReg. They both use a dense array to store the corresponding quantum state. The only difference is that SubspaceArrayReg also stores a subspace object.","category":"page"},{"location":"registers/#Basic-Interfaces","page":"Registers","title":"Basic Interfaces","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"To create a register with its internal state to be Rydberg ground state  0000 rangle, we can simply use  the function zero_state by specifying the number of qubits","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"using Bloqade\nzero_state(5) # creates a 5-qubit register","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"To create a more general polarized product state, you can use the product_state function by inputing its bit-string","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"product_state(bit\"10011\")","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"where bit\"10011 is a special Julia string literal defined for bitstrings.","category":"page"},{"location":"registers/#Operations","page":"Registers","title":"Operations","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"You can perform various operations on registers via standard Yao register interface. This includes applying operators on quantum  states by using apply!, measuring certain observables with  projection on the quantum state by using measure!, and calculating the expectation value of certain observables by using  expect. To inspect the internal state of the register, one  can use the statevec method","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"reg = rand_state(3)\nmeasure(reg)\nexpect(put(1=>X), reg)\nstatevec(reg)","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"For more detailed introduction of register interface, please refer to Yao:Array Registers and Yao:AbstractRegister.","category":"page"},{"location":"registers/#References","page":"Registers","title":"References","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"arrayreg\napply!\nmeasure!\nstatevec\nzero_state\nrand_state\nproduct_state\nSubspaceArrayReg\nset_zero_state!","category":"page"},{"location":"registers/#YaoArrayRegister.arrayreg","page":"Registers","title":"YaoArrayRegister.arrayreg","text":"arrayreg(state; nbatch::Union{Integer,NoBatch}=NoBatch(), nlevel::Integer=2)\n\nCreate an array register, if nbatch is a integer, it will return a BatchedArrayReg.\n\n\n\n\n\narrayreg([T=ComplexF64], bit_str; nbatch=NoBatch())\n\nConstruct an array register from bit string literal. For bit string literal please read @bit_str.\n\nExamples\n\njulia> arrayreg(bit\"1010\")\nArrayReg{2, ComplexF64, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\njulia> arrayreg(ComplexF32, bit\"1010\")\nArrayReg{2, ComplexF32, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoAPI.apply!","page":"Registers","title":"YaoAPI.apply!","text":"apply!(register, block)\n\nApply a block (of quantum circuit) to a quantum register.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoAPI.measure!","page":"Registers","title":"YaoAPI.measure!","text":"measure!([postprocess,] [operator, ]register[, locs]; rng=Random.GLOBAL_RNG)\n\nMeasure current active qudits or qudits at locs. After measure and collapse,\n\n* do nothing if postprocess is `NoPostProcess`\n* reset to result state to `postprocess.config` if `postprocess` is `ResetTo`.\n* remove the qubit if `postprocess` is `RemoveMeasured`\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.statevec","page":"Registers","title":"YaoArrayRegister.statevec","text":"statevec(r::ArrayReg) -> array\n\nReturn a state matrix/vector by droping the last dimension of size 1. See also state.\n\nwarning: Warning\nstatevec is not type stable. It may cause performance slow down.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.zero_state","page":"Registers","title":"YaoArrayRegister.zero_state","text":"zero_state([T=ComplexF64], n::Int; nbatch::Int=1)\n\nCreate an AbstractArrayReg with total number of bits n. See also product_state, rand_state, uniform_state.\n\nExamples\n\njulia> zero_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\njulia> zero_state(ComplexF32, 4)\nArrayReg{2, ComplexF32, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\njulia> zero_state(ComplexF32, 4; nbatch=3)\nBatchedArrayReg{2, ComplexF32, Transpose...}\n    active qudits: 4/4\n    nlevel: 2\n    nbatch: 3\n\n\n\n\n\nzero_state([T=ComplexF64], n::Int, subspace)\n\nCreate a SubspaceArrayReg in zero state in given subspace.\n\nArguments\n\nT: optional, element type, default is ComplexF64.\nn: required, number of atoms (qubits).\nsubspace: required, the subspace of rydberg state.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.rand_state","page":"Registers","title":"YaoArrayRegister.rand_state","text":"rand_state([T=ComplexF64], n::Int; nbatch=1, no_transpose_storage=false)\n\nCreate a random AbstractArrayReg with total number of qudits n.\n\nExamples\n\njulia> rand_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\njulia> rand_state(ComplexF64, 4)\nArrayReg{2, ComplexF64, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\njulia> rand_state(ComplexF64, 4; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qudits: 4/4\n    nlevel: 2\n    nbatch: 2\n\n\n\n\n\nrand_state(subspace)\n\nCreate a random state in the given subspace.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoArrayRegister.product_state","page":"Registers","title":"YaoArrayRegister.product_state","text":"product_state([T=ComplexF64], bit_str; nbatch=NoBatch())\n\nCreate an ArrayReg with bit string literal defined with @bit_str. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> product_state(bit\"100\"; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qudits: 3/3\n    nlevel: 2\n    nbatch: 2\n\njulia> r1 = product_state(ComplexF32, bit\"100\"; nbatch=2)\nBatchedArrayReg{2, ComplexF32, Transpose...}\n    active qudits: 3/3\n    nlevel: 2\n    nbatch: 2\n\njulia> r2 = product_state(ComplexF32, [0, 0, 1]; nbatch=2)\nBatchedArrayReg{2, ComplexF32, Transpose...}\n    active qudits: 3/3\n    nlevel: 2\n    nbatch: 2\n\njulia> r1 ≈ r2   # because we read bit strings from right to left, vectors from left to right.\ntrue\n\n\n\n\n\nproduct_state([T=ComplexF64], total::Int, bit_config::Integer; nbatch=1, no_transpose_storage=false)\n\nCreate an ArrayReg with bit configuration bit_config, total number of bits total. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> product_state(4, 3; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qudits: 4/4\n    nlevel: 2\n    nbatch: 2\n\njulia> product_state(4, 0b1001; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qudits: 4/4\n    nlevel: 2\n    nbatch: 2\n\njulia> product_state(ComplexF32, 4, 0b101)\nArrayReg{2, ComplexF32, Array...}\n    active qudits: 4/4\n    nlevel: 2\n\nwarning: Warning\nThis interface will not check whether the number of required digits for the bit configuration matches the total number of bits.\n\n\n\n\n\nproduct_state(config, subspace)\n\nCreate a product state of given config from subspace.\n\n\n\n\n\n","category":"function"},{"location":"registers/#YaoSubspaceArrayReg.SubspaceArrayReg","page":"Registers","title":"YaoSubspaceArrayReg.SubspaceArrayReg","text":"SubspaceArrayReg <: AbstractRegister{2}\nSubspaceArrayReg(state, subspace)\n\nType for registers in a subspace. The subspace must be a Subspace.\n\n\n\n\n\n","category":"type"},{"location":"registers/#YaoSubspaceArrayReg.set_zero_state!","page":"Registers","title":"YaoSubspaceArrayReg.set_zero_state!","text":"set_zero_state!(register)\n\nSet the given register to |00...00⟩.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"EditURL = \"https://github.com/Happy-Diode/Bloqade.jl/blob/master/examples/noise/main.jl\"","category":"page"},{"location":"tutorials/noise/main/#Adiabatic-Preparation-with-Sensitivity-Analysis","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"","category":"section"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"using Bloqade\nusing CairoMakie\nusing BloqadePlots","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"┌ Warning: unknown command \\Join\n└ @ MathTeXEngine ~/.julia/packages/MathTeXEngine/ZP0gS/src/parser/commands_registration.jl:48\n","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"In this example, we examine the adiabatic preparation of a spin Hamiltonian with noise parameters to show the erro propagation feature.","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"We first prepare the adiabatic pulse sequence as two piecewise linear functions the first part considers Hamiltonian parameters with time-dependent global noise (where each atom site is subject to the same noise)","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"define the rabi waveform","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"Ω_src = 2.3 * 2 * pi","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"14.451326206513047","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"the noise strength can be specified by \\pm","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"Ω_max = Ω_src ± 0.001\nΩ = piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[0.0, Ω_max , Ω_max , 0])","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n               20 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⢰⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ ","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"define the noisy detuning waveform","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"U = Ω_src / 2.3 ± 0.001\nΔ = piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[-6*U, -6*U, 2*U , 2*U])","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n               20 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⡟⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n              -40 │⠒⠒⠒⠒⠒⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ ","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"We prepare a square lattice of 9 atoms create the atom positions","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"nx, ny = 3, 3\nnsites = nx*ny\n\natoms = generate_sites(SquareLattice(), nx, ny, scale=9.629)","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"120mm\" viewBox=\"0 0 120 120\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.88\" id=\"img-08109db7-1\">\n  <g transform=\"translate(35,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9.63μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">19.26μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9.63μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">19.26μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"1.2\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-08109db7-2\">\n  <g transform=\"translate(35,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(35,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(35,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"7.06\" id=\"img-08109db7-3\">\n  <g transform=\"translate(35,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(35,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(35,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"We construct the Rydberg Hamiltonian from the defined noisy rabi and detuning waveforms","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"h = rydberg_h(atoms; C=2 * pi * 858386, Δ, Ω)\n\nusing SparseArrays","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"We evolve the system from the zero state using the ODE solver to a final time t = 1.6 microseconds","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"prob = SchrodingerProblem(zero_state(Complex{Measurement{Float64}}, 9), 1.6±0.0, h)\nemulate!(prob) # run the time evolution directly","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"SchrodingerProblem:\n  register info:\n    type: YaoArrayRegister.ArrayReg{2, Complex{Measurements.Measurement{Float64}}, Matrix{Complex{Measurements.Measurement{Float64}}}}\n    storage size: 8 bytes\n\n  time span (μs): (0.0 ± 0.0, 1.6 ± 0.0)\n\n  equation: \n    storage size: 184.023 KiB\n    expression:\nnqubits: 9\n+\n├─ [+] ∑ 5.39e6/|r_i-r_j|^6 n_i n_j\n├─ [+] Ω(t) ⋅ ∑ σ^x_i\n└─ [-] Δ(t) ⋅ ∑ n_i\n\n\n  options:\n    save_everystep: false\n    save_start: false\n    save_on: false\n    dense: false\n","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"We compute the Rydberg probability for each site, where each of the results contains an error bar","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"densities = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"9-element Vector{Measurements.Measurement{Float64}}:\n 0.806694 ± 2.5e-5\n 0.422381 ± 5.5e-5\n 0.806694 ± 2.5e-5\n 0.422381 ± 5.5e-5\n 0.440296 ± 5.5e-5\n 0.422381 ± 5.5e-5\n 0.806694 ± 2.5e-5\n 0.422381 ± 5.5e-5\n 0.806694 ± 2.5e-5","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"the second part considers Hamiltonian parameters with time-dependent local noise (where each atom site is subject to independent noise)","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"each atom is subject to an indenpendent noise","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"Ω = map(1:9) do idx\n    piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[0.0, Ω_max, Ω_max , 0])\nend\n\nΔ = map(1:9) do idx\n    piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[-6*U, -6*U, 2*U , 2*U])\nend","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"9-element Vector{BloqadeWaveforms.Waveform{BloqadeWaveforms.PiecewiseLinear{Measurements.Measurement{Float64}, Interpolations.Extrapolation{Measurements.Measurement{Float64}, 1, Interpolations.GriddedInterpolation{Measurements.Measurement{Float64}, 1, Measurements.Measurement{Float64}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Float64}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Throw{Nothing}}}, Float64}}:\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"define the Hamiltonian","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"h = rydbergh(atoms; C=2 * pi * 858386, Δ, Ω) prob = ODEEvolution(zerostate(9), 1.6±0.0, h) emulate!(prob) # run the time evolution directly","category":"page"},{"location":"tutorials/noise/main/#measure-the-Rydberg-density-for-each-site","page":"Adiabatic Preparation with Sensitivity Analysis","title":"measure the Rydberg density for each site","text":"","category":"section"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"densities = map(1:nsites) do i     real(expect(put(nsites, i=>Op.n), prob.reg)) end","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"","category":"page"},{"location":"tutorials/noise/main/","page":"Adiabatic Preparation with Sensitivity Analysis","title":"Adiabatic Preparation with Sensitivity Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"CurrentModule = Bloqade","category":"page"},{"location":"hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Hamiltonian encodes essential physical properties of a quantum system. One can use the Rydberg Hamiltonian to  understand the ground state properties of the corresponding system and to generate interesting quantum dynamics.  The Rydberg Hamiltonian is generally specified by atom positions, Rabi frequencies and detunings. In Bloqade,  we can easily create a Hamiltonian by inputting these information, including lattice and Rabi frequencies and detunings, into the function rydberg_h. Furthermore, by inputing waveforms for the Rabi frequency and  detuning, we can easily generate time-dependent Hamiltonians. ","category":"page"},{"location":"hamiltonians/#Building-Time-Independent-Hamiltonians","page":"Hamiltonians","title":"Building Time-Independent Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"To specify the Hamiltonian, we first need to specify the atom positions, which determine the Rydberg intearctions strengths between pairs of atoms. Here we generate a square lattice by using the code below.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3, scale=6.3)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Please refer to Lattices page for more details about generating lattice and relevant operations. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Then the Hamiltonian can be simply built by inputing the generated atom positions atoms and by specifying the strength of Rabi detuning Δ, Rabi frequency Ω, and laser phase ϕ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h0 = rydberg_h(atoms; Δ=1.2, Ω=1.1, ϕ=2.1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Note that the default value for the Rydberg interaction constant is C = 2pi times 862690 text MHz μm^6 to match the experimental unit. For more information about units, please  refer to Bloqade. Instead of using the default value of C, the users are free to set their own values. For instance, if the users would like to have a chain lattice with  nearest-neighbour atoms seperted by 1, and interaction strength to be a particular value, say, 14^6, it can be done with the following codes","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"atoms = generate_sites(SquareLattice(), 3, 3, scale=1)\nh0 = rydberg_h(atoms; C=1.4^6, Δ=1.2, Ω=1.1, ϕ=2.1)","category":"page"},{"location":"hamiltonians/#Building-Time-Dependent-Hamiltonians","page":"Hamiltonians","title":"Building Time-Dependent Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"One can also directly use waveforms (instead of contanst values of detuning, Rabi frequency, and laser phase) to build a time-dependent Hamiltonian.  First let us use the  generate_sites to create a list of atom coordinates. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"atoms = generate_sites(ChainLattice(), 5, scale=5.72)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Then we generate time-dependent pulses for Omega and Delta by using  piecewise_linear. For details about how to build waveforms, please refer to the section Waveforms. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Ω1 = piecewise_linear(clocks=[0.0, 0.1, 2.1, 2.2], values=[0.0, 6.0, 6.0, 0]);\nΔ1 = piecewise_linear(clocks=[0.0, 0.6, 2.1, 2.2], values=[-10.1, -10.1, 10.1, 10.1]);","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The time-dependent Hamiltonian is easily generated by inputting the waveforms into the function rydberg_h","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h1 = rydberg_h(atoms; Δ=Δ1, Ω=Ω1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"By specifying the time of h1, we can  acess the Hamiltonian at a particular time, e.g. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"ht= h1 |> attime(0.5)","category":"page"},{"location":"hamiltonians/#Hamiltonian-Expressions","page":"Hamiltonians","title":"Hamiltonian Expressions","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Bloqade uses \"block\"s from Yao to build symbolic hamiltonian expressions. This gives users the flexiblity to define various different  kind of Hamltonian by simply writing down the expression.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Except standard operators from Yao, the following operators are supported by Bloqade:","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"RydInteract\nSumOfX\nSumOfXPhase\nSumOfZ\nSumOfN\nXPhase","category":"page"},{"location":"hamiltonians/#BloqadeExpr.RydInteract","page":"Hamiltonians","title":"BloqadeExpr.RydInteract","text":"struct RydInteract <: AbstractTerm\nRydInteract(;atoms, C=2π * 862690MHz⋅μm^6)\n\nType for Rydberg interactive term.\n\nExpression\n\nsum_i j fracCr_i - r_j^6 n_i n_j\n\nKeyword Arguments\n\natoms: a list of atom positions, must be type RydAtom, default unit is μm.\nC: the interaction strength, default unit is MHz⋅μm^6. default value is 2π * 862690 * MHz*µm^6.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfX","page":"Hamiltonians","title":"BloqadeExpr.SumOfX","text":"struct SumOfX <: AbstractTerm\nSumOfX(nsites, Ω)\n\nTerm for sum of X operators.\n\nThe following two expressions are equivalent\n\njulia> SumOfX(nsites=5)\n∑ σ^x_i\n\njulia> sum([X for _ in 1:5])\nnqudits: 1\n+\n├─ X\n├─ X\n├─ X\n├─ X\n└─ X\n\nExpression\n\nsum_i Ω σ^x_i\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfXPhase","page":"Hamiltonians","title":"BloqadeExpr.SumOfXPhase","text":"struct SumOfXPhase <: AbstractTerm\nSumOfXPhase(;nsites, Ω=1, ϕ)\n\nSum of XPhase operators.\n\nThe following two expressions are equivalent\n\njulia> SumOfXPhase(nsites=5, ϕ=0.1)\n1.0 ⋅ ∑ e^{0.1 ⋅ im} |0⟩⟨1| + e^{-0.1 ⋅ im} |1⟩⟨0|\n\njulia> sum([XPhase(0.1) for _ in 1:5])\nnqudits: 1\n+\n├─ XPhase(0.1)\n├─ XPhase(0.1)\n├─ XPhase(0.1)\n├─ XPhase(0.1)\n└─ XPhase(0.1)\n\nBut may provide extra speed up.\n\nExpression\n\nsum_i Ω  (e^ϕ  im 01 + e^-ϕ  im 10)\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfZ","page":"Hamiltonians","title":"BloqadeExpr.SumOfZ","text":"struct SumOfZ <: AbstractTerm\nSumOfZ(;nsites, Δ=1)\n\nSum of Pauli Z operators.\n\nThe following two expression are equivalent\n\njulia> SumOfZ(nsites=5)\n∑ σ^z_i\n\njulia> sum([Z for _ in 1:5])\nnqudits: 1\n+\n├─ Z\n├─ Z\n├─ Z\n├─ Z\n└─ Z\n\nExpression\n\nsum_i Δ  σ^z_i\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.SumOfN","page":"Hamiltonians","title":"BloqadeExpr.SumOfN","text":"struct SumOfN <: AbstractTerm\nSumOfN(;nsites[, Δ=1])\n\nSum of N operators. \n\nThe following two expression are equivalent\n\njulia> SumOfN(nsites=5)\n∑ n_i\n\njulia> sum([Op.n for _ in 1:5])\nnqudits: 1\n+\n├─ P1\n├─ P1\n├─ P1\n├─ P1\n└─ P1\n\nBut may provide extra speed up.\n\nExpression\n\nsum_i Δ  n_i\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.XPhase","page":"Hamiltonians","title":"BloqadeExpr.XPhase","text":"XPhase{T} <: PrimitiveBlock{2}\n\nXPhase operator.\n\ne^ϕ  im 01 + e^-ϕ  im 10\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"As an example, we can explicitly add up these terms to compose a new hamiltonian, e.g","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using Bloqade\nh = SumOfX(5, 1.0) + SumOfZ(5, 1.0)","category":"page"},{"location":"hamiltonians/#Convert-Hamiltonian-to-Matrices","page":"Hamiltonians","title":"Convert Hamiltonian to Matrices","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Hamiltonian expression can be converted to a matrix via the mat interface from Yao.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"mat","category":"page"},{"location":"hamiltonians/#YaoAPI.mat","page":"Hamiltonians","title":"YaoAPI.mat","text":"mat([T=ComplexF64], blk)\n\nReturns the matrix form of given block.\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"This method will return the most compact matrix representation of the operator, e.g","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"mat(X) # will return a PermMatrix\nmat(ht) # will return a SparseMatrixCSC","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The hamiltonian matrix can also be created in a subspace, such as the blockade subspace (see also Rydberg Blockade and Maximum Independent Set). This will allow one to work in larger system size.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"For Rydberg hamiltonian, we can create the subspace via blockade_subspace method, e.g","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"space = blockade_subspace(atoms, 7.5)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The above code means that the blocakde subspace only includes states where there is only one Rydberg excitation  within the distance of 75 mu m. If we have a chain of atoms seperated by 572 mu m, the blocakde subspace  does not contains states with nearest-neighbour atoms being simutaniously excited. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Once we have defined the space, we can convert the Hamiltonain to matrice in subspace basis via the codes below","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h_m = mat(ht, space)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We can see that the size of the matrices in blockade susbpace is much smaller than that in the full space. ","category":"page"},{"location":"hamiltonians/#Diagonalization-of-the-Hamiltonian","page":"Hamiltonians","title":"Diagonalization of the Hamiltonian","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Bloqade doesn't provide any diagonalization tool, as there are already lots of tools in Julia ecosystem. Here, we demonstrate how to use KrylovKit package for this purpose as following","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using KrylovKit\nvals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where the vals and vecs store calculated eigenvalues and eigenvectors respectively. ","category":"page"},{"location":"hamiltonians/#Low-level-representation-of-the-Hamiltonian","page":"Hamiltonians","title":"Low-level representation of the Hamiltonian","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Besides the symbolic representation, in order to achieve highest performance possible, we use a lower-level representation of the Hamiltonian in Bloqade, which is the Hamiltonian and StepHamiltonian type.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"BloqadeExpr.Hamiltonian\nBloqadeExpr.StepHamiltonian","category":"page"},{"location":"hamiltonians/#BloqadeExpr.Hamiltonian","page":"Hamiltonians","title":"BloqadeExpr.Hamiltonian","text":"struct Hamiltonian\n\nHamiltonian stores the dynamic prefactors of each term. The actual hamiltonian is the sum of f_i(t) * t_i where f_i and t_i are entries of fs and ts.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/#BloqadeExpr.StepHamiltonian","page":"Hamiltonians","title":"BloqadeExpr.StepHamiltonian","text":"struct StepHamiltonian\n\nA low-level linear-map object that encodes time-dependent hamiltonian at time step t. This object supports the linear map interface mul!(Y, H, X).\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The Hamiltonian type represents the following Hamiltonian expression","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"f_1(t) H_1 + f_2(t) H_2 + cdots + f_n(t) H_n + H_c","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where f_i(t) are time-dependent parameters of the Hamiltonian, H_i are time-independent local terms of the Hamiltonian as linear operator (in Julia, this means objects that supports LinearAlgebra.mul! interface). And H_c is the constant component of the Hamiltonian.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"A Hamiltonian object supports callable method, which will produce a StepHamiltonian that is time-independent, e.g","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using BloqadeExpr\nh = BloqadeExpr.Hamiltonian(Float64, SumOfX(5, sin) + SumOfZ(5, cos))\nh(0.1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Here, we see the hamiltonian expression written as Yao blocks are automatically analyzed into time-dependent terms and constant terms. A more complicated example can be SumOfXPhase","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using BloqadeExpr\nh = BloqadeExpr.Hamiltonian(Float64, SumOfXPhase(5, sin, cos) + SumOfZ(5, cos))\nh(0.1)","category":"page"},{"location":"hamiltonians/#References","page":"Hamiltonians","title":"References","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"rydberg_h","category":"page"},{"location":"hamiltonians/#BloqadeExpr.rydberg_h","page":"Hamiltonians","title":"BloqadeExpr.rydberg_h","text":"rydberg_h(atoms; [C=2π * 862690 * MHz*µm^6], Ω[, ϕ, Δ])\n\nCreate a rydberg hamiltonian\n\n fracCr_i - r_j^6 n_i n_j + fracΩ2 σ_x - Δ σ_n\n\nshorthand for\n\nRydInteract(C, atoms) + SumOfXPhase(length(atoms), Ω, ϕ) - SumOfN(length(atoms), Δ)\n\nArguments\n\natoms: a collection of atom positions.\n\nKeyword Arguments\n\nC: optional, default unit is MHz*µm^6, interation parameter,   see also RydInteract.\nΩ: optional, default unit is MHz, Rabi frequencies, divided by 2, see also SumOfX.\nΔ: optional, default unit is MHz, detuning parameter, see SumOfN.\nϕ: optional, does not have unit, the phase, see SumOfXPhase.\n\ntips: Tips\nThe rabi frequencies are divided by two in the Rydberg hamiltonian unlike directly constructing via SumOfX or SumOfXPhase.\n\ntips: Tips\nThe parameters of Hamiltonian have their own default units to match hardware, one can use Unitful.jl to specify their units explicitly. If the units are specified explicitly, they will be converted to default units automatically.\n\nExample\n\njulia> using Bloqade\n\njulia> atoms = [(1, ), (2, ), (3, ), (4, )]\n4-element Vector{Tuple{Int64}}:\n (1,)\n (2,)\n (3,)\n (4,)\n\njulia> rydberg_h(atoms)\n∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n\njulia> rydberg_h(atoms; Ω=0.1)\nnqubits: 4\n+\n├─ ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n└─ 0.05 ⋅ ∑ σ^x_i\n\n\n\n\n\n","category":"function"},{"location":"subspace/#subspace","page":"Working with Subspace","title":"Working with Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Due to the strong Rydberg interactions, only one Rydberg excitation is allowed within the blockade radius (see Rydberg Blockade). This is the called blockade constraint.  In Bloqade, we take advantage of this effect by allowing users to run emulation in a truncated subspace.  This is done by throwing out states that violate the blockade constraint.  This process could help us accelerate the emulation and reach a bigger system size. In this section, we will show how to create a blockade subsapce, create register in subspace,  obtain Hamiltonian matrix in subspace, and run emulation in subspace. ","category":"page"},{"location":"subspace/#Create-Blockade-Subspace","page":"Working with Subspace","title":"Create Blockade Subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"One can create a blockade subspace via blockade_subspace method","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"blockade_subspace","category":"page"},{"location":"subspace/#BloqadeMIS.blockade_subspace","page":"Working with Subspace","title":"BloqadeMIS.blockade_subspace","text":"blockade_subspace(atoms[, radius=1.0])\n\nCreate a blockade approximation subspace from given atom positions and radius.\n\n\n\n\n\n","category":"function"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"For example, we can construct a blockade subspace of a square lattice using the code below","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3, scale=5.1)\nspace = blockade_subspace(atoms, 5.2)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"where we have created a 3*3 square lattice with nearest neighbour atoms seperated by 51 mu m. Then we have created a blockade subpace with blockade radius being 52 mu m. This means that if two atoms have a distance that is smaller than (or equal to) 52 mu m, the blockade subspace does not contain states where both of them being in Rydberg states. The number of allowed states  is 63 in the above case, which is much smaller than the full Hilbert space 512. ","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Here space is of type Subspace","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Subspace","category":"page"},{"location":"subspace/#BloqadeExpr.Subspace","page":"Working with Subspace","title":"BloqadeExpr.Subspace","text":"Subspace{S <: AbstractVector{Int}} <: AbstractSpace\n\nA Dict-like object stores the mapping between subspace and full space.\n\n\n\n\n\n","category":"type"},{"location":"subspace/#Create-register-in-subspace","page":"Working with Subspace","title":"Create register in subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"One can create the register in subspace by feeding the space object instead of an integer for the common register interfaces, e.g","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"zero_state(space)\nproduct_state(bit\"000_000_001\", space)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"Or if you have an existing state stored as a subtype of AbstractVector, we can also create the register using the constructor","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"state = rand(ComplexF64, length(space))\nreg = SubspaceArrayReg(state, space)","category":"page"},{"location":"subspace/#Obtain-matrix-of-Hamiltonian-in-subspace","page":"Working with Subspace","title":"Obtain matrix of Hamiltonian in subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"The matrix in subspace of a given Hamiltonian can be obtained via mat as well, e.g","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"h1 = rydberg_h(atoms; Δ=0.2, Ω=0.1)\nmat(h1, space)","category":"page"},{"location":"subspace/#Run-emulation-in-subspace","page":"Working with Subspace","title":"Run emulation in subspace","text":"","category":"section"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"To run an emulation in subspace, one just need to use the subspace register SubspaceArrayReg instead of the fullspace register ArrayReg, e.g","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"reg = zero_state(space)\nprob = SchrodingerProblem(reg, 0.1, h1)\nemulate!(prob)\nstatevec(reg)","category":"page"},{"location":"subspace/","page":"Working with Subspace","title":"Working with Subspace","text":"The measurement in register with subspace is the same as that in the full space. ","category":"page"},{"location":"mis/#mis","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"","category":"section"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"One of the most important property of Rydberg system is the Rydberg blockade, which naturally embeds the maximum independent set problem into its ground state. In Bloqade, we provide several functions to work with such property and we will discuss them in this section.","category":"page"},{"location":"mis/#The-maximum-independent-set-problem","page":"Maximum Independent Set","title":"The maximum independent set problem","text":"","category":"section"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"In graph theory, an independent set is a set of vertices in a graph, no two of which are adjacent. The problem of finding maximum independent sets (MIS) is NP-hard, i.e. unlikely to be solved in a time polynomial to the problem size. Even aproximating the MIS size alpha(G) for a graph G=(VE) is hard. In this tutorial we study the MIS problem defined on diagonal-coupled unit-disk grid graphs (DUGG)(see arxiv:2202.09372). Although these graphs have highly constraint topology, finding its MISs is NP-hard. We show how to map the MIS problem on this graph to a Rydberg atom array hamiltonian, and use two quantum algorithms, the standard QAOA and a variational quantum algorithm with specially parametrized waveform, to find maximum independent sets.","category":"page"},{"location":"mis/#References","page":"Maximum Independent Set","title":"References","text":"","category":"section"},{"location":"mis/","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"Modules = [BloqadeMIS]","category":"page"},{"location":"mis/#BloqadeMIS.add_random_vertices","page":"Maximum Independent Set","title":"BloqadeMIS.add_random_vertices","text":"add_random_vertices([rng=GLOBAL_RNG], config::AbstractVector, graph::AbstractGraph, ntrials::Int = 10)\n\nAdd vertices randomly to given configuration for ntrials times and pick the one that has largest count_vertices.\n\nArguments\n\nrng: optional, Random Number Generator.\nconfig: configuration to tweak.\ngraph: problem graph.\nntrials: number of trials to use, default is 10.\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.anyone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"Maximum Independent Set","title":"BloqadeMIS.anyone","text":"anyone(index::Integer, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(0b1011, 0b1001)\ntrue\njulia> anyone(0b1011, 0b1100)\ntrue\njulia> anyone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.blockade_subspace","page":"Maximum Independent Set","title":"BloqadeMIS.blockade_subspace","text":"blockade_subspace(atoms[, radius=1.0])\n\nCreate a blockade approximation subspace from given atom positions and radius.\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.bmask","page":"Maximum Independent Set","title":"BloqadeMIS.bmask","text":"bmask(::Type{T}) where T <: Integer -> zero(T)\nbmask([T::Type], positions::Int...) -> T\nbmask([T::Type], range::UnitRange{Int}) -> T\n\nReturn an integer mask of type T where 1 is the position masked according to positions or range. Directly use T will return an empty mask 0.\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.count_vertices-Tuple{Integer}","page":"Maximum Independent Set","title":"BloqadeMIS.count_vertices","text":"count_vertices(config::Integer)\n\ncounter the number of vertices in a spin configuration.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.create_subspace_from_mis-Tuple{Int64, AbstractVector}","page":"Maximum Independent Set","title":"BloqadeMIS.create_subspace_from_mis","text":"create_subspace_from_mis(n::Int, mis::AbstractVector)\n\nCreate Subspace from given list of maximal cliques/maximal independent set.\n\nArguments\n\nn: number of vertices of the graph.\nmis: the list of maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.exact_solve_mis-Tuple{Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.exact_solve_mis","text":"exact_solve_mis(g::AbstractGraph)\n\nReturn the exact MIS size of a graph g.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.gibbs_loss-Tuple{Any, Real}","page":"Maximum Independent Set","title":"BloqadeMIS.gibbs_loss","text":"gibbs_loss([f], reg_or_samples, α::Real)\n\nThe Gibbs loss for maximum independent set defined as\n\nL = -1α log(langle ψexp(α sum(n))ψrangle)\n\nwhere n is the vertex set size.\n\nArguments\n\nf: optional, postprocessing callback function f(config) -> config.   The input config is an integer of type Int, the output   config can be a type supports count_vertices   e.g, an AbstractVector or an Integer.\nreg_or_samples can be a register (Yao.ArrayReg or SubspaceArrayReg)   or a list of measurement result (config) in AbstractVector.\nα::Real: the parameter of Gibbs loss.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.independent_set_probabilities","page":"Maximum Independent Set","title":"BloqadeMIS.independent_set_probabilities","text":"independent_set_probabilities([f], reg::YaoAPI.AbstractRegister, graph_or_mis)\n\nCalculate the probabilities of independent sets with given postprocessing function f(config) -> config. The default postprocessing function f will only reduce all configurations to independent set.\n\nArguments\n\nf: optional, postprocessing function, default is to_independent_set.\nreg: required, the register object.\ngraph_or_mis: a problem graph or the MIS size of the problem   graph (can be calculated via exact_solve_mis).\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.independent_set_subspace-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.independent_set_subspace","text":"independent_set_subspace(graph)\n\nCreate a subspace from given graph's maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.is_independent_set-Tuple{Any, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.is_independent_set","text":"is_independent_set(config, graph::AbstractGraph)\n\nReturn true if config is an independent set of graph. config can be a BitStr, a vector, or any iterable.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T<:Integer","page":"Maximum Independent Set","title":"BloqadeMIS.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.mean_rydberg","page":"Maximum Independent Set","title":"BloqadeMIS.mean_rydberg","text":"mean_rydberg([f], reg_or_samples)\n\nMean size of vertex set.\n\nArguments\n\nf: optional, postprocessing callback function f(config) -> config.   The input config is an integer of type Int, the output   config can be a type supports count_vertices   e.g, an AbstractVector or an Integer.\nreg_or_samples can be a register (Yao.ArrayReg or SubspaceArrayReg)   or a list of measurement result (config) in AbstractVector.\n\nExample\n\nTo implement the postprocessing protocal in MIS experiment:\n\ncalculating mean_rydberg by first reducing the configuration\n\nto independent set using to_independent_set\n\nrandomly adding vertices then pick the largest count_vertices\n\nusing add_random_vertices.\n\nmean_rydberg(r) do config\n    config = to_independent_set(config, graph)\n    add_random_vertices(config, graph, 10)\n    return config\nend\n\nOr one can also just add vertice by atom order\n\nmean_rydberg(r) do config\n    config = to_independent_set(config, graph)\n    add_vertices!(config, graph)\n    return config\nend\n\n\n\n\n\n","category":"function"},{"location":"mis/#BloqadeMIS.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.mis_postprocessing","text":"mis_postprocessing(config, graph::AbstractGraph; ntrials::Int=10)\n\nThe postprocessing protocal used in Harvard.\n\nArguments\n\nconfig: configuration to postprocess.\ngraph: the problem graph.\n\nKeyword Arguments\n\nntrials: number of trials to use.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.mis_postprocessing-Tuple{Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.mis_postprocessing","text":"mis_postprocessing(graph::AbstractGraph; ntrials::Int = 10)\n\nCurried version of mis_postprocessing.\n\nExample\n\nto calculate mean_rydberg loss with postprocessing used in Harvard experiment.\n\nmean_rydberg(mis_postprocessing(graph), reg)\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}","page":"Maximum Independent Set","title":"BloqadeMIS.num_mis_violation","text":"num_mis_violation(config, graph::AbstractGraph, i::Int)\n\nCalculate the number of MIS violations for i-th vertex in graph and configuration config. The config should be a subtype of AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.to_independent_set!","text":"to_independent_set!(config::AbstractVector, graph::AbstractGraph)\n\nEliminate vertices in config so that remaining vertices do not have connected edges. This algorithm is a naive vertex elimination that does not nesesarily give the maximum possible vertex set.\n\n# run the following code in Atom/VSCode\natoms = [(0.0, 1.0), (1.0, 0.), (2.0, 0.0), (1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]\ngraph = unit_disk_graph(atoms, 1.5)\n\nconfig = [1, 1, 1, 0, 1, 1]\nviz_config(atoms, graph, config)\n\nto_independent_set!(config, graph)\nviz_config(atoms, graph, config)\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.to_independent_set-Tuple{Integer, Graphs.AbstractGraph}","page":"Maximum Independent Set","title":"BloqadeMIS.to_independent_set","text":"to_independent_set(config::Integer, graph::AbstractGraph)\n\nEliminate vertices in config so that remaining vertices do not have connected edges without changing the original config, see also to_independent_set!.\n\n\n\n\n\n","category":"method"},{"location":"mis/#BloqadeMIS.unit_disk_graph","page":"Maximum Independent Set","title":"BloqadeMIS.unit_disk_graph","text":"unit_disk_graph(atoms::AbstractVector, radius=1)\n\nCreate a unit disk graph from atom positions atoms. It returns a Graphs.SimpleGraph instance.\n\natoms is vector of atoms positions.\nradius is the unit in the unit disk graph definition.\n\n\n\n\n\n","category":"function"},{"location":"lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"With Bloqade, we are going to be simulating the quantum evolution of information stored in neutral atoms. Present-day experimental platforms allow distribution of atoms in an organized lattice structure and even in  arbitrary shapes. This makes neutral atom a natural setup for quantum simulation of statistical models and quantum matter. With Bloqade, we support several built-in lattice structure and allow the users to specify atom positions by inputing coordinates.","category":"page"},{"location":"lattices/#Lattice-types","page":"Lattices","title":"Lattice types","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of mu m) plus atom locations in a unit cell. A Bravais lattice is an infinite array of decrete points generated by a set of discrete translation operations described by","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"mathbfR = n_1 mathbfa_1 + n_2 mathbfa_2 + ldots + n_d mathbfa_d","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where d is the dimension of space, n_1 ldots n_d in Z are integers. The unit cell of a Bravais lattice is defined by specifing its lattice vectors (mathbfa_1 mathbfa_2 ldots mathbfa_d). To create a simple lattice, we just place one site at location (0.0, 0.0) in a unit cell. For example, to create a triangular lattice, we can specify its lattice vector to be (1.0, 0.0) and (0.5, 0.5*sqrt(3)).","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using Bloqade\ntriangular = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"For composite lattices, one should provide multiple sites as the second argument to specify their locations in a unitcell. For example, the honeycomb lattice can be defined by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"honeycomb = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))],\n    [(0.0, 0.0), (0.5, 0.5/sqrt(3))])","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We provide a few shorthands for several useful lattices, inlucding the ChainLattice, SquareLattice, HoneycombLattice, TriangularLattice, LiebLattice, and KagomeLattice shown below.  One can use lattice_vectors and lattice_sites to access the lattice vectors and sites locations in a unit cell as described in the above section.","category":"page"},{"location":"lattices/#[ChainLattice](@ref)","page":"Lattices","title":"ChainLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using Bloqade\nchain = ChainLattice()","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"img_atoms(generate_sites(chain, 10))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"note: Note\nYou can see the above visulization in one of the following editorsa VSCode editor,\na Jupyter notebook,\nor a Pluto notebook,But not in a Julia REPL that does not have a graphical display.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(chain)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(chain)","category":"page"},{"location":"lattices/#[SquareLattice](@ref)","page":"Lattices","title":"SquareLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"square = SquareLattice()\nimg_atoms(generate_sites(square, 10, 10))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Note that the index showing on sites are consistent with the index of qubits for performing computation.  In other words, if we want to do measurment or apply opearations on individual sites (qubits), we can refer the numbering on atoms for convienience.  For more details about how to generate Hamiltonian by using lattice as an argument, please see the section Hamiltonians.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(square)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(square)","category":"page"},{"location":"lattices/#[HoneycombLattice](@ref)","page":"Lattices","title":"HoneycombLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"honeycomb = HoneycombLattice()\nimg_atoms(generate_sites(honeycomb, 5, 5))","category":"page"},{"location":"lattices/#[TriangularLattice](@ref)","page":"Lattices","title":"TriangularLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"triangular = TriangularLattice()\nimg_atoms(generate_sites(triangular, 8, 8))","category":"page"},{"location":"lattices/#[LiebLattice](@ref)","page":"Lattices","title":"LiebLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lieb = LiebLattice()\nimg_atoms(generate_sites(lieb, 5, 5))","category":"page"},{"location":"lattices/#[KagomeLattice](@ref)","page":"Lattices","title":"KagomeLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"kagome = KagomeLattice()\nimg_atoms(generate_sites(kagome, 5, 5))","category":"page"},{"location":"lattices/#Generate-and-sort-sites","page":"Lattices","title":"Generate and sort sites","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Once we have defined certain lattice shapes (which have fixed lattice vectors and site positions), we can generate the atom positons by  specifying the number of atoms and the scale size of the lattice.  This is done by using the function generate_sites , which will return a AtomList instance containing the coordinates for each atoms. e.g.  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms = generate_sites(HoneycombLattice(), 3, 5; scale=4.5)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where scale defines the unit distance in experimental unit (mu m) of the lattice, and 3, 5 specifies the repetitions of unit cells in each lattice vector direction.  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We also support different operations for the generated lattices. For instance,  one can apply predefined filters, e.g. rescale_axes, clip_axes, offset_axes, to manipulate atom locations.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"rescale_axes(atoms, 0.8)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where the above operation rescales the coordinates of original sites by a factor of 0.8. ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The code below restricts the atoms sitting in window (0.0, 5.0), (0.0, 6.0) and throw aways those outside this regime. ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Further, we can shift the origin of atoms by some vector (5.0, 5.0) simply by typing the code","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"offset_axes(atoms, 5.0, 5.0)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"To sort the atoms by the their x-coordinates, one can convert these locations to a MaskedGrid representation of the atoms.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms_in_grid = make_grid(atoms)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Then one can get the sorted atoms by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"sorted_atoms = collect_atoms(atoms_in_grid)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Note that the sorting has changed the index numbering of atoms. ","category":"page"},{"location":"lattices/#User-determined-arbitrary-lattices","page":"Lattices","title":"User-determined arbitrary lattices","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can also generate atoms located at arbitray positions by directly inputing the atoms' coordinates  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atom_coordinate = AtomList([(0.0, 0.0), (0, 5), (0, 8), (5, 2), (6, 7), (9, 6)])","category":"page"},{"location":"lattices/#Query-neighbors","page":"Lattices","title":"Query neighbors","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can use make_kdtree to generate a k-d tree data type for efficient querying neighborhoods in low dimensional space.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"tree = make_kdtree(sorted_atoms)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The return value is a KDTree instance, which is defined in package NearestNeigbors. One can use it to query the neighbors of an atom, e.g. one can find the 20 nearest neighbors of the 5-th site by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"neighbors = grouped_nearest(tree, 5, 20)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The return value is a DistanceGroup instance, and the indices of second nearest neighbors are","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"neighbors[2]","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can select and display these atoms with correct labeling by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"img_atoms(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"It show the correct second nearest neigbors of site 5. One can check the docstring of img_atoms to know more about how to custom lattice visualization.","category":"page"},{"location":"lattices/#References","page":"Lattices","title":"References","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Modules = [BloqadeLattices]","category":"page"},{"location":"lattices/#BloqadeLattices.AtomList","page":"Lattices","title":"BloqadeLattices.AtomList","text":"AtomList{D, T} <: AbstractVector{NTuple{D, T}}\nAtomList(atoms::Vector{<:NTuple})\n\nA list of atoms in D dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.ChainLattice","page":"Lattices","title":"BloqadeLattices.ChainLattice","text":"BloqadeLattices.ChainLattice <: AbstractLattice{1}\nBloqadeLattices.ChainLattice()\n\nBloqadeLattices.ChainLattice is a 1 dimensional lattice with:\n\nLattice vectors = ((1.0,),)\nLattice sites   = ((0.0,),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.DistanceGroup","page":"Lattices","title":"BloqadeLattices.DistanceGroup","text":"DistanceGroup\n\nThe vertices grouped by distances. One can use distancegroup[n] to get n-th nearest neighbors.\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.GeneralLattice","page":"Lattices","title":"BloqadeLattices.GeneralLattice","text":"GeneralLattice{D,K,T} <: AbstractLattice{D}\nGeneralLattice(vectors, sites)\n\nThe general lattice type for tiling the space. Type parameter D is the dimension, K is the number of sites in a unit cell and T is the data type for coordinates, e.g. Float64. Input arguments are\n\nvectors is a vector/tuple of D-tuple. Its length is D, it specifies the Bravais lattice vectors.\nsites is a vector/tuple of D-tuple. Its length is K, it specifies the sites inside a Bravais cell.\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.HoneycombLattice","page":"Lattices","title":"BloqadeLattices.HoneycombLattice","text":"BloqadeLattices.HoneycombLattice <: AbstractLattice{2}\nBloqadeLattices.HoneycombLattice()\n\nBloqadeLattices.HoneycombLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.5, 0.2886751345948129))\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.KagomeLattice","page":"Lattices","title":"BloqadeLattices.KagomeLattice","text":"BloqadeLattices.KagomeLattice <: AbstractLattice{2}\nBloqadeLattices.KagomeLattice()\n\nBloqadeLattices.KagomeLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.25, 0.4330127018922193), (0.75, 0.4330127018922193))\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.LiebLattice","page":"Lattices","title":"BloqadeLattices.LiebLattice","text":"BloqadeLattices.LiebLattice <: AbstractLattice{2}\nBloqadeLattices.LiebLattice()\n\nBloqadeLattices.LiebLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0), (0.5, 0.0), (0.0, 0.5))\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.MaskedGrid","page":"Lattices","title":"BloqadeLattices.MaskedGrid","text":"MaskedGrid{T}\nMaskedGrid(xs, ys, mask)\n\nMasked square lattice contains 3 fields, the x-coordinates, y-coordinates and a mask. e.g. MaskedGrid([0.0, 1.0, 3.0], [0.0, 2.0,6.0], Bool[1 0 0; 0 1 1; 0 1 0]) specifies the following lattice:\n\n     y₁   y₂        y₃\n     ↓    ↓         ↓\nx₁ → ●    ⋅         ●\nx₂ → ⋅    ●         ●\n\nx₃ → ⋅    ●         ⋅\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.RectangularLattice","page":"Lattices","title":"BloqadeLattices.RectangularLattice","text":"RectangularLattice <: AbstractLattice{2}\nRectangularLattice(aspect_ratio::Real)\n\nRectangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, aspect_ratio)\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.SquareLattice","page":"Lattices","title":"BloqadeLattices.SquareLattice","text":"BloqadeLattices.SquareLattice <: AbstractLattice{2}\nBloqadeLattices.SquareLattice()\n\nBloqadeLattices.SquareLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.TriangularLattice","page":"Lattices","title":"BloqadeLattices.TriangularLattice","text":"BloqadeLattices.TriangularLattice <: AbstractLattice{2}\nBloqadeLattices.TriangularLattice()\n\nBloqadeLattices.TriangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"lattices/#BloqadeLattices.clip_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{Tuple{T, T}, D}}} where {D, T}","page":"Lattices","title":"BloqadeLattices.clip_axes","text":"clip_axes(sites::AtomList{D, T}, bounds::Vararg{Tuple{T,T},D}) where {D, T}\nclip_axes(bounds...)\n\nRemove sites out of bounds, where bounds is specified by D D-tuples.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> clip_axes(sites, (-5.0, 5.0), (-5.0, 5.0))\n2-element AtomList{2, Float64}:\n (1.0, 2.0)\n (3.0, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.collect_atoms-Tuple{MaskedGrid}","page":"Lattices","title":"BloqadeLattices.collect_atoms","text":"collect_atoms(maskedgrid::MaskedGrid)\n\nReturns an list of atoms in the maskedgrid in order.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.dimension-Union{Tuple{AbstractLattice{D}}, Tuple{D}} where D","page":"Lattices","title":"BloqadeLattices.dimension","text":"dimension(lattice)\n\nReturns the space dimension of target lattice. e.g. ChainLattice is a 1D lattice, hence returns 1.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D","page":"Lattices","title":"BloqadeLattices.generate_sites","text":"generate_sites(lattice::AbstractLattice{D}, repeats::Vararg{Int,D}; scale=1.0)\n\nReturns an AtomList instance by tiling the specified lattice. The tiling repeat the sites of the lattice m times along the first dimension, n times along the second dimension, and so on. scale is a real number that re-scales the lattice constant and atom locations.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.grouped_nearest-Tuple{NearestNeighbors.KDTree, Int64, Int64}","page":"Lattices","title":"BloqadeLattices.grouped_nearest","text":"grouped_nearest(tree::KDTree, siteindex::Int, nsites::Int; atol=1e-8)\n\nFind the nsites closest vertices to siteindex, and group them by distance. Difference of the distances smaller than the atol (default is 1e-8) are treated as the same Returns a DistanceGroup instance.\n\njulia> atoms = generate_sites(HoneycombLattice(), 5, 5);\n\njulia> tree = make_kdtree(atoms)\nNearestNeighbors.KDTree{StaticArrays.SVector{2, Float64}, Distances.Euclidean, Float64}\n  Number of points: 50\n  Dimensions: 2\n  Metric: Distances.Euclidean(0.0)\n  Reordered: true\n\njulia> gn = grouped_nearest(tree, 23, 20)\nDistanceGroup([23, 14, 22, 24, 15, 13, 21, 25, 33, 31, 12, 16, 32, 4, 6, 34, 26, 17, 5, 41], [1, 2, 5, 11, 14, 18, 21])\n\njulia> gn[0]  # the 0-th nearest neighbor is defined by vertex itself\n1-element Vector{Int64}:\n 23\n\njulia> gn[1]  # nearest neighbors\n3-element Vector{Int64}:\n 14\n 22\n 24\n\njulia> gn[2]  # second nearest neighbors\n6-element Vector{Int64}:\n 15\n 13\n 21\n 25\n 33\n 31\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.img_atoms-Tuple{AtomList{2}}","page":"Lattices","title":"BloqadeLattices.img_atoms","text":"img_atoms(atoms::AtomList;\n    colors=[\"black\", \"black\", ...],\n    blockade_radius=0,\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    io=nothing,\n    kwargs...\n    )\n\nPlots atoms with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> using Compose\n\njulia> open(\"test.png\", \"w\") do f\n            img_atoms(generate_sites(SquareLattice(), 5, 5); io=f, format=Compose.PNG)\n       end\n\nThe format keyword argument can also be Compose.SVG or Compose.PDF. Atoms within blockade_radius will be connected by bonds.\n\nOther Keyword Arguments\n\n# overall scaling\nscale::Float64 = 1.0\n\n# padding space\npad::Float64 = 1.5 \n\n# axes\naxes_text_color::String = \"black\"\naxes_text_fontsize::Float64 = 11.0\naxes_num_of_xticks = 5\naxes_num_of_yticks = 5\naxes_x_offset::Float64 = 0.1\naxes_y_offset::Float64 = 0.06\naxes_unit::String = \"μm\"\n\n# node\nnode_text_fontsize::Float64 = 5.0\nnode_text_color::String = \"black\"\nnode_stroke_color = \"black\"\nnode_stroke_linewidth = 0.03\nnode_fill_color = \"white\"\n# bond\nbond_color::String = \"black\"\nbond_linewidth::Float64 = 0.03\n# blockade\nblockade_style::String = \"none\"\nblockade_stroke_color::String = \"black\"\nblockade_fill_color::String = \"transparent\"\nblockade_fill_opacity::Float64 = 0.5\nblockade_stroke_linewidth = 0.03\n# image size in cm\nimage_size::Float64 = 12\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.img_maskedgrid-Tuple{MaskedGrid}","page":"Lattices","title":"BloqadeLattices.img_maskedgrid","text":"img_maskedgrid(maskedgrid::MaskedGrid;\n    format=SVG,\n    io=nothing,\n    colors=nothing,\n    texts = nothing,\n    blockade_radius = 0,\n    kwargs...\n    )\n\nDraw a maskedgrid with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image.\n\nSee also the docstring of img_atoms for explanations of other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.lattice_sites-Tuple{GeneralLattice}","page":"Lattices","title":"BloqadeLattices.lattice_sites","text":"lattice_sites(lattice::AbstractLattice)\n\nReturns sites in a Bravais lattice unit cell as a Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.lattice_vectors-Tuple{GeneralLattice}","page":"Lattices","title":"BloqadeLattices.lattice_vectors","text":"lattice_vectors(lattice::AbstractLattice)\n\nReturns Bravais lattice vectors as a D-Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.make_grid-Union{Tuple{AtomList{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Lattices","title":"BloqadeLattices.make_grid","text":"make_grid(sites::AtomList; atol=...)\n\nCreate a MaskedGrid from the sites. It is required by lattice preparation of Rydberg array. Because the grid will sort the sites by rows, we need atol (default value is 10 time sit data precision) determines up to what level of round off error, two atoms belong to the same row.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.make_kdtree-Union{Tuple{AtomList{D, T}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Lattices","title":"BloqadeLattices.make_kdtree","text":"make_kdtree(atoms::AtomList{D,T}) where {T, D}\n\nReturns a KDTree instance defined in package NearestNeighbors from input atoms.\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.offset_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{T, D}}} where {D, T}","page":"Lattices","title":"BloqadeLattices.offset_axes","text":"offset_axes(sites::AtomList{D, T}, offsets::Vararg{T,D}) where {D, T}\noffset_axes(offsets...)\n\nOffset the sites by distance specified by offsets.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> offset_axes(sites, 1.0, 3.0)\n4-element AtomList{2, Float64}:\n (2.0, 5.0)\n (11.0, 6.0)\n (2.0, 15.0)\n (4.0, 8.0)\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.random_dropout-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"Lattices","title":"BloqadeLattices.random_dropout","text":"random_dropout(sites::AtomList{D, T}, ratio::Real) where {D, T}\nrandom_dropout(ratio)\n\nRandomly drop out ratio * number of sites atoms from sites, where ratio ∈ [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"lattices/#BloqadeLattices.rescale_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"Lattices","title":"BloqadeLattices.rescale_axes","text":"rescale_axes(sites::AtomList{D, T}, scale::Real) where {D, T}\nrescale_axes(scale)\n\nRescale the sites by a constant scale.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> rescale_axes(sites, 2.0)\n4-element AtomList{2, Float64}:\n (2.0, 4.0)\n (20.0, 6.0)\n (2.0, 24.0)\n (6.0, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"CurrentModule = Bloqade","category":"page"},{"location":"waveform/#Waveforms","page":"Waveforms","title":"Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms are essential ingredients for Rydberg quantum simulations. By controlling the waveforms of Omega and Delta, one can prepare the ground states of certain target Hamiltonians and study their non-equalibrium dynamics. With Bloqade, we support several built-in waveforms and allow the users to specify waveforms by inputing functions. We also support different operations of waveforms, such as smoothing, waveform, and composing, and more. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"The generated waveforms can be directly used to build time-dependent Hamiltonians, please see Hamiltonians section for more details. ","category":"page"},{"location":"waveform/#Creating-Waveforms","page":"Waveforms","title":"Creating Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In Bloqade, the waveforms are defined as Waveform object, which is a composition of a callable object and a real number duration.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"BloqadeWaveforms.Waveform","category":"page"},{"location":"waveform/#BloqadeWaveforms.Waveform","page":"Waveforms","title":"BloqadeWaveforms.Waveform","text":"Waveform{F, T <: Real}\n\nType for waveforms. Waveforms are defined as a function combiend with a real number duration.\n\nFields\n\nf: a callable object.\nduration: a real number defines the duration of this waveform.\n\n\n\n\n\n","category":"type"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade gives users the flexibility to specify general waveforms by inputing functions. The following code constructs a sinusoidal waveform with time duration of 4 pi mu s","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"using Bloqade\nusing BloqadePlots: draw, draw!\nusing PythonCall\nplt = pyimport(\"matplotlib.pyplot\")\nwaveform = Waveform(t->2.2sin(t), duration=4π);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"where BloqadePlots is a plotting package for objects from Bloqade, that you need to use explicitly. And in our documentation we use the python package matplotlib for plotting.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade supports built-in waveforms for convenience (see References below).  For example, the codes below create different waveform shapes with single lines:","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_linear(clocks=[0.0, 0.2, 0.5, 0.8, 1.0], values=[0.0, 1.5, 3.1, 3.1, 0.0]); \ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1]);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = linear_ramp(duration=0.5, start_value=0.0, stop_value=1.0);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform =  constant(duration=0.5, value=2.1);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = sinusoidal(duration=4π, amplitude=2.2); \ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In certain cases, users may have their own waveforms specified by a vector of clocks and a vector of signal strengths. To build a waveform from the two vectors, we can directly use the functions piecewise_linear or piecewise_constant, corresponding to different interpolations. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"clocks = collect(0:1e-1:2);\nvalues = rand(length(clocks));\nwf1 = piecewise_linear(;clocks, values); \nwf2 = piecewise_constant(;clocks, values); \n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\ndraw!(ax1, wf1)\ndraw!(ax2, wf2)\nfig","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"For more advanced interpolation options, please see the JuliaMath/Interpolations package.","category":"page"},{"location":"waveform/#Operations-of-Waveforms","page":"Waveforms","title":"Operations of Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade also supports several operations of the waveforms.  Waveforms can be sliced using the duration syntax start..stop, e.g","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = sinusoidal(duration=2.2);\nwf[1.1..1.5];\ndraw(wf)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms can be composed together via append","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf1 = Waveform(sin, duration=2.2);\nwf2 = linear_ramp(;start_value=0.0, stop_value=1.1, duration=0.5);\nwaveform = append(wf1, wf2); \ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"where the waveform w2 is appended at the end of w1. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Sharp waveforms may result in bad performance in practice (e.g. for adibatic preparing a ground state of target Hamiltnonian), it is sometimes preferred to smoothen the waveform using the moving average methods, one can use the smooth function to create a smooth-ed wavefrom from a piecewise linear waveform.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 3.0, 1.1, 2.2]);\nswf = smooth(wf);\ndraw(swf)","category":"page"},{"location":"waveform/#Waveform-Arithmetics","page":"Waveforms","title":"Waveform Arithmetics","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade also supports several arithmetics of waveforms. If two waveforms have the same duration, we can directly add up or subtract the strength of two waveforms, simply by using + or -. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf1 = linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0);\nwf2 = Waveform(sin, duration=2.2);\nwf3 = wf1 + wf2; \nwf4 = wf1 - wf2;\n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\ndraw!(ax1, wf3)\ndraw!(ax2, wf4)\nfig\n","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"If we want to increase the strength of a waveform by some times, we can directly use *","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0);\nwf_t = 3 * wf;\n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\ndraw!(ax1, wf)\ndraw!(ax2, wf_t)\nfig\n","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Such operation could also be broadcasted by using .*","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf2, wf3 = [2.0, 3.0] .* wf1; \n\nfig, (ax1, ax2) = plt.subplots(figsize=(12, 4), ncols=2)\ndraw!(ax1, wf2)\ndraw!(ax2, wf3)\nfig","category":"page"},{"location":"waveform/#References","page":"Waveforms","title":"References","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"piecewise_linear\npiecewise_constant\nlinear_ramp\nconstant\nsinusoidal\nsmooth\nsmooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)","category":"page"},{"location":"waveform/#BloqadeWaveforms.piecewise_linear","page":"Waveforms","title":"BloqadeWaveforms.piecewise_linear","text":"piecewise_linear(;clocks, values)\n\nCreate a piecewise linear waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\n\nExample\n\njulia> piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 2.0, 2.0, 0.0])\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀│ \n                  │⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀│ \n                  │⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀│ \n                  │⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆│ \n                0 │⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀ \n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.piecewise_constant","page":"Waveforms","title":"BloqadeWaveforms.piecewise_constant","text":"piecewise_constant(;clocks, values, duration=last(clocks))\n\nCreate a piecewise constant waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\nduration::Real: the duration of the entire waveform, default is the last clock.\n\nExample\n\njulia> piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1], duration=1.1)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢠⠒⠒⠒⠒⠒⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⣀⣀⣀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ \n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.linear_ramp","page":"Waveforms","title":"BloqadeWaveforms.linear_ramp","text":"linear_ramp(;duration, start_value, stop_value)\n\nCreate a linear ramp waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nstart_value::Real: start value of the linear ramp.\nstop_value::Real: stop value of the linear ramp.\n\nExample\n\njulia> linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                1 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀3⠀ \n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.constant","page":"Waveforms","title":"BloqadeWaveforms.constant","text":"constant(;duration::Real, value::Real)\n\nCreate a constant waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nvalue::Real: value of the constant waveform.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.sinusoidal","page":"Waveforms","title":"BloqadeWaveforms.sinusoidal","text":"sinusoidal(;duration::Real, amplitude::Real=one(start))\n\nCreate a sinusoidal waveform of the following expression.\n\namplitude * sin(t)\n\nKeyword Arguments\n\nduration: duration of the waveform.\namplitude: amplitude of the sin waveform.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.smooth","page":"Waveforms","title":"BloqadeWaveforms.smooth","text":"smooth([kernel=Kernel.gaussian], f; edge_pad_size::Int=length(f.clocks))\n\nKernel smoother function for piece-wise linear function/waveform via weighted moving average method.\n\nArguments\n\nkernel: the kernel function, default is Kernels.gaussian.\nf: a Union{PiecewiseLinear, PiecewiseConstant} function or a Waveform{<:Union{PiecewiseLinear, PiecewiseConstant}}.\n\nKeyword Arguments\n\nkernel_radius: radius of the kernel.\nedge_pad_size: the size of edge padding.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#BloqadeWaveforms.smooth-Tuple{Any, Vector, Vector, Real}","page":"Waveforms","title":"BloqadeWaveforms.smooth","text":"smooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)\n\nKernel smoother function via weighted moving average method. See also Kernel Smoother.\n\nTheory\n\nKernel function smoothing is a technique to define a smooth function f mathcalR^p  mathbfR from a set of discrete points by weighted averaging the neighboring points. It can be written as the following equation.\n\nY(X) = sum_i K(X X_i) Y_i  sum_i K(X X_i)\n\nwhere Y(X) is the smooth function by calculating the moving average of known data points X_i and Y_i. K is the kernel function, where K(fracX - X_ih_λ) decrease when the Euclidean norm X - X_i increase, h_λ is a parameter controls the radius of the kernel.\n\nAvailable Kernels\n\nThe following kernel functions are available via the Kernels module:\n\nbiweight; cosine; gaussian; include; logistic; parabolic; sigmoid; triangle; tricube; triweight; uniform\n\nArguments\n\nkernel: a Julia function that has method kernel(t::Real).\nXi::Vector: a list of inputs X_i.\nYi::Vector: a list of outputs Y_i.\nkernel_radius::Real: the radius of the kernel.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"EditURL = \"https://github.com/Happy-Diode/Bloqade.jl/blob/master/examples/quantum-scar/main.jl\"","category":"page"},{"location":"tutorials/quantum-scar/main/#Quantum-Scar","page":"Quantum Scar","title":"Quantum Scar","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/#Background","page":"Quantum Scar","title":"Background","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The experimental study H. Bernien, et al. finds that if one starts with a with a particular initial state (e.g. the Neel state), the Rydberg blockade constraint results into persistent revivals of quantum dynamics. Later, theoretical studies (e.g. C. J. Turner, et al.) reveal that this behavior is due to very specific eigenstates embeded in the quantum many-body spectrum, called quantum many-body scars.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Quantum many-body scars are analogous to clasical scars in single-particle quantum chaos, where scars represent a concentration of some eigenfunctions along the trajectory of classical periodic orbits. Similarly, in the quantum many-body case, the initial Neel state has a large component of these specific scar states. Under the time evolution of the Rydberg Hamiltonian, the initial state undergoes the trajectory of periodic quantum orbits. The non-thermal behavior is mainly caused by such non-ergodicity in Hilbert space.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"In this example, we use the Rydberg Emulator to simulate the evolution of a fully coherent, strongly interacting Rydberg system.  We demonstrate the persistent revivals of many-body dynamics with measurements of the Rydberg density, and entanglement entropy. For a comprehensive review of quantum many-body scars, we refer readers to this paper M. Serbyn et al.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We start by importing required libraries","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"using Bloqade\nusing BloqadePlots\nusing PythonCall\nusing Random\n\nplt = pyimport(\"matplotlib.pyplot\")","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Python module: <module 'matplotlib.pyplot' from '/home/runner/work/Bloqade.jl/Bloqade.jl/examples/adiabatic/.CondaPkg/env/lib/python3.10/site-packages/matplotlib/pyplot.py'>","category":"page"},{"location":"tutorials/quantum-scar/main/#Rabi-oscillations-with-Rydberg-blockade","page":"Quantum Scar","title":"Rabi oscillations with Rydberg blockade","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first demonstrate that the strong Rydberg interactions have important effects on the Rabi oscillations of Rydberg atoms. To do so, we consider a system with 1, 2 and 3 atoms. All the atoms are placed withint the blockade radius of any other atom (see blockade for more details).","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"atom1 = generate_sites(ChainLattice(), 1, scale=3.0)\natom2 = generate_sites(ChainLattice(), 2, scale= 3.0)\natom3 = generate_sites(ChainLattice(), 3, scale= 3.0)","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"70mm\" viewBox=\"0 0 120 70\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.88\" id=\"img-299ddca7-1\">\n  <g transform=\"translate(35,49)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,49)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,49)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"1.2\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-299ddca7-2\">\n  <g transform=\"translate(35,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"7.06\" id=\"img-299ddca7-3\">\n  <g transform=\"translate(35,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Then a resonant Rabi driving is applied to each of the system. The Hamiltonians can be simply constructed by","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"h1 = rydberg_h(atom1; Δ=0, Ω=2π*2)\nh2 = rydberg_h(atom2; Δ=0, Ω=2π*2)\nh3 = rydberg_h(atom3; Δ=0, Ω=2π*2)","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"nqubits: 3\n+\n├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n├─ [+] 6.28 ⋅ ∑ σ^x_i\n└─ [-] 0.0 ⋅ ∑ n_i\n","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The initial states are chosen such that all atoms start from the ground state","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"reg1 = zero_state(1)\nreg2 = zero_state(2)\nreg3 = zero_state(3)","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"ArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first emulate the dynamics for the single atom's case, where the intial state is quenched under a Hamiltonain with constant Rabi frequency","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"clocks = 0.0:1e-2:1.5\nprob1 = KrylovEvolution(reg1, clocks, h1)\ndensity_mat1 = zeros(1, length(clocks)-1)\n\nfor info in prob1\n    for i in 1:1\n        density_mat1[i, info.step] = expect(put(1, i=>Op.n), info.reg)\n    end\nend","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The Rydberg density of this atom exihibits Rabi oscillations as a function of time, shown by the plot","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"fig, ax = plt.subplots()\nax.plot(clocks[1:end-1], density_mat1[1, :])\nax.set_xlabel(\"Time (μs)\")\nax.set_ylabel(\"Single Rydberg Probability\")\nax.set_title(\"Rydberg Density: Single Atom Case\")\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"For the case of 2 and 3 atoms, if they are seperated far enough with negligible interactions, the total Rydberg excitation densities are simply the sum of each each atom. However, we will show that this is not the case for systems when atoms are close to each other (which results in strong Rydberg interactions). Similar to the 1 atom case, we can emulate the dynamics and get the time-dependent dynamics for each atom","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"prob2 = KrylovEvolution(reg2, clocks, h2);\ndensity_mat2 = zeros(2, length(clocks)-1);\n\nfor info in prob2\n    for i in 1:2\n        density_mat2[i, info.step] = expect(put(2, i=>Op.n), info.reg)\n    end\nend\n\nprob3 = KrylovEvolution(reg3, clocks, h3);\ndensity_mat3 = zeros(3, length(clocks)-1);\n\nfor info in prob3\n    for i in 1:3\n        density_mat3[i, info.step] = expect(put(3, i=>Op.n), info.reg)\n    end\nend","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The total Rydberg density for the 1-, 2-, and 3-atom system is plotted below","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"fig, ax = plt.subplots()\nax.plot(clocks[1:end-1], density_mat1[1, :])\nax.set_xlabel(\"Time (μs)\")\nax.set_ylabel(\"Single Rydberg Probability\")\nax.set_title(\"Rydberg Density: Single Atom Case\")\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"2-atom system","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"density2 = sum(density_mat2, dims=1)\n\nfig, ax = plt.subplots()\nax.plot(clocks[1:end-1], density2[1, :])\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"3-atom system","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"density3 = sum(density_mat3, dims=1)\n\nfig, ax = plt.subplots()\nax.plot(clocks[1:end-1], density3[1, :])\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"From the above plot, we can see that the total Rydberg density for 2 (3) atom case does not exceed 1. This is because it is energitically unfavorable to have more than 1 excitation due to the strong Rydberg interactions. Furthermore, the frequency of Rabi oscillation for the whole system depends strongly on the number of atoms. This again validates the fact that interaction plays an important role in the system's dynamics.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Below, we show that for a system with 9 atoms where only nearest atoms are within each other's blockade radius, the system can also exhibit nontrivial dynamics for certain initial state.","category":"page"},{"location":"tutorials/quantum-scar/main/#Build-9-sites-Hamiltonian","page":"Quantum Scar","title":"Build 9-sites Hamiltonian","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We build a 1D-Chain with 9-atom arrangement, with each atom separated from its neighbor by 5.72 mu m. This results in a nearest-neighbor interaction strength of 2 pi * 24 MHz. This is much larger than the Rabi oscillations Omega, which we specify below. So the nerest-neighbor Rydberg atoms are within the blockade radius, such that both of the atoms can not be excited simultaneously.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"nsites = 9\natoms = generate_sites(ChainLattice(), nsites, scale=5.72)","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"47.27mm\" viewBox=\"0 0 120 47.27\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.88\" id=\"img-4f800e62-1\">\n  <g transform=\"translate(23.64,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.82,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">11.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">22.88μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.18,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">34.32μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.36,33.09)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">45.76μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.82,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"0.44\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-4f800e62-2\">\n  <g transform=\"translate(23.64,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(32.73,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(41.82,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(50.91,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(69.09,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(78.18,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(87.27,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(96.36,23.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"2.18\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"2.57\" id=\"img-4f800e62-3\">\n  <g transform=\"translate(23.64,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(32.73,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.82,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(50.91,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(69.09,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.18,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(87.27,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.36,23.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The waveforms are composed by two parts. For the first part, we use the adibatic evolution to prepare an ordered Neel state (see adiabatic for more details).","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Δ1= piecewise_linear(clocks=[0.0, 0.3, 1.6, 2.2], values=[-10*2π, -10*2π, 10*2π, 10* 2π]);\nΩ1= piecewise_linear(clocks=[0.0, 0.05, 1.6, 2.2], values=[0.0, 4*2π, 4*2π, 0]);","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The second part of the waveform has constant value of parameters, so we can use constant to construct","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Ω2 = constant(duration=2.0, value=2* 2π);\nΔ2 = constant(duration=2.0, value=0);","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"The waveform for the whole evolution is composed by appending the second part to the first part","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Ω_tot = append(Ω1, Ω2);\nΔ_tot = append(Δ1, Δ2);\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\ndraw!(ax1, Ω_tot)\ndraw!(ax2, Δ_tot)\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Note that the total evolution is 4.2 mu s. We then build the Hamiltonian by importing the defined lattice structure and waveforms.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"h = rydberg_h(atoms; Δ=Δ_tot, Ω=Ω_tot)","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"nqubits: 9\n+\n├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n├─ [+] Ω(t) ⋅ ∑ σ^x_i\n└─ [-] Δ(t) ⋅ ∑ n_i\n","category":"page"},{"location":"tutorials/quantum-scar/main/#Emulate-the-problem","page":"Quantum Scar","title":"Emulate the problem","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We evaluate the quench dynamics of the Rydberg atom array (initially prepared in the ground state). The initial state can be created by","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"reg = zero_state(9)","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"ArrayReg{2, ComplexF64, Array...}\n    active qubits: 9/9\n    nlevel: 2","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We can now set up discrete time evolution problem using the ODE solver.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"prob = SchrodingerProblem(reg, 4.2, h);\nintegrator = init(prob, Vern8());","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"Then we measure the real-time expectation value of Rydberg density and entanglement entropy.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"entropy = Float64[]\ndensities = []\nfor _ in TimeChoiceIterator(integrator, 0.0:1e-3:4.2)\n    push!(densities, [expect(put(nsites, i=>Op.n), reg) for i in 1:nsites])\n    rho = density_matrix(reg, (1,2,3,4,5))\n    push!(entropy, von_neumann_entropy(rho))\nend","category":"page"},{"location":"tutorials/quantum-scar/main/#Plot-the-results","page":"Quantum Scar","title":"Plot the results","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We first plot the Rydberg density for each site as a function of time","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"clocks = [t for t in 0:1e-3:4.2]\nD = hcat(densities...)\n\nfig, ax = plt.subplots(figsize = (10,4))\nax.imshow(real(D), interpolation=\"nearest\", aspect=\"auto\")\nax.set_xlabel(\"iterations\")\nax.set_ylabel(\"rydberg density per site\")\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We can see that the state evolves to a Neel state after the first part of pulse. After that, there are clear oscillations between the two partterns of the Rydberg density.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"We can also plot the entanglement as a function of time","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"fig, ax = plt.subplots(figsize = (10,4))\nax.plot(clocks, entropy)\nax.set_xlabel(\"Time (μs)\")\nax.set_ylabel(\"Entanglement Entropy\")\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/#A-different-initial-state","page":"Quantum Scar","title":"A different initial state","text":"","category":"section"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"In order to show that the revivals depends strongly on the initial state, we now choose a different initial state, and use the ['KrylovEvolution']@(ref) solver to emulate the problem","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"hd = rydberg_h(atoms;Ω=4π)\nclocks = 0.0:1e-2:1.2\n\ninit_d = product_state(bit\"100000101\")\nprob_d = KrylovEvolution(init_d, clocks, hd)\ndensity_mat_d = zeros(nsites, length(clocks)-1)\n\nfor info in prob_d\n    for i in 1:nsites\n        density_mat_d[i, info.step] = expect(put(nsites, i=>Op.n), info.reg)\n    end\nend\n\nfig, ax = plt.subplots(figsize = (10,4))\nax.imshow(real(density_mat_d), interpolation=\"nearest\", aspect=\"auto\")\nax.set_xlabel(\"iterations\")\nax.set_ylabel(\"rydberg density per site\")\nfig","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"From the above figure, we see that the density does not show long-lived oscillations.","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"","category":"page"},{"location":"tutorials/quantum-scar/main/","page":"Quantum Scar","title":"Quantum Scar","text":"This page was generated using Literate.jl.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"CurrentModule = Bloqade","category":"page"},{"location":"emulation/#emulation","page":"Emulation","title":"Emulation of Shordinger Equation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"After we create the Rydberg Hamiltonian and Register storing the quantum information, we can  emulate the quantum many-body dynamics. The coherent dynamics of the system is governed by Schrodinger Equation. The emulation interface of Bloqade is designed as  define-and-run style.  With Bloqade, we have two major types of emulation:","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ODE solver based emulation for most of the problems.\nKrylov based emulation for piecewise constant problems or QAOA-like problem.","category":"page"},{"location":"emulation/#Define-the-ODE-Emulation-Problem","page":"Emulation","title":"Define the ODE Emulation Problem","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ODE solver is the major backend we uses for most of the exact quantum  dynamics simulation. The ODE solvers for Bloqade are powered by the DiffEq.jl package.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Bloqade provides a special problem type SchrodingerProblem that supports most of the  integrator interface of DiffEq, and most of the solver options. Here we will introduce common use cases of the integrator and solver options. For more advanced usage of the solver, please refer to the above link.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"BloqadeODE.SchrodingerProblem","category":"page"},{"location":"emulation/#BloqadeODE.SchrodingerProblem","page":"Emulation","title":"BloqadeODE.SchrodingerProblem","text":"struct SchrodingerProblem\nSchrodingerProblem(reg, tspan, hamiltonian; kw...)\n\nDefine a Schrodinger equation problem that uses ODE solver from OrdinaryDiffEq to solve the dynamics.\n\nArguments\n\nregister: required, the evolution problem register, can be a SubspaceArrayReg or an ArrayReg   from Yao.\ntspan: required, a (start, stop) tuple or a single number t, the single value form t is equivalent   to (zero(t), t).\nhamiltonian: required, the evolution hamiltonian, can be created via rydberg_h.\n\nCommon Keyword Arguments\n\nalgo: optional, algorithm to use, this only works for the emulate! interface.   for solve or integrator interface, one will need to specify the algorithm explicitly.\nprogress: print progress bar or not, this may effect the performance when problem scale is small, default is true.\nprogress_steps: steps to update the progress bar, default is 5.\nreltol: relative tolerance, default is 1e-8.\nabstol: absolute tolerance, default is 1e-8.\n\nFurther References\n\nFor more ODE options, please refer to Common Solver Options. The SchrodingerProblem type supports most of the standard DiffEq problem interface.\n\n\n\n\n\n","category":"type"},{"location":"emulation/#Run-ODE-based-Emulation","page":"Emulation","title":"Run ODE-based Emulation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"To run the emulation, you need to define the exact evolution and solver you would like to run with via BloqadeODE.SchrodingerProblem, then feed the corresponding object to emulate! function","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"emulate!","category":"page"},{"location":"emulation/#BloqadeExpr.emulate!","page":"Emulation","title":"BloqadeExpr.emulate!","text":"emulate!(prob)\n\nRun emulation of a given problem.\n\n\n\n\n\n","category":"function"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For example, we can simulate quantum dynamics of a time-dependent Hamiltonian by the following codes","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3; scale=5.1);\nclocks = [0.0, 0.1, 0.2, 0.3, 0.4];\nwf = piecewise_constant(;clocks, values=[1.0, 2.0, 3.0, 4.0]);\nh = rydberg_h(atoms; Δ=2.0, Ω=wf); # create the Hamiltonian \nreg = zero_state(length(atoms)); # create fullspace register\nev = SchrodingerProblem(reg, 0.3, h)\nemulate!(ev)","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"With the emulate!, the quantum state stored in reg has been updated to the state after the time-evolution. ","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"In case you want to do operations during the real-time evolution, such as measuring observables, you can instead using the integrator interface with for loop and with TimeChoiceIterator on your desired clocks, e.g","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"integrator = init(ev, Vern8())\nfor _ in TimeChoiceIterator(integrator, [0.1, 0.25])\n    ev.reg # state at selected time\n    @show measure(ev.reg)[] # measure the state at each time\nend","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"You can use any function on the reg object.  For calculating observables,  please see the Observables section.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"tip: Tip\nRemember to make sure your operation does not mutate your state so that this won't effect the evolution itself, since the entire time evolution is simulated by keep mutating the state vector stored in reg which means do not use any function that has a ! in its name on the register info.reg unless you are certain about what you are doing.","category":"page"},{"location":"emulation/#Choosing-ODE-solver","page":"Emulation","title":"Choosing ODE solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"One of the most powerful aspect of Julia ecosystem is the DiffEq ecosystem that implements lots of different solvers. These solvers have different trade-offs. Since simulating many-body Schrodinger equation has some special properties comparing to a general ODE problem, we will discuss some general heurestics in this section on how to choose a good ODE solver and how to check if your emulation converges. Because many-body Schrodinger equation's stiffness is unknown, we will not be using stiff problem solver, but using non-stiff problem algorithm or auto-switching algorithm.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Most of the cases one can use VCABM solver for large system simulation. However, this method requires more memory which can be a bottleneck when utilizing GPUs.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The Vern family is another set of solvers that is good for many-body Schrodinger equation, such as Vern6, Vern7 and Vern8, they also have relatively good memory usage when utilize GPUs.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For more detailed list of solvers please refer to DiffEq:Full list of solvers. For more detailed explaination on ODE solvers please refer to DiffEq:Recommended Methods.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"If you come from MATLAB or Python, you may expecting to compare the same method that you use in MATLAB or Python, you can find the corresponding solvers in Julia in DiffEq:Translation from MATLAB/Python/R.","category":"page"},{"location":"emulation/#Adaptive-Steps-in-ODE-solver","page":"Emulation","title":"Adaptive Steps in ODE solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Our ODE solver uses adaptive steps by default. It provides a huge speedup comparing to standard fixed step methods (see our benchmark here). However, if one expects to retreive results during the time evolution, e.g plotting Rydberg density changes with the time, fixed step method should be preferred otherwise the ODE solver will give constant results between each step","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"(add @Johnason's plot on ring emulation here) (add a few examples of how to turn on or turn off the adaptive)","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"On the other hand, if one only expects the final state of the evolution, or the interval between each chosen clock is much larger than maximum step size, adaptive step is preferred.","category":"page"},{"location":"emulation/#Define-Krylov-Emulation-Problem","page":"Emulation","title":"Define Krylov Emulation Problem","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The Krylov-based method expects time independent Hamiltonians, one can define such evolution via KrylovEvolution object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"KrylovEvolution","category":"page"},{"location":"emulation/#BloqadeKrylov.KrylovEvolution","page":"Emulation","title":"BloqadeKrylov.KrylovEvolution","text":"struct KrylovEvolution\nKrylovEvolution(reg::AbstractRegister, clocks, h; kw...)\n\nCreate a KrylovEvolution object that describes a time evolution using Krylov subspace methods.\n\nArguments\n\nreg: a register, should be a subtype of AbstractRegister.\nclocks: the clocks of this time evolution at each step.\nh: a hamiltonian expression.\n\nKeyword Arguments\n\nprogress: show progress bar, default is false.\nprogress_name: progress bar name, default is \"emulating\".\nnormalize_step: normalize the state every normalize_step.\nnormalize_finally: wether normalize the state in the end of evolution, default is true.\ntol: tolerance of the Krylov method, default is 1e-7\n\nExamples\n\nThe following is the simplest way of using KrylovEvolution via emulate!. For more advanced usage, please refer to documentation page Emulation.\n\njulia> using Bloqade\n\njulia> r = zero_state(5)\nArrayReg{2, ComplexF64, Array...}\n    active qudits: 5/5\n    nlevel: 2\n\njulia> atoms = [(i, ) for i in 1:5]\n5-element Vector{Tuple{Int64}}:\n (1,)\n (2,)\n (3,)\n (4,)\n (5,)\n\njulia> h = rydberg_h(atoms; Ω=sin)\nnqubits: 5\n+\n├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j\n└─ [+] Ω(t) ⋅ ∑ σ^x_i\n\n\njulia> prob = KrylovEvolution(r, 0.0:1e-2:0.1, h);\n\njulia> emulate!(prob); # run the emulation\n\n\n\n\n\n","category":"type"},{"location":"emulation/#Run-Krylov-based-Emulation","page":"Emulation","title":"Run Krylov-based Emulation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"We can run the Krylov-based emulation in a similar way using emulate!","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"emulate!(KrylovEvolution(reg, clocks, h))","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"However, as its name points out, the Krylov-based emulation is not a standard ODE problem that DiffEq  supports, thus it does not support the ODE problem interface, but a more gate-like interface, e.g the object KrylovEvolution is iterable","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"for (step, reg, duration) in KrylovEvolution(reg, clocks, h)\n    @show step\n    @show reg\n    @show duration\n    println(\"==========\")\nend","category":"page"},{"location":"emulation/#Krylov-vs-ODE-solver","page":"Emulation","title":"Krylov vs ODE solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The KrylovEvolution uses Krylov subspace methods to simulate the time evolution as discrete time-independent time evolution operators exp(iDelta t_i H(t)), where Delta t_i is the duration of time-independent Hamiltonian H(t) at time t. This method is more efficient when the evolution itself is a discrete evolution, e.g QAOA, piecewise_constant waveform. As for other cases, ODE solvers are usually more efficient than KrylovEvolution.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Bloqade","category":"page"},{"location":"#Bloqade","page":"Home","title":"Bloqade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Coverage Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p>\nWelcome to the documentation page for Bloqade, a &nbsp;\n    <a href=\"https://julialang.org\">\n        <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">\n        Julia Language\n    </a>\n    &nbsp; package for the efficient simulation of quantum computers based on neutral-atom architectures. <br> <br>\n\nBloqade enables the easy design and fast execution of quantum computing protocols incorporating the particularities of architectures based on neutral atoms, including the definition of arbitrary-layout quantum registers, the operation in Hilbert spaces constrained by the Rydberg blockade, and more.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nTo install Bloqade,\n    please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open\n    Julia's interactive session (known as REPL)</a>, press <kbd>]</kbd> key in the REPL to use the package mode, and then...\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"add the QuEra Julia registry via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> registry add https://github.com/Happy-Diode/Miskatonic.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the stable release, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bloqade","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or for the current master,","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bloqade#master","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more advanced installation guide, please see the Installation page.","category":"page"},{"location":"#What-does-Bloqade-do?","page":"Home","title":"What does Bloqade do?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bloqade simulates the time evolution of a quantum state under the Schrödinger equation where the Hamiltonian is the interacting Rydberg Hamiltonian mathcalH, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"i hbar dfracpartialpartial t  psi rangle = mathcalH(t)  psi rangle  \n\nfracmathcalH(t)hbar = sum_j fracOmega_j(t)2 left( e^i phi_j(t)   1_j rangle  langle r_j  + e^-i phi_j(t)   r_j rangle  langle 1_j  right) - sum_j Delta_j(t) n_j + sum_j  k V_jk n_j n_k","category":"page"},{"location":"","page":"Home","title":"Home","text":"Following the atomic physics nomenclature, Omega_j, phi_j, and Delta_j  denote the Rabi frequency, laser phase, and the detuning of the driving laser field on atom (qubit) j coupling the two states   1_j rangle (ground state) and  r_j rangle (Rydberg state). The number operator n_j = r_jrangle langle r_j, and V_jk = Coverrightarrowmathbfr_j - overrightarrowmathbfr_k^6 describes the Rydberg interaction between atoms j and k where overrightarrowmathbfr_j denotes the position of the atom j; C is the Rydberg interaction constant that depends on the particular Rydberg state used. For the emulator, the default C = 2pi times 862690 text MHz μm^6 for r rangle = lvert 70S_12 rangle of the ^87Rb atoms. hbar is the reduced Planck's constant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting from a initial quantum state  psi_textini rangle, the emulator simulates its time evolution under the Hamiltonian mathcalH(t), given the qubit positions and the time-dependent profiles for  Omega_j, phi_j, and Delta_j. The emulator then produces the real-time-evolved state  psi(t) rangle, which can then be used for the measurement of different observables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default units for various quantities are ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantity Default Unit\nLength μm\nTime μs\nOmega MHz\nphi rad\nDelta MHz","category":"page"},{"location":"#First-steps","page":"Home","title":"First steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's try a simple example of simulating quantum many-body dynamics governed by the Rydberg Hamiltonian. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start by loading the Emulator Module","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Bloqade","category":"page"},{"location":"","page":"Home","title":"Home","text":"As one can see from the Rydberg Hamiltonian, the interactions between Rydberg atoms depend on their positions. Bloqade provides several built-in Lattices structures for specifying the atom positions. For instance, we can use the following codes to quickly generate a chain of 10 atoms in 1D: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"nsites = 10;\natoms = generate_sites(ChainLattice(), nsites, scale = 5.74)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have set the distance between nearest neighbor atoms to be 5.74 μm. Note that the default unit of length is μm as shown in the table above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's set both Omega and Delta to be constants. Since all the parameters are specified, we can now create an interacting Rydberg Hamiltonian by using rydberg_h, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = rydberg_h(atoms; Ω = 2π * 4, Δ = 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For creating more complicated waveforms for Omega and Delta and the supported utilities, please refer to the Waveforms page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's create an initial state with all the atoms in the ground state by using zero_state","category":"page"},{"location":"","page":"Home","title":"Home","text":"reg = zero_state(10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are interested in measuring observables of the final quantum state of the Rydberg system starting from the initial state and evolving under the Rydberg Hamiltonian over some time duration. We can first create the problem and then directly emulate the time evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob = SchrodingerProblem(reg, 1.6, h)\nintegrator = init(prob, Vern8());\nemulate!(prob);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we have chosen the ODE-based solver by using SchrodingerProblem and set the total evolution time to be 1.6 μs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After simulating the time evolution and get the final state, we can measure the Rydberg population at each site for the final state ","category":"page"},{"location":"","page":"Home","title":"Home","text":"rydberg_populations = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob.reg is the register storing the final state after the time evolution.","category":"page"},{"location":"#Looking-for-Help?","page":"Home","title":"Looking for Help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"check the slack channel #julia\nif not urgent, ask questions in discussions","category":"page"},{"location":"#Have-Suggestions-or-Interested-in-Contribution?","page":"Home","title":"Have Suggestions or Interested in Contribution?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"check the slack channel #q-emulator for meetings and discussions\nfile an issue to report a bug or request a feature","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"EditURL = \"https://github.com/Happy-Diode/Bloqade.jl/blob/master/examples/ring/main.jl\"","category":"page"},{"location":"tutorials/ring/main/#Ring-Emulation","page":"Ring Emulation","title":"Ring Emulation","text":"","category":"section"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"using Bloqade","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Use matplotlib to generate plots for windows users you may need to use the following commands","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"matplotlib = pyimport(\"matplotlib\")\nmatplotlib.use(\"TkAgg\")","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"using PythonCall\nplt = pyimport(\"matplotlib.pyplot\")\nplt.rcParams[\"font.size\"] = 22","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"22","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Simulate nonequilibrium dynamics of a 12-site ring of Rydberg atoms. This script generates Figure 2 in the example RydbergBlockade.","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"First, define the geometry of the system, a ring of 12 sites.","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"nsites = 12;    # 12 site chain\ndistance = 7    # Distance between atoms, in microns\n\nR = distance/(2*sin(2*pi/(nsites)/2))                                       # Radius of the circle, using a little trigonometry\npos = [(R*sin(i*2*pi/(nsites)), R*cos(i*2*pi/(nsites)) ) for i in 1:nsites] # Positions of each atom\natoms = AtomList(pos)                                                       # Define the atom positions as an AtomList.","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"120mm\" viewBox=\"0 0 120 120\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.88\" id=\"img-953b5638-1\">\n  <g transform=\"translate(28.71,102.77)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">-13.52μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(49.57,102.77)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">-4.51μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(70.43,102.77)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4.51μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(91.29,102.77)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">13.52μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(14.36,91.29)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">-13.52μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(14.36,70.43)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">-4.51μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(14.36,49.57)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4.51μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(14.36,28.71)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">13.52μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"0.78\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-953b5638-2\">\n  <g transform=\"translate(75.64,32.9)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(87.1,44.36)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(91.29,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(87.1,75.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(75.64,87.1)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,91.29)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(44.36,87.1)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(32.9,75.64)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(28.71,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(32.9,44.36)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(44.36,32.9)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,28.71)\">\n    <circle cx=\"0\" cy=\"0\" r=\"3.89\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"4.57\" id=\"img-953b5638-3\">\n  <g transform=\"translate(75.64,32.9)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(87.1,44.36)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(91.29,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(87.1,75.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(75.64,87.1)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,91.29)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(44.36,87.1)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(32.9,75.64)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(28.71,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n  <g transform=\"translate(32.9,44.36)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">10</text>\n    </g>\n  </g>\n  <g transform=\"translate(44.36,32.9)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">11</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,28.71)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">12</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Build the Hamiltonian by defining the atom list and the Rabi frequency Here, the Rabi frequency Ω is π, such that one oscillation occurs in 0.5usec.","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"h = rydberg_h(atoms;C = 2π * 858386, Ω=π)","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"nqubits: 12\n+\n├─ [+] ∑ 5.39e6/|r_i-r_j|^6 n_i n_j\n└─ [+] 1.57 ⋅ ∑ σ^x_i\n","category":"page"},{"location":"tutorials/ring/main/#Emulate-the-problem","page":"Ring Emulation","title":"Emulate the problem","text":"","category":"section"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"State in the full space","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"init_state = zero_state(nsites)","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"ArrayReg{2, ComplexF64, Array...}\n    active qubits: 12/12\n    nlevel: 2","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"State in the blockade subspace","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"space = blockade_subspace(atoms,distance*1.1)   # Compute the blockade subspace\ninit_state2 = zero_state(space)                       # Define the initial state in the blockade subspace.","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"YaoSubspaceArrayReg.SubspaceArrayReg{Vector{ComplexF64}, BloqadeExpr.Subspace{Vector{Int64}}}(12, ComplexF64[1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im], BloqadeExpr.Subspace{Vector{Int64}}(12, Dict(2050 => 235, 2594 => 298, 1033 => 151, 2632 => 305, 1028 => 148, 2312 => 271, 2688 => 310, 1296 => 208, 2324 => 275, 673 => 138, 73 => 28, 1188 => 195, 657 => 133, 1090 => 168, 2592 => 297, 584 => 116, 544 => 103, 168 => 53, 2132 => 254, 1193 => 198, 1092 => 169, 2722 => 319, 676 => 140, 1168 => 187, 264 => 61, 41 => 20, 68 => 25, 1297 => 209, 1285 => 204, 82 => 32, 130 => 37, 1361 => 230, 517 => 94, 1088 => 166, 66 => 24, 521 => 96, 1109 => 178, 336 => 85, 1280 => 200, 1058 => 160, 1105 => 175, 656 => 132, 1301 => 212, 2570 => 293, 2336 => 276, 578 => 113, 2644 => 309, 644 => 127, 138 => 42, 528 => 98, 1320 => 218, 276 => 67, 170 => 55, 129 => 36, 1154 => 181, 133 => 39, 1185 => 193, 72 => 27, 258 => 58, 532 => 101, 2052 => 236, 2218 => 267, 1 => 2, 137 => 41, 2176 => 255, 529 => 99, 2560 => 289, 288 => 69, 2114 => 248, 2578 => 295, 33 => 15, 1284 => 203, 677 => 141, 516 => 93, 1044 => 156, 1066 => 165, 40 => 19, 522 => 97, 1029 => 149, 1034 => 152, 1061 => 162, 165 => 52, 2212 => 265, 2372 => 283, 5 => 5, 2180 => 257, 265 => 62, 2708 => 317, 325 => 81, 2120 => 250, 660 => 135, 136 => 40, 1024 => 145, 145 => 44, 672 => 137, 1026 => 147, 1312 => 213, 337 => 86, 2602 => 301, 530 => 100, 1300 => 211, 1042 => 155, 1192 => 197, 1352 => 226, 674 => 139, 1097 => 172, 1317 => 217, 1056 => 158, 1156 => 182, 2640 => 307, 148 => 46, 1170 => 189, 36 => 17, 2304 => 268, 2724 => 320, 1345 => 222, 1321 => 219, 553 => 109, 1290 => 207, 162 => 50, 84 => 33, 1189 => 196, 1045 => 157, 292 => 72, 296 => 74, 680 => 142, 18 => 11, 1157 => 183, 2626 => 303, 16 => 9, 514 => 92, 341 => 89, 1282 => 202, 2082 => 243, 1173 => 191, 266 => 63, 146 => 45, 2376 => 284, 74 => 29, 513 => 91, 1089 => 167, 2192 => 260, 576 => 111, 580 => 114, 2568 => 292, 1160 => 184, 2720 => 318, 2690 => 311, 1354 => 228, 17 => 10, 2122 => 251, 577 => 112, 585 => 117, 520 => 95, 80 => 30, 1313 => 214, 2058 => 238, 274 => 66, 2370 => 282, 1362 => 231, 2210 => 264, 330 => 84, 552 => 108, 2344 => 279, 1184 => 192, 1194 => 199, 2564 => 291, 648 => 129, 650 => 131, 1106 => 176, 2692 => 312, 1344 => 221, 2208 => 263, 272 => 64, 1161 => 185, 164 => 51, 2600 => 300, 64 => 22, 1364 => 232, 2048 => 234, 2624 => 302, 4 => 4, 2596 => 299, 640 => 124, 1057 => 159, 658 => 134, 2184 => 258, 2728 => 321, 328 => 82, 2704 => 315, 2128 => 252, 69 => 26, 2384 => 286, 2066 => 240, 85 => 34, 2196 => 262, 2698 => 314, 2388 => 288, 2 => 3, 10 => 8, 533 => 102, 261 => 60, 2068 => 241, 1322 => 220, 144 => 43, 273 => 65, 257 => 57, 2634 => 306, 290 => 71, 20 => 12, 81 => 31, 1186 => 194, 2576 => 294, 340 => 88, 0 => 1, 329 => 83, 2306 => 269, 1289 => 206, 9 => 7, 512 => 90, 2112 => 247, 161 => 49, 1298 => 210, 2056 => 237, 1152 => 179, 2116 => 249, 645 => 128, 649 => 130, 260 => 59, 297 => 75, 545 => 104, 1098 => 173, 8 => 6, 37 => 18, 1348 => 224, 2090 => 246, 1096 => 171, 2378 => 285, 2706 => 316, 1153 => 180, 593 => 120, 1360 => 229, 554 => 110, 548 => 106, 2314 => 272, 1353 => 227, 1346 => 223, 2178 => 256, 322 => 79, 592 => 119, 597 => 123, 1104 => 174, 2308 => 270, 586 => 118, 2628 => 304, 2696 => 313, 32 => 14, 2088 => 245, 2080 => 242, 320 => 77, 681 => 143, 2346 => 280, 324 => 80, 1064 => 163, 1025 => 146, 1169 => 188, 2386 => 287, 2216 => 266, 2340 => 278, 1349 => 225, 661 => 136, 682 => 144, 1288 => 205, 256 => 56, 596 => 122, 277 => 68, 1060 => 161, 2064 => 239, 549 => 107, 2320 => 273, 1162 => 186, 321 => 78, 34 => 16, 1316 => 216, 42 => 21, 2730 => 322, 132 => 38, 2642 => 308, 169 => 54, 2338 => 277, 2580 => 296, 1040 => 153, 160 => 48, 1281 => 201, 289 => 70, 2562 => 290, 1032 => 150, 128 => 35, 21 => 13, 581 => 115, 1365 => 233, 1172 => 190, 1108 => 177, 2130 => 253, 2186 => 259, 2368 => 281, 2194 => 261, 1065 => 164, 546 => 105, 338 => 87, 2322 => 274, 2084 => 244, 1093 => 170, 149 => 47, 641 => 125, 594 => 121, 1314 => 215, 65 => 23, 293 => 73, 298 => 76, 642 => 126, 1041 => 154), [0, 1, 2, 4, 5, 8, 9, 10, 16, 17, 18, 20, 21, 32, 33, 34, 36, 37, 40, 41, 42, 64, 65, 66, 68, 69, 72, 73, 74, 80, 81, 82, 84, 85, 128, 129, 130, 132, 133, 136, 137, 138, 144, 145, 146, 148, 149, 160, 161, 162, 164, 165, 168, 169, 170, 256, 257, 258, 260, 261, 264, 265, 266, 272, 273, 274, 276, 277, 288, 289, 290, 292, 293, 296, 297, 298, 320, 321, 322, 324, 325, 328, 329, 330, 336, 337, 338, 340, 341, 512, 513, 514, 516, 517, 520, 521, 522, 528, 529, 530, 532, 533, 544, 545, 546, 548, 549, 552, 553, 554, 576, 577, 578, 580, 581, 584, 585, 586, 592, 593, 594, 596, 597, 640, 641, 642, 644, 645, 648, 649, 650, 656, 657, 658, 660, 661, 672, 673, 674, 676, 677, 680, 681, 682, 1024, 1025, 1026, 1028, 1029, 1032, 1033, 1034, 1040, 1041, 1042, 1044, 1045, 1056, 1057, 1058, 1060, 1061, 1064, 1065, 1066, 1088, 1089, 1090, 1092, 1093, 1096, 1097, 1098, 1104, 1105, 1106, 1108, 1109, 1152, 1153, 1154, 1156, 1157, 1160, 1161, 1162, 1168, 1169, 1170, 1172, 1173, 1184, 1185, 1186, 1188, 1189, 1192, 1193, 1194, 1280, 1281, 1282, 1284, 1285, 1288, 1289, 1290, 1296, 1297, 1298, 1300, 1301, 1312, 1313, 1314, 1316, 1317, 1320, 1321, 1322, 1344, 1345, 1346, 1348, 1349, 1352, 1353, 1354, 1360, 1361, 1362, 1364, 1365, 2048, 2050, 2052, 2056, 2058, 2064, 2066, 2068, 2080, 2082, 2084, 2088, 2090, 2112, 2114, 2116, 2120, 2122, 2128, 2130, 2132, 2176, 2178, 2180, 2184, 2186, 2192, 2194, 2196, 2208, 2210, 2212, 2216, 2218, 2304, 2306, 2308, 2312, 2314, 2320, 2322, 2324, 2336, 2338, 2340, 2344, 2346, 2368, 2370, 2372, 2376, 2378, 2384, 2386, 2388, 2560, 2562, 2564, 2568, 2570, 2576, 2578, 2580, 2592, 2594, 2596, 2600, 2602, 2624, 2626, 2628, 2632, 2634, 2640, 2642, 2644, 2688, 2690, 2692, 2696, 2698, 2704, 2706, 2708, 2720, 2722, 2724, 2728, 2730]))","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Define the time steps","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Tmax = 10.\nnsteps = 5001\ntimes = LinRange(0,Tmax,nsteps)","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"5001-element LinRange{Float64, Int64}:\n 0.0,0.002,0.004,0.006,0.008,0.01,0.012,…,9.99,9.992,9.994,9.996,9.998,10.0","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Time evolve the system in the full space","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"prob = SchrodingerProblem(init_state, Tmax, h, dt = Tmax/(nsteps-1) , adaptive = false);\nintegrator = init(prob, Vern6());\n\ndensities = []\nfor _ in TimeChoiceIterator(integrator, 0.0:Tmax/(nsteps-1):Tmax)\n    push!(densities, expect(put(nsites, 1=>Op.n), init_state))\nend","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Time evolve the system in the subspace","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"prob2 = SchrodingerProblem(init_state2, Tmax, h, dt = Tmax/(nsteps-1) , adaptive = false);\nintegrator2 = init(prob2, Vern8());\n\ndensities2 = []\nfor _ in TimeChoiceIterator(integrator2, 0.0:Tmax/(nsteps-1):Tmax)\n    push!(densities2, expect(put(nsites, 1=>Op.n), init_state2))#, SubspaceArrayReg(u, space)))\nend","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"Plot the data","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"fig, ax = plt.subplots(figsize=(8,6))\n\nax.plot(times,real(densities),\"k\",label=\"Full space\")\nax.plot(times,real(densities2),\"r--\",label=\"Subspace\")\nax.axis([0,Tmax,0,0.45])\nax.set_xlabel(\"Time (us)\")\nax.set_ylabel(\"Rydberg density\")\nplt.tight_layout()\nax.legend()\n\ninset_axes = pyimport(\"mpl_toolkits.axes_grid1.inset_locator\")\nax2 = inset_axes.inset_axes(ax,width=\"20%\",height=\"30%\",loc=\"lower right\",borderpad=1)\nax2.plot(times,real(densities - densities2))\nax2.axis([0,0.6,-0.0008,0.0008])\nax2.set_ylabel(\"Difference\",fontsize=12)\nax2.set_yticks(LinRange(-0.0008,0.0008,5),fontsize=12)\nax2.set_xticks([0,0.2,0.4,0.6],fontsize=12)\nfig","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"(Image: )","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"","category":"page"},{"location":"tutorials/ring/main/","page":"Ring Emulation","title":"Ring Emulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"julia/#The-Julia-Programming-Language","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"The Bloqade project is built in pure Julia programming language. Thus if you are not familiar with Julia, here is a quick start for basic Julia gramar, and a guide for learning more detailed and advanced Julia.","category":"page"},{"location":"julia/#Why-Julia?","page":"The Julia Programming Language","title":"Why Julia?","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Fast, as you might have heard about it, Julia is very fast, there are various benchmarks online.   It can even be used to write Basic Linear Algebra Subroutine (BLAS) to reach performance on par with   manually optimized assembly with C (check Octavian).\nGeneric, the language itself and its ecosystem are built to be generic, and the compiler can specialize   on generic methods automatically, thus you will find a lot things can be combined easily, and they will   just work, e.g plugin the Measurement number from    Measurement.jl into your ODE solver, you will get error propagation just work, plugin Tropical number into tensor contraction function, you can   solve optimization problems with tensor networks, and so on.\nDifferentiable, the language is differentiable, that means you can calculate the derivatives   using an automatic differentiation engine on the whole language. The current stable AD engine   is powered by Zygote, the next generation AD engine includes   Diffractor (check the video talk on ACM SIGPLAN),   Enzyme.\nExtensible, the language is designed to be compiler friendly, it supports staged programming   as well as compiler plugins. This makes supporting new hardware much easier. As a result, Julia   can support multiple different hardware, such as CUDA,   oneAPI, TPU and so on.\nEasy, with all these features, yet the language itself stays rather easy to learn. Let's go to   the quick start section to skim the syntax.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"info: Info\nMulti-stage programming (MSP) is a variety of metaprogramming in which compilation is divided into a series of intermediate phases, allowing typesafe run-time code generation. Statically defined types are used to verify that dynamically constructed types are valid and do not violate the type system. – Wikipedia","category":"page"},{"location":"julia/#Quick-Start","page":"The Julia Programming Language","title":"Quick Start","text":"","category":"section"},{"location":"julia/#Variables-and-Some-Basic-Types","page":"The Julia Programming Language","title":"Variables and Some Basic Types","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can define a variable similar to how you define it in Python, e.g we can define a x using = (assignment)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"x = 1","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"every variable has a type, you can check it using typeof","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(x)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"By default Julia displays the output of the last operation. (You can suppress the output by adding ; (a semicolon) at the end.)","category":"page"},{"location":"julia/#Functions","page":"The Julia Programming Language","title":"Functions","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can also define short-form, one-line functions using = (assignment) similar to how you write things mathematically.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f(x) = 2x","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Typing the function's name gives information about the function. To call it we must use parentheses:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f\nf(2)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For longer functions we use the following syntax with the function keyword and end:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"function g(x, y)\n\tz = x + y\n\treturn z^2\nend","category":"page"},{"location":"julia/#Control-Flows","page":"The Julia Programming Language","title":"Control Flows","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, there are for, if and while, they look like the following","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s = 0\nfor i in 1:10\n    s += 1\nend","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"we can now check the value of s by typing it again","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Here, 1:10 is a range representing the numbers from 1 to 10:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(1:10)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"the if else statement looks like the following","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if s < 10\n\t# do something\nelseif 10 < s < 13\n\t# do something\nelse\n\t# do something\nend","category":"page"},{"location":"julia/#Matrix-and-Array","page":"The Julia Programming Language","title":"Matrix and Array","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own Array type, if you use Python, it is similar to numpy.array in Python except:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"index starts from 1\nthe multi-dimensional index is column-wise","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"You can also have list comprehension:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[i for i in 1:10]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"it works for multi-dimensional case too:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[(i, j) for i in 1:10, j in 1:5]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"most functions follow the same convention as numpy or MATLAB, e.g you can create a random matrix using:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"rand(5, 5)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if you have question about using a function, you can always type question mark ? in your REPL following the function name","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> ?rand","category":"page"},{"location":"julia/#Package-Manager-and-Environments","page":"The Julia Programming Language","title":"Package Manager & Environments","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own package manager, you can use it as a normal package:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> using Pkg","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"to install a pacakge, you can use","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.add(\"Yao\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"to remove a pacakge, you can use","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.rm(\"Yao\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"All Julia program runs inside an environment, it is the global environment by default. It is usually recommended to run your notebook in a local environment, so we won't hit any version conflicts between different packages. ","category":"page"},{"location":"julia/#Resources","page":"The Julia Programming Language","title":"Resources","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For more resources just check the official website julialang.org/learning","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"<style>\n  iframe {\n    width: 1px;\n    min-width: 100%;\n    min-height: 1000px;\n  }\n</style>\n<iframe id=\"myIframe\" src=\"https://julialang.org/learning/\"></iframe>\n<script>\n  iFrameResize({ log: true }, '#myIframe')\n</script>","category":"page"}]
}
