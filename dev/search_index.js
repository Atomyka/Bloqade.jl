var documenterSearchIndex = {"docs":
[{"location":"topics/blockade/#Rydberg-Blockade","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"","category":"section"},{"location":"tutorials/qaoa/","page":"Quantum Approximate Optimization Algorithm","title":"Quantum Approximate Optimization Algorithm","text":"EditURL = \"https://github.com/Happy-Diode/EaRyd.jl/blob/master/examples/qaoa/main.jl\"","category":"page"},{"location":"tutorials/qaoa/","page":"Quantum Approximate Optimization Algorithm","title":"Quantum Approximate Optimization Algorithm","text":"","category":"page"},{"location":"tutorials/qaoa/","page":"Quantum Approximate Optimization Algorithm","title":"Quantum Approximate Optimization Algorithm","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contrib/#Contributing","page":"Contributing EaRyd","title":"Contributing","text":"","category":"section"},{"location":"contrib/","page":"Contributing EaRyd","title":"Contributing EaRyd","text":"If you are interested in contributing to this package, please consider going through this guide to help you smooth your developing workflow.","category":"page"},{"location":"contrib/","page":"Contributing EaRyd","title":"Contributing EaRyd","text":"Contributing to documentation is always a good start to get familiar with the community and workflows.","category":"page"},{"location":"contrib/#Documentation","page":"Contributing EaRyd","title":"Documentation","text":"","category":"section"},{"location":"contrib/#Setting-Up-Environments","page":"Contributing EaRyd","title":"Setting Up Environments","text":"","category":"section"},{"location":"contrib/#Components","page":"Contributing EaRyd","title":"Components","text":"","category":"section"},{"location":"cuda/#CUDA-Acceleration","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"","category":"section"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"The emulator supports CUDA acceleration, to use CUDA acceleration, you will need NVIDIA graphic card.","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"Converting your CPU-based simulation to CUDA-based simulation is simple, just use the cu function from CUDA on the register object, which will convert the CPU-based register to a CUDA-based register, e.g","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"reg = zero_state(5)\ndreg = cu(reg) # device register","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"other code in the emulator should adapt to CUDA automatically.","category":"page"},{"location":"topics/ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"EditURL = \"https://github.com/Happy-Diode/EaRyd.jl/blob/master/examples/quantum-scar/main.jl\"","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"using EaRyd\nusing Random","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"In this example, we use the Rydberg Emulator to simulate and evolve a fully coherent, strongly interacting system of 9 qubits to observe emergent oscillations in many-body dynamics afer a sudden quench to single-atom resonance. We demonstrate the many-body dynamics with measurements of the domain wall density, which signals the appearance and disappearance of crystalline states.","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"We start by building the 1D-Chain 10-atom arrangement, with each atom separated from its neighbor by 5.72 micrometers We evaluate the quench dynamics of the Rydberg atom array initially prepared in a product state as the detuning changes to single atom resonance After the quence, we observe oscillations of many-body states between the initial and inverted states.","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"Random.seed!(42)","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"Random.TaskLocalRNG()","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"build lattice structure","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"nsites = 10\natoms = generate_sites(ChainLattice(), nsites, scale=5.72)","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"46.03mm\" viewBox=\"0 0 120 46.03\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.53\" id=\"img-a8e08e17-1\">\n  <g transform=\"translate(23.01,32.22)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(41.51,32.22)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">12.87μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,32.22)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">25.74μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(78.49,32.22)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">38.61μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.99,32.22)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">51.48μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.51,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.51,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.51,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.51,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(11.51,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"0.39\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-a8e08e17-2\">\n  <g transform=\"translate(23.01,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(31.23,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(39.45,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(47.67,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(55.89,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(64.11,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(72.33,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(80.55,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(88.77,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(96.99,23.01)\">\n    <circle cx=\"0\" cy=\"0\" r=\"1.97\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"1.86\" id=\"img-a8e08e17-3\">\n  <g transform=\"translate(23.01,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(31.23,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(39.45,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(47.67,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(55.89,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(64.11,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(72.33,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(80.55,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(88.77,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n  <g transform=\"translate(96.99,23.01)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">10</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"construct Rydberg Hamiltonian with specified Rabi frequency","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"h = rydberg_h(atoms;C = 2π * 858386, Ω=4π)","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"Hamiltonian\n  Term 1\n   ∑(n=1:10) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n  Term 2\n   ∑(n=1:10) 12.6/2 σ^x","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"construct initial product state","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"config = rand(0:1, 10)\ninit = product_state(config)","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"ArrayReg{1, ComplexF64, Array...}\n    active qubits: 10/10","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"perform discrete time evolution given timestep ts = 0.01 for 120 iterations using Krylov","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"iteration = 1:120\nts = [0.01 for _ in iteration];\nhs = [h for _ in iteration];\nprob = KrylovEvolution(init, ts, hs)","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"KrylovEvolution{Float64}:\n  reg: ArrayReg{1, ComplexF64, Matrix{ComplexF64}}\n  reg storage: 16.000 KiB\n\n  total duration: 1.2000000000000002 μs\n\n  hamiltonian: \n    Hamiltonian\n      Term 1\n       ∑(n=1:10) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n      Term 2\n       ∑(n=1:10) 12.6/2 σ^x\n\n       ⋮\n\n    Hamiltonian\n      Term 1\n       ∑(n=1:10) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n      Term 2\n       ∑(n=1:10) 12.6/2 σ^x\n\n  hamiltonian storage: 135.875 KiB\n\n  options: \n    progress: false\n    progress_step: 1\n    progress_name: \"emulating\"\n    normalize_step: 5\n    normalize_finally: true","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"measure observable","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"clocks = cumsum(ts)","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"120-element Vector{Float64}:\n 0.01\n 0.02\n 0.03\n 0.04\n 0.05\n 0.060000000000000005\n 0.07\n 0.08\n 0.09\n 0.09999999999999999\n 0.10999999999999999\n 0.11999999999999998\n 0.12999999999999998\n 0.13999999999999999\n 0.15\n 0.16\n 0.17\n 0.18000000000000002\n 0.19000000000000003\n 0.20000000000000004\n 0.21000000000000005\n 0.22000000000000006\n 0.23000000000000007\n 0.24000000000000007\n 0.25000000000000006\n 0.26000000000000006\n 0.2700000000000001\n 0.2800000000000001\n 0.2900000000000001\n 0.3000000000000001\n 0.3100000000000001\n 0.3200000000000001\n 0.3300000000000001\n 0.34000000000000014\n 0.35000000000000014\n 0.36000000000000015\n 0.37000000000000016\n 0.38000000000000017\n 0.3900000000000002\n 0.4000000000000002\n 0.4100000000000002\n 0.4200000000000002\n 0.4300000000000002\n 0.4400000000000002\n 0.45000000000000023\n 0.46000000000000024\n 0.47000000000000025\n 0.48000000000000026\n 0.49000000000000027\n 0.5000000000000002\n 0.5100000000000002\n 0.5200000000000002\n 0.5300000000000002\n 0.5400000000000003\n 0.5500000000000003\n 0.5600000000000003\n 0.5700000000000003\n 0.5800000000000003\n 0.5900000000000003\n 0.6000000000000003\n 0.6100000000000003\n 0.6200000000000003\n 0.6300000000000003\n 0.6400000000000003\n 0.6500000000000004\n 0.6600000000000004\n 0.6700000000000004\n 0.6800000000000004\n 0.6900000000000004\n 0.7000000000000004\n 0.7100000000000004\n 0.7200000000000004\n 0.7300000000000004\n 0.7400000000000004\n 0.7500000000000004\n 0.7600000000000005\n 0.7700000000000005\n 0.7800000000000005\n 0.7900000000000005\n 0.8000000000000005\n 0.8100000000000005\n 0.8200000000000005\n 0.8300000000000005\n 0.8400000000000005\n 0.8500000000000005\n 0.8600000000000005\n 0.8700000000000006\n 0.8800000000000006\n 0.8900000000000006\n 0.9000000000000006\n 0.9100000000000006\n 0.9200000000000006\n 0.9300000000000006\n 0.9400000000000006\n 0.9500000000000006\n 0.9600000000000006\n 0.9700000000000006\n 0.9800000000000006\n 0.9900000000000007\n 1.0000000000000007\n 1.0100000000000007\n 1.0200000000000007\n 1.0300000000000007\n 1.0400000000000007\n 1.0500000000000007\n 1.0600000000000007\n 1.0700000000000007\n 1.0800000000000007\n 1.0900000000000007\n 1.1000000000000008\n 1.1100000000000008\n 1.1200000000000008\n 1.1300000000000008\n 1.1400000000000008\n 1.1500000000000008\n 1.1600000000000008\n 1.1700000000000008\n 1.1800000000000008\n 1.1900000000000008\n 1.2000000000000008","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"create empty lists of output expectation values","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"entropy = zeros(length(iteration)) # entanglement entropy\ndomain_mat = zeros(nsites-1, length(iteration)) # domain wall number\ndensity_mat = zeros(nsites, length(iteration)) # density matrix\n\nfor info in prob\n    for i in 1:nsites\n        density_mat[i, info.step] = expect(put(nsites, i=>Op.n), info.reg)\n    end\n\n    for i in 1:nsites-1\n        corr = real(expect(put(nsites, (i, i+1)=>kron(Op.n, Op.n)), info.reg))\n        obs = density_mat[i, info.step] + density_mat[i+1, info.step] - 2corr\n        domain_mat[i, info.step] = obs\n    end\n\n    rho = density_matrix(info.reg, (1,2,3,4,5))\n    entropy[info.step] = von_neumann_entropy(rho)\nend","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"Plot results","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"using CairoMakie\nfig = Figure(size=(10, 5));\nax = Axis(fig[1, 1])\n\nfor i in 1:nsites\n    lines!(clocks, density_mat[i, :])\nend\nfig\n\nheatmap(clocks, 1:nsites, density_mat')\nheatmap(clocks, 1:nsites, domain_mat')\ndomain_avg = vec(sum(domain_mat, dims=1)/(nsites-1))\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(ax, clocks, domain_avg)\nlines!(ax, clocks, entropy)\nfig","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"(Image: )","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"TODO: subspace","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"","category":"page"},{"location":"tutorials/quantum-scar/","page":"Quantum Scar","title":"Quantum Scar","text":"This page was generated using Literate.jl.","category":"page"},{"location":"topics/bravais/#bravais-lattice","page":"Bravais Lattice","title":"Bravais Lattice","text":"","category":"section"},{"location":"quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick-start/#Create-a-Hamiltonian","page":"Quick Start","title":"Create a Hamiltonian","text":"","category":"section"},{"location":"quick-start/#Define-Atom-Positions","page":"Quick Start","title":"Define Atom Positions","text":"","category":"section"},{"location":"quick-start/#Run-emulation","page":"Quick Start","title":"Run emulation","text":"","category":"section"},{"location":"quick-start/#Create-a-Lattice","page":"Quick Start","title":"Create a Lattice","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Creating a lattice is very simple in EaRyd, e.g we can create a square lattice as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using EaRyd\ngenerate_sites(SquareLattice(), 3, 3)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"this generates the atom positions on a 3times 3 square lattice using the generate_sites function.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"we support the following built-in lattice: SquareLattice, KagomeLattice, HoneycombLattice, and more. Please refer to Lattices for more detailed guide of lattice related operation.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"tips: Tips\nThe lattice in EaRyd is actually defined as general Bravis lattice. You can create your own by defining the corresponding lattice vector. Check Bravais Lattice","category":"page"},{"location":"quick-start/#Create-a-Waveform","page":"Quick Start","title":"Create a Waveform","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"EaRyd gives users the flexibility to specify general waveform by inputing functions. The following code constracting a sinusoidal waveform with time duration of 4 pi","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"waveform = Waveform(t->2.2sin(t), duration=4π)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"We also support several built-in time-dependent waveforms, including piecewise_linear, piecewise_constant, linear_ramp, constant, sinusoidal. For example, we can create a piecewise linear waveform simply by one line below ","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"waveform = piecewise_linear(clocks=[0.0, 0.2, 0.5, 0.8, 1.0], values=[0.0, 1.5, 3.1, 3.1, 0.0])","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Please refer to Waveform for more detailed guide of waveform related operation.","category":"page"},{"location":"quick-start/#Create-a-Register","page":"Quick Start","title":"Create a Register","text":"","category":"section"},{"location":"hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The simplest way of creating a Hamiltonian is via the rydberg_h function","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"rydberg_h","category":"page"},{"location":"hamiltonians/#EaRydCore.rydberg_h","page":"Hamiltonians","title":"EaRydCore.rydberg_h","text":"rydberg_h(atoms; [C=2π * 858386 * MHz*µm^6], Ω[, ϕ, Δ])\n\nCreate a rydberg hamiltonian\n\n fracCr_i - r_j^6 n_i n_j + fracΩ2 σ_x - Δ σ_n\n\nshorthand for\n\nRydInteract(C, atoms) + XTerm(length(atoms), Ω, ϕ) + ZTerm(length(atoms), Δ)\n\nArguments\n\natoms: a collection of atom positions\n\nKeyword Arguments\n\nC: optional, default unit is MHz*µm^6, interation parameter,   see also RydInteract.\nΩ: required, default unit is MHz, Rabi frequencies, see XTerm.\nΔ: optional, default unit is MHz, detuning parameter, see NTerm.\nϕ: optional, does not have unit, the phase, see XTerm.\n\ntips: Tips\nThe parameters of Hamiltonian have their own default units to match hardware, one can use Unitful.jl to specify their units explicitly. If the units are specified explicitly, they will be converted to default units automatically.\n\nExample\n\njulia> using EaRyd\n\njulia> atoms = generate_sites(SquareLattice(), 3, 3);\n\njulia> rydberg_h(atoms; Δ=1.2, Ω=1.1)\nHamiltonian\n  Term 1\n   ∑(n=1:9) 1.1/2 σ^x\n\n  Term 2\n   -∑(n=1:9) 1.2 n\n\n  Term 3\n   ∑(n=1:9) 686.0/|r_i - r_j|^6 n_i n_j\n\njulia> rydberg_h(atoms; Δ=1.2, Ω=1.1, ϕ=2.1)\nHamiltonian\n  Term 1\n   ∑(n=1:9) 1.1/2 (e^{2.1i}|0)⟨1| + e^{-2.1i}|1⟩⟨0|)\n\n  Term 2\n   -∑(n=1:9) 1.2 n\n\n  Term 3\n   ∑(n=1:9) 686.0/|r_i - r_j|^6 n_i n_j\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians/#The-Hamiltonian-Expressions","page":"Hamiltonians","title":"The Hamiltonian Expressions","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Inside this package, a more general definition of hamiltonians are supported as Symbolic expressions, this gives user the flexiblity to define various different kind of hamltonian by simply writing down the expression.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"There are currently 4 terms supported: RydInteract, XTerm, NTerm, ZTerm. The terms can be added up to compose a new hamiltonian, e.g","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using EaRyd\nh = XTerm(5, 1.0) + ZTerm(5, 1.0)","category":"page"},{"location":"hamiltonians/#Convert-Hamiltonian-Expression-to-Matrices","page":"Hamiltonians","title":"Convert Hamiltonian Expression to Matrices","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The Hamiltonian expressions can be converted to matrices via type conversion, e.g we can convert the above hamiltonian to a SparseMatrixCSC","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using SparseArrays\nSparseMatrixCSC(h)","category":"page"},{"location":"lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices/#Create-a-Lattice","page":"Lattices","title":"Create a Lattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Creating a lattice is very simple in EaRyd, e.g we can create a square lattice as following","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using EaRyd\ngenerate_sites(SquareLattice(), 3, 3)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"this generates the atom positions on a 3times 3 square lattice using the generate_sites function.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"we support the following built-in lattice: SquareLattice, KagomeLattice, HoneycombLattice, and more. Please refer to Lattices for more detailed guide of lattice related operation.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"tip: Tip\nThe lattice in EaRyd is actually defined as general Bravis lattice. You can create your own by defining the corresponding lattice vector. Check Bravais Lattice","category":"page"},{"location":"lattices/#Bravais-Lattices","page":"Lattices","title":"Bravais Lattices","text":"","category":"section"},{"location":"lattices/#Plotting-Lattices","page":"Lattices","title":"Plotting Lattices","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"CurrentModule = EaRydWaveforms","category":"page"},{"location":"waveform/#Waveform","page":"Waveforms","title":"Waveform","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms are signals used in pulse programming or as hamiltonian parameters. The waveforms are defined as Waveform object, which is a composition of a callable object and a real number duration.","category":"page"},{"location":"waveform/#Creating-Waveforms","page":"Waveforms","title":"Creating Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"EaRyd gives users the flexibility to specify general waveform by inputing functions. The following code constracting a sinusoidal waveform with time duration of 4 pi","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"using EaRydWaveforms # hide\nwaveform = Waveform(t->2.2sin(t), duration=4π)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"We also support several built-in time-dependent waveforms, including piecewise_linear, piecewise_constant, linear_ramp, constant, sinusoidal. For example, we can create a piecewise linear waveform simply by one line below ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_linear(clocks=[0.0, 0.2, 0.5, 0.8, 1.0], values=[0.0, 1.5, 3.1, 3.1, 0.0])","category":"page"},{"location":"waveform/#Slicing-Waveforms","page":"Waveforms","title":"Slicing Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms can be sliced using the duration syntax start..stop, e.g","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"using EaRydWaveform # hide\nwf = sinusoidal(duration=2.2)\nwf[1.1..1.5]","category":"page"},{"location":"waveform/#Composing-Waveforms","page":"Waveforms","title":"Composing Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms can be composed together via append","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"EaRydWaveforms.append","category":"page"},{"location":"waveform/#EaRydWaveforms.append","page":"Waveforms","title":"EaRydWaveforms.append","text":"append(wf::Waveform, wfs::Waveform...)\n\nAppend other waveforms to wf on time axis.\n\n\n\n\n\n","category":"function"},{"location":"waveform/#Waveform-Smoothing","page":"Waveforms","title":"Waveform Smoothing","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Sharp waveforms may result in bad performance in practice, it is sometimes preferred to smoothen the waveform using the moving average methods, one can use the smooth function to create a smooth-ed wavefrom from a piecewise linear waveform.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"CurrentModule = EaRyd","category":"page"},{"location":"emulation/#Emulation-of-Shordinger-Equation","page":"Emulation","title":"Emulation of Shordinger Equation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The dynamics of Rydberg system is described by a Shordinger Equation of a hamiltonian. There are two methods for solving this equation, one is via Krylov subspace projection for time independent hamiltonian, the other is ODE-basd solver.","category":"page"},{"location":"emulation/#Krylov-Based-Solver","page":"Emulation","title":"Krylov Based Solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The Krylov-based method expects time independent hamiltonians, one can define such evolution via KrylovEvolution object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"KrylovEvolution","category":"page"},{"location":"emulation/#EaRydCore.KrylovEvolution","page":"Emulation","title":"EaRydCore.KrylovEvolution","text":"KrylovEvolution{P}(register, durations, hs; kw...)\n\nCreate a KrylovEvolution object that emulates a list of hamiltonians at discrete time steps using Krylov subspace method, or trotterize a continuous function with dt then run the trotterize integrator on it.\n\nArguments\n\nP: optional, a type parameter that sets the problem precision type, default is   the same as the Yao.datatype of given register.\nregister: required, the evolution problem register, can be a RydbergReg or an ArrayReg   from Yao.\ndurations: required, the evolution durations of each hamiltonian, should be a list of real numbers.\nhs: required, the evolution hamiltonian, a list of hamiltonians with constant parameters.\n\nKeyword Arguments\n\ncache: discrete solver cache, see also KrylovEmulationCache.\nnormalize_step::Int: run normalization per normalize_step, default is 5.\nnormalize_finally::Bool: normalize the state after the entire emulation ends, default is true.\nprogress::Bool: show progress bar, default is false.\nprogress_step::Int: update the progress bar per progress_step, default is 1.\nprogress_name::String: the printed name on progress bar, default is \"emulating\".\ndt::Real: the time step of trotterization if ts is specified as   a Real number and hs is a time dependent hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"tip: Tip\none can use trotterize function to discretize a time-dependent hamiltonian into a list of time indepdent hamiltonian to use  Krylov-based solver for time-dependent problem if preferred.","category":"page"},{"location":"emulation/#ODE-Based-Solver","page":"Emulation","title":"ODE Based Solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The ODE-based method expects time-dependent hamiltonians, one can define such evolution via ODEEvolution object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ODEEvolution","category":"page"},{"location":"emulation/#EaRydODE.ODEEvolution","page":"Emulation","title":"EaRydODE.ODEEvolution","text":"ODEEvolution{P}\n\nProblem type for hamiltonian with time dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"emulation/#Run-Emulation","page":"Emulation","title":"Run Emulation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"To run the emulation, you need to define the exact evolution and solver you would like to run with via either KrylovEvolution or ODEEvolution, then feed the corresponding object to emulate! function","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"emulate!","category":"page"},{"location":"emulation/#EaRydCore.emulate!","page":"Emulation","title":"EaRydCore.emulate!","text":"emulate!(evolution)\n\nRun emulation on given evolution object. See also KrylovEvolution, or ContinousEvolution.\n\nArguments\n\nevolution: the evolution object.\n\n\n\n\n\n","category":"function"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For example, we can simulate a constant hamiltonian","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"using EaRyd\natoms = generate_sites(SquareLattice(), 3, 3; scale=5.1)\nds = rand(3) # durations\nhs = [rydberg_h(atoms;Δ=2.0, Ω=1.0) for _ in 1:3]\nreg = zero_state(length(atoms)) # create fullspace register\nev = KrylovEvolution(reg, ds, hs)\nemulate!(ev)","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Or if you would like to do some operation during the evolution, such as measure observables during the evolution, you can instead write the for loop","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ev = KrylovEvolution(reg, ds, hs)\nfor info in ev\n    @info \"running emulation\" step=info.step duration=info.duration h=info.hamiltonian reg=info.reg\nend","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"You can use any function on the reg object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"tip: Tip\nremember to make sure your operation does not mutate your state so that this won't effect the evolution itself, since the entire time evolution is simulated by keep mutating the state vector stored in reg which means do not use any function that has a ! in its name on the register info.reg unless you are certain about what you are doing.","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"EditURL = \"https://github.com/Happy-Diode/EaRyd.jl/blob/master/examples/ground/main.jl\"","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"write your EaRyd example with Literate.jl here calculate the ground states of a ladder system","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"using EaRyd\nusing KrylovKit\nusing SparseArrays\nusing CairoMakie","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"we create a two ladder of atoms with 8 sites in each row","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"n_sites = 8","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"8","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"x coordinate for each row","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"ax = 1\nL = (n_sites - 1)* ax\natomx = collect(0.0:ax:L)","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"8-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n 4.0\n 5.0\n 6.0\n 7.0","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"y coordinate for the two rows","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"ay1 = 0\nay2 = 2","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"2","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"generate the atom sites one by one, since we dont have rectangular lattice now","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"atom_coordinate = [(0.0, 0.0)]\nfor ii = 2: n_sites\n    push!(atom_coordinate, (atomx[ii], ay1))\nend\nfor ii = 1: n_sites\n    push!(atom_coordinate, (atomx[ii], ay2))\nend","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"Hamiltonian parameters","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"C = 2.3^6\nΔ = 4 * ones(2*n_sites)\nΩ = 1* ones(2*n_sites)\nΔ[2* n_sites] += -0.05  # addtional detuning term to break the symmetry","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"3.95","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"create the Hamiltonian","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"h = rydberg_h(atom_coordinate; C=C, Δ=Δ, Ω=Ω)","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"Hamiltonian\n  Term 1\n   ∑(n=1:16) 148.0/|r_i - r_j|^6 n_i n_j\n\n  Term 2\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x +\n   1.0/2 σ^x\n\n  Term 3\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   4.0 n +\n   3.95 n","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"the sparse matrix for the hamiltonian","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"H0 = SparseMatrixCSC(h)","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"65536×65536 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1114111 stored entries:\n⣿⣿⣾⢦⡀⠳⣄⠀⠀⠀⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠺⣟⢻⣶⣿⡂⠈⠳⣄⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⢤⡈⠻⠻⠿⣧⣤⣠⡈⠳⠄⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠙⢦⡀⠀⣻⣿⣿⣙⣦⡀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠙⢦⡈⠳⣼⣿⣿⡆⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠙⢦⡀⠀⠀⠁⠀⠈⠈⠉⣿⣿⣾⢦⡀⠳⣄⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠺⣟⢻⣶⣿⡂⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⢤⡈⠻⠻⠿⣧⣤⣠⡈⠳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠙⢦⡀⠀⣻⣿⣿⣙⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠙⢦⡈⠳⣼⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄\n⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡟⢦⡈⠳⣄⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣍⣿⣿⣯⠀⠈⠳⣄⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⡈⠋⠛⢻⣶⣦⣦⡈⠓⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠨⣿⠿⣧⣽⡦⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠙⢦⠈⠳⡿⣿⣿⣀⡀⡀⠀⢀⠀⠀⠈⠳⣄\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠸⣿⣿⡟⢦⡈⠳⣄⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠈⠻⣍⣿⣿⣯⠀⠈⠳⣄⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠐⢦⡈⠋⠛⢻⣶⣦⣦⡈⠓\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠙⢦⡀⠨⣿⠿⣧⣽⡦\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠙⢦⠈⠳⡿⣿⣿","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"diagonize the hamiltonian","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"vals, vecs, info = KrylovKit.eigsolve(H0,  4, :SR)\nstate1 = ArrayReg(vecs[1])","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"ArrayReg{1, ComplexF64, Array...}\n    active qubits: 16/16","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"measruing the magnetization for the ground state","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"output_mat1 = zeros(Float64, 2*n_sites)\nfor i in 1:2*n_sites\n     output_mat1[i] = real(expect(put(2*n_sites, i=>Op.n), state1))\nend\nprintln(output_mat1)","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"[0.03664241855337393, 0.8991807296045933, 0.008432651032628653, 0.00277204630289679, 0.93577522231578, 0.005136445349415519, 0.0013037673093657157, 0.9628372805132885, 0.9624520014710578, 0.0013778621040051872, 0.005168909275319624, 0.9359261213570252, 0.0027032972912197644, 0.007810489797107941, 0.9059497769676133, 0.03118108800269738]\n","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"plot the difference of the magnetization in the two rows","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"n_diff = output_mat1[1:n_sites]- output_mat1[n_sites+1: 2*n_sites]\nlines(1:n_sites, n_diff)","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"","category":"page"},{"location":"tutorials/ground/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"EditURL = \"https://github.com/Happy-Diode/EaRyd.jl/blob/master/examples/adiabatic/main.jl\"","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"using EaRyd\nusing CairoMakie\nusing EaRydPlots","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"In this example, we examine the adiabatic preparation of a spin Hamiltonian.","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We first prepare the adiabatic pulse sequence as two piecewise linear functions define the rabi waveform","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Ω_max = 2.3 * 2 * pi\nΩ = piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[0.0, Ω_max , Ω_max , 0])","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n               20 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⢰⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ ","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"define the detuning waveform","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"U = Ω_max / 2.3\nΔ = piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[-6*U, -6*U, 2*U , 2*U])","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n               20 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⡟⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n              -40 │⠒⠒⠒⠒⠒⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ ","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We prepare a square lattice of 9 atoms create the atom positions","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"nx, ny = 3, 3\nnsites = nx*ny\n\natoms = generate_sites(SquareLattice(), nx, ny, scale=9.629)","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"120mm\" viewBox=\"0 0 120 120\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.53\" id=\"img-8d9d72d6-1\">\n  <g transform=\"translate(35,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(47.5,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4.81μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9.63μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(72.5,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">14.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">19.26μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,72.5)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4.81μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9.63μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,47.5)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">14.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">19.26μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"1.2\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-8d9d72d6-2\">\n  <g transform=\"translate(35,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(35,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(35,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"5.64\" id=\"img-8d9d72d6-3\">\n  <g transform=\"translate(35,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(35,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(35,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We construct the Rydberg Hamiltonian from the defined rabi and detuning waveforms","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"h = rydberg_h(atoms; C=2 * pi * 858386, Δ, Ω)","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"Hamiltonian\n  Term 1\n   ∑(n=1:9) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n  Term 2\n   ∑(n=1:9) Waveform(_, 1.6)(t)/2 σ^x\n\n  Term 3\n   -∑(n=1:9) Waveform(_, 1.6)(t) n","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We evolve the system from the zero state using the ODE solver to a final time t = 1.6 microseconds","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"prob = ODEEvolution(zero_state(9), 1.6, h)\nemulate!(prob) # run the time evolution directly","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"ODEEvolution{Float64}:\n  reg: ArrayReg{1, ComplexF64, Matrix{ComplexF64}}\n  reg storage: 8.000 KiB\n\n  timespan: (0.0, 1.6)\n  equation: \n    Schrödinger Equation:\n      Storage Size: 69.992 KiB\n      State Storage: Vector{ComplexF64}\n      Hamiltonian Storage: SparseArrays.SparseMatrixCSC{Float64, Int32}\n      Hamiltonian\n        Term 1\n         ∑(n=1:9) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n        Term 2\n         ∑(n=1:9) Waveform(_, 1.6)(t)/2 σ^x\n\n        Term 3\n         -∑(n=1:9) Waveform(_, 1.6)(t) n\n\n  options: \n    algo: Vern8(true)\n    progress: false\n    progress_steps: 5\n    progress_name: \"ODE\"\n    reltol: 1.0e-8\n    abstol: 1.0e-8\n    normalize_steps: 5\n    normalize_finally: true","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"We compute the Rydberg probability and plot the histogram of the most frequent results from sampling the final state","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"densities = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend\n\nbitstring_histgram(prob.reg; nlargest=20)","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"(Image: )","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"","category":"page"},{"location":"tutorials/adiabatic/","page":"Adiabatic Evolution","title":"Adiabatic Evolution","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#EaRyd","page":"References","title":"EaRyd","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [EaRyd]","category":"page"},{"location":"ref/#EaRydCore","page":"References","title":"EaRydCore","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [EaRydCore]","category":"page"},{"location":"ref/#EaRydCore.fullspace","page":"References","title":"EaRydCore.fullspace","text":"fullspace\n\nA constant for the FullSpace.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#EaRydCore.AbstractAtom","page":"References","title":"EaRydCore.AbstractAtom","text":"AbstractAtom\n\nAbstract type for atoms.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.AbstractSpace","page":"References","title":"EaRydCore.AbstractSpace","text":"AbstractSpace\n\nAbstract type for spaces.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.AbstractTerm","page":"References","title":"EaRydCore.AbstractTerm","text":"AbstractTerm\n\nAbstract term for hamiltonian terms.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.Atom2D","page":"References","title":"EaRydCore.Atom2D","text":"Atom2D{T} = RydAtom{2,T}\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.FullSpace","page":"References","title":"EaRydCore.FullSpace","text":"FullSpace <: AbstractSpace\n\nA trait for the full space.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.KrylovEmulationCache","page":"References","title":"EaRydCore.KrylovEmulationCache","text":"KrylovEmulationCache{C}\n\nCache type for the discrete emulation, type variable C is the actual matrix type for the hamiltonian storage.\n\nWhen we do Krylov subspace based time evolution emulation with a sequence of hamiltonians of similar terms, e.g all the hamiltonians are RydInteract + XTerm + ZTerm, the sparse structure will be the same, thus we can re-use the sparse matrix generated for the first hamiltonian again via update_term! in the following calculation to reduce the memory usage and speed up the emulation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.KrylovEmulationCache-Union{Tuple{Ti}, Tuple{Tv}, Tuple{EaRydCore.AbstractTerm, EaRydCore.AbstractSpace}} where {Tv, Ti}","page":"References","title":"EaRydCore.KrylovEmulationCache","text":"KrylovEmulationCache{Tv, Ti}(hs[, s::AbstractSpace=fullspace])\n\nCreate a KrylovEmulationCache.\n\nArguments\n\nT: element type of the storage.\nhs: a Hamiltonian expression term or a list of Hamiltonians.\ns: space type, default is fullspace.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.KrylovEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Vector{<:Real}, Vector{<:EaRydCore.AbstractTerm}}} where P","page":"References","title":"EaRydCore.KrylovEvolution","text":"KrylovEvolution{P}(register, durations, hs; kw...)\n\nCreate a KrylovEvolution object that emulates a list of hamiltonians at discrete time steps using Krylov subspace method, or trotterize a continuous function with dt then run the trotterize integrator on it.\n\nArguments\n\nP: optional, a type parameter that sets the problem precision type, default is   the same as the Yao.datatype of given register.\nregister: required, the evolution problem register, can be a RydbergReg or an ArrayReg   from Yao.\ndurations: required, the evolution durations of each hamiltonian, should be a list of real numbers.\nhs: required, the evolution hamiltonian, a list of hamiltonians with constant parameters.\n\nKeyword Arguments\n\ncache: discrete solver cache, see also KrylovEmulationCache.\nnormalize_step::Int: run normalization per normalize_step, default is 5.\nnormalize_finally::Bool: normalize the state after the entire emulation ends, default is true.\nprogress::Bool: show progress bar, default is false.\nprogress_step::Int: update the progress bar per progress_step, default is 1.\nprogress_name::String: the printed name on progress bar, default is \"emulating\".\ndt::Real: the time step of trotterization if ts is specified as   a Real number and hs is a time dependent hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.NTerm","page":"References","title":"EaRydCore.NTerm","text":"NTerm{Delta} <: AbstractTerm\nNTerm(nsites, Δs::Delta)\n\nType for N term\n\nExpression\n\nsum_i Δ_i n_i\n\nParameters\n\nΔs: the detuning parameter, the default unit is MHz.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.NTerm-Tuple{AbstractVector}","page":"References","title":"EaRydCore.NTerm","text":"NTerm(Δs::AbstractVector)\n\nCreate a simple NTerm from given Δs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.RydAtom","page":"References","title":"EaRydCore.RydAtom","text":"RydAtom{N,T} <: AbstractAtom\n\nPosition of one Rydberg atom.\n\nRydAtom(locs::NTuple{N, T})\n\nCreate a position of one Rydberg atom. The default unit is μm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.RydAtom-Tuple","page":"References","title":"EaRydCore.RydAtom","text":"RydAtom(locations...)\n\nCreate a RydAtom from given locations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.RydAtom-Tuple{AbstractVector}","page":"References","title":"EaRydCore.RydAtom","text":"RydAtom(locations::Vector)\n\nCreate a RydAtom from given list of locations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.RydInteract","page":"References","title":"EaRydCore.RydInteract","text":"RydInteract{T<:Number, AtomList <: AbstractVector{<:RydAtom}} <: AbstractTerm\nRydInteract(atoms::AbstractVector{<:RydAtom}, C::Number)\n\nType for Rydberg interactive term.\n\nExpression\n\nsum_i j fracCr_i - r_j^6 n_i n_j\n\nParameters\n\natoms: a list of atom positions, must be type RydAtom, default unit is μm.\nC: the interaction strength, default unit is MHz⋅μm^6. default value is 2π * 858386 * MHz*µm^6.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.RydbergReg-Tuple{AbstractMatrix{<:Real}, Subspace}","page":"References","title":"EaRydCore.RydbergReg","text":"RydbergReg(state::AbstractMatrix, subspace::Subspace)\n\nCreate a RydbergReg from real value storage.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.RydbergReg-Union{Tuple{N}, Tuple{AbstractVector, Subspace}} where N","page":"References","title":"EaRydCore.RydbergReg","text":"RydbergReg(state::AbstractVector, subspace::Subspace)\n\nCreate a RydbergReg from state vector and its corresponding subspace of natoms.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.Subspace","page":"References","title":"EaRydCore.Subspace","text":"Subspace{S <: AbstractVector{Int}} <: AbstractSpace\n\nA Dict-like object stores the mapping between subspace and full space.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.Subspace-Tuple{Int64, AbstractVector{Int64}}","page":"References","title":"EaRydCore.Subspace","text":"Subspace(nqubits::Int, subspace_v::AbstractVector{Int})\n\nCreate a Subspace from given list of subspace indices in the corresponding full space.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.XTerm","page":"References","title":"EaRydCore.XTerm","text":"XTerm{Omega, Phi} <: AbstractTerm\nXTerm(nsites::Int, Ωs::Omega, ϕs::Phi)\n\nType for X term.\n\nExpression\n\nsum_i Ω_i (e^iϕ_i 0_i1 + e^-iϕ_i1_i0)\n\nParameters\n\nΩ: rabi-frequency, the default unit for Ωs is MHz\nϕs phase, has no unit (or NoUnits in Unitful).\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.XTerm-Tuple{AbstractVector, AbstractVector}","page":"References","title":"EaRydCore.XTerm","text":"XTerm(Ωs::AbstractVector, ϕs::AbstractVector)\n\nCreate the XTerm from given Ωs and ϕs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.XTerm-Tuple{AbstractVector, Any}","page":"References","title":"EaRydCore.XTerm","text":"XTerm(Ωs::AbstractVector, ϕs::Number)\n\nCreate the XTerm from given Ωs and ϕs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.XTerm-Tuple{AbstractVector}","page":"References","title":"EaRydCore.XTerm","text":"XTerm(n::Int, Ωs::AbstractVector)\n\nCreate a simple XTerm from given Ωs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.XTerm-Tuple{Any, AbstractVector}","page":"References","title":"EaRydCore.XTerm","text":"XTerm(Ωs::Number, ϕs::AbstractVector)\n\nCreate the XTerm from given Ωs and ϕs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.XTerm-Tuple{Int64, Any}","page":"References","title":"EaRydCore.XTerm","text":"XTerm(n::Int, Ω::Number)\n\nCreate a simple XTerm from given number of atoms n and Ω.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.ZTerm","page":"References","title":"EaRydCore.ZTerm","text":"ZTerm{Delta} <: AbstractTerm\nZTerm(nsites, Δs::Delta)\n\nType for Z term.\n\nExpression\n\nsum_i Δ_iσ_i^z\n\nParameters\n\nΔs: the detuning parameter, the default unit is MHz.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydCore.ZTerm-Tuple{AbstractVector}","page":"References","title":"EaRydCore.ZTerm","text":"ZTerm(Δs::AbstractVector)\n\nCreate a simple ZTerm from given Δs.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.add_random_vertices","page":"References","title":"EaRydCore.add_random_vertices","text":"add_random_vertices([rng=GLOBAL_RNG], config::AbstractVector, graph::AbstractGraph, ntrials::Int = 10)\n\nAdd vertices randomly to given configuration for ntrials times and pick the one that has largest count_vertices.\n\nArguments\n\nrng: optional, Random Number Generator.\nconfig: configuration to tweak.\ngraph: problem graph.\nntrials: number of trials to use, default is 10.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.anyone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"References","title":"EaRydCore.anyone","text":"anyone(index::Integer, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(0b1011, 0b1001)\ntrue\njulia> anyone(0b1011, 0b1100)\ntrue\njulia> anyone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.blockade_subspace","page":"References","title":"EaRydCore.blockade_subspace","text":"blockade_subspace(atoms[, radius=1.0])\n\nCreate a blockade approximation subspace from given atom positions and radius.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.bmask","page":"References","title":"EaRydCore.bmask","text":"bmask(::Type{T}) where T <: Integer -> zero(T)\nbmask([T::Type], positions::Int...) -> T\nbmask([T::Type], range::UnitRange{Int}) -> T\n\nReturn an integer mask of type T where 1 is the position masked according to positions or range. Directly use T will return an empty mask 0.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.count_vertices-Tuple{Integer}","page":"References","title":"EaRydCore.count_vertices","text":"count_vertices(config::Integer)\n\ncounter the number of vertices in a spin configuration.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.create_subspace_from_mis-Tuple{Int64, AbstractVector}","page":"References","title":"EaRydCore.create_subspace_from_mis","text":"create_subspace_from_mis(n::Int, mis::AbstractVector)\n\nCreate Subspace from given list of maximal cliques/maximal independent set.\n\nArguments\n\nn: number of vertices of the graph.\nmis: the list of maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.distance-Tuple{RydAtom, RydAtom}","page":"References","title":"EaRydCore.distance","text":"distance(a::RydAtom, b::RydAtom)\n\nReturn the distance between two Rydberg atoms.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.emulate_step!","page":"References","title":"EaRydCore.emulate_step!","text":"emulate_step!(prob::KrylovEvolution, step::Int=1)\n\nRun single step evolution at given step index for a discrete evolution (Krylov-based).\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.exact_solve_mis-Tuple{Graphs.AbstractGraph}","page":"References","title":"EaRydCore.exact_solve_mis","text":"exact_solve_mis(g::AbstractGraph)\n\nReturn the exact MIS size of a graph g.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.expmv-Union{Tuple{T}, Tuple{Number, Any, Vector{T}}} where T","page":"References","title":"EaRydCore.expmv","text":"expmv(t, A, vec; [tol], [m], [norm], [anorm])\n\nCalculate matrix exponential acting on some vector, w = e^tAv, using the Krylov subspace approximation. See R.B. Sidje, ACM Trans. Math. Softw., 24(1):130-156, 1998 and http://www.maths.uq.edu.au/expokit\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.getterm","page":"References","title":"EaRydCore.getterm","text":"getterm(terms, k, k_site)\n\nGet the value of k-th local term in terms given the site configuration as k_site.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.gibbs_loss-Tuple{Any, Real}","page":"References","title":"EaRydCore.gibbs_loss","text":"gibbs_loss([f], reg_or_samples, α::Real)\n\nThe Gibbs loss for maximum independent set defined as\n\nL = -1α log(langle ψexp(α sum(n))ψrangle)\n\nwhere n is the vertex set size.\n\nArguments\n\nf: optional, postprocessing callback function f(config) -> config.   The input config is an integer of type Int, the output   config can be a type supports count_vertices   e.g, an AbstractVector or an Integer.\nreg_or_samples can be a register (Yao.ArrayReg or RydbergReg)   or a list of measurement result (config) in AbstractVector.\nα::Real: the parameter of Gibbs loss.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.independent_set_probabilities","page":"References","title":"EaRydCore.independent_set_probabilities","text":"independent_set_probabilities([f], reg::Yao.AbstractRegister, graph_or_mis)\n\nCalculate the probabilities of independent sets with given postprocessing function f(config) -> config. The default postprocessing function f will only reduce all configurations to independent set.\n\nArguments\n\nf: optional, postprocessing function, default is to_independent_set.\nreg: required, the register object.\ngraph_or_mis: a problem graph or the MIS size of the problem   graph (can be calculated via exact_solve_mis).\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.independent_set_subspace-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"References","title":"EaRydCore.independent_set_subspace","text":"independent_set_subspace(graph)\n\nCreate a subspace from given graph's maximal independent set.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.is_independent_set-Tuple{Any, Graphs.AbstractGraph}","page":"References","title":"EaRydCore.is_independent_set","text":"is_independent_set(config, graph::AbstractGraph)\n\nReturn true if config is an independent set of graph. config can be a BitStr, a vector, or any iterable.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.is_time_dependent-Tuple{Hamiltonian}","page":"References","title":"EaRydCore.is_time_dependent","text":"is_time_dependent(h::Hamiltonian)\n\nCheck if a hamiltonian is time-dependent.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T<:Integer","page":"References","title":"EaRydCore.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.mean_rydberg","page":"References","title":"EaRydCore.mean_rydberg","text":"mean_rydberg([f], reg_or_samples)\n\nMean size of vertex set.\n\nArguments\n\nf: optional, postprocessing callback function f(config) -> config.   The input config is an integer of type Int, the output   config can be a type supports count_vertices   e.g, an AbstractVector or an Integer.\nreg_or_samples can be a register (Yao.ArrayReg or RydbergReg)   or a list of measurement result (config) in AbstractVector.\n\nExample\n\nTo implement the postprocessing protocal in MIS experiment:\n\ncalculating mean_rydberg by first reducing the configuration\n\nto independent set using to_independent_set\n\nrandomly adding vertices then pick the largest count_vertices\n\nusing add_random_vertices.\n\nmean_rydberg(r) do config\n    config = to_independent_set(config, graph)\n    add_random_vertices(config, graph, 10)\n    return config\nend\n\nOr one can also just add vertice by atom order\n\nmean_rydberg(r) do config\n    config = to_independent_set(config, graph)\n    add_vertices!(config, graph)\n    return config\nend\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}","page":"References","title":"EaRydCore.mis_postprocessing","text":"mis_postprocessing(config, graph::AbstractGraph; ntrials::Int=10)\n\nThe postprocessing protocal used in Harvard.\n\nArguments\n\nconfig: configuration to postprocess.\ngraph: the problem graph.\n\nKeyword Arguments\n\nntrials: number of trials to use.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.mis_postprocessing-Tuple{Graphs.AbstractGraph}","page":"References","title":"EaRydCore.mis_postprocessing","text":"mis_postprocessing(graph::AbstractGraph; ntrials::Int = 10)\n\nCurried version of mis_postprocessing.\n\nExample\n\nto calculate mean_rydberg loss with postprocessing used in Harvard experiment.\n\nmean_rydberg(mis_postprocessing(graph), reg)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.nsites","page":"References","title":"EaRydCore.nsites","text":"nsites(term)\n\nReturn the number of sites of given Hamiltonian term.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}","page":"References","title":"EaRydCore.num_mis_violation","text":"num_mis_violation(config, graph::AbstractGraph, i::Int)\n\nCalculate the number of MIS violations for i-th vertex in graph and configuration config. The config should be a subtype of AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.rand_atoms-Tuple{Int64, Float64}","page":"References","title":"EaRydCore.rand_atoms","text":"rand_atoms(n::Int, ρ::Float64; ndims::Int=2)\n\nCreate a random atom position of n atoms and with density ρ in ndims space. The size of the box is L^ndims, where the linear dimension L = (nρ)^(1ndims).\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.rand_unit_disk_graph-Tuple{Int64, Real}","page":"References","title":"EaRydCore.rand_unit_disk_graph","text":"rand_unit_disk_graph(natoms::Int, ρ::Real)\n\nGenerate a random disk graph.\n\nρ is defined as n/L^2, where L is the box size.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.read_atoms-Tuple{String, Vararg{Any}}","page":"References","title":"EaRydCore.read_atoms","text":"read_atoms(filename[, T=Int])\n\nRead atom positions from file filename.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.read_atoms-Union{Tuple{T}, Tuple{IO, Type{T}}} where T","page":"References","title":"EaRydCore.read_atoms","text":"read_atoms(io::IO[, T=Int])\n\nRead atom positions from stream io.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.read_subspace-Tuple{AbstractString}","page":"References","title":"EaRydCore.read_subspace","text":"read_subspace(filename::AbstractString)\n\nRead Subspace from a file filename.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.read_subspace-Tuple{IO}","page":"References","title":"EaRydCore.read_subspace","text":"read_subspace(io::IO)\n\nRead Subspace from given io.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.rydatoms-Tuple{AbstractMatrix}","page":"References","title":"EaRydCore.rydatoms","text":"rydatoms(::AbstractMatrix)\n\nCreate a list of RydAtoms from a nx2 location matrix.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.rydberg_h-Tuple{Any}","page":"References","title":"EaRydCore.rydberg_h","text":"rydberg_h(atoms; [C=2π * 858386 * MHz*µm^6], Ω[, ϕ, Δ])\n\nCreate a rydberg hamiltonian\n\n fracCr_i - r_j^6 n_i n_j + fracΩ2 σ_x - Δ σ_n\n\nshorthand for\n\nRydInteract(C, atoms) + XTerm(length(atoms), Ω, ϕ) + ZTerm(length(atoms), Δ)\n\nArguments\n\natoms: a collection of atom positions\n\nKeyword Arguments\n\nC: optional, default unit is MHz*µm^6, interation parameter,   see also RydInteract.\nΩ: required, default unit is MHz, Rabi frequencies, see XTerm.\nΔ: optional, default unit is MHz, detuning parameter, see NTerm.\nϕ: optional, does not have unit, the phase, see XTerm.\n\ntips: Tips\nThe parameters of Hamiltonian have their own default units to match hardware, one can use Unitful.jl to specify their units explicitly. If the units are specified explicitly, they will be converted to default units automatically.\n\nExample\n\njulia> using EaRyd\n\njulia> atoms = generate_sites(SquareLattice(), 3, 3);\n\njulia> rydberg_h(atoms; Δ=1.2, Ω=1.1)\nHamiltonian\n  Term 1\n   ∑(n=1:9) 1.1/2 σ^x\n\n  Term 2\n   -∑(n=1:9) 1.2 n\n\n  Term 3\n   ∑(n=1:9) 686.0/|r_i - r_j|^6 n_i n_j\n\njulia> rydberg_h(atoms; Δ=1.2, Ω=1.1, ϕ=2.1)\nHamiltonian\n  Term 1\n   ∑(n=1:9) 1.1/2 (e^{2.1i}|0)⟨1| + e^{-2.1i}|1⟩⟨0|)\n\n  Term 2\n   -∑(n=1:9) 1.2 n\n\n  Term 3\n   ∑(n=1:9) 686.0/|r_i - r_j|^6 n_i n_j\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.set_zero_state!","page":"References","title":"EaRydCore.set_zero_state!","text":"set_zero_state!(register)\n\nSet the given register to |00...00⟩.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.simple_rydberg-Tuple{Int64, Number}","page":"References","title":"EaRydCore.simple_rydberg","text":"simple_rydberg(n::Int, ϕ::Number)\n\nCreate a simple rydberg hamiltonian that has only XTerm.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.sort_atoms!-Tuple{Vector{<:RydAtom}}","page":"References","title":"EaRydCore.sort_atoms!","text":"sort_atoms!(atoms; by=nothing)\n\nSort a list of atom positions. Sort by coordinates if by is nothing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.square_lattice-Tuple{Int64, Float64}","page":"References","title":"EaRydCore.square_lattice","text":"square_lattice(n::Int, ff::Float64)\n\nCreate a list of Rydberg atoms on a square lattice with given size n and filling factor ff.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.term_value","page":"References","title":"EaRydCore.term_value","text":"term_value(term, lhs, rhs, col, row)\n\nReturn the value of given term at H[col, row] with left basis lhs and right basis rhs. For full space, lhs = col - 1 and rhs = row - 1, for subspace, lhs = subspace_v[col] and rhs = subspace_v[row].\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}","page":"References","title":"EaRydCore.to_independent_set!","text":"to_independent_set!(config::AbstractVector, graph::AbstractGraph)\n\nEliminate vertices in config so that remaining vertices do not have connected edges. This algorithm is a naive vertex elimination that does not nesesarily give the maximum possible vertex set.\n\n# run the following code in Atom/VSCode\natoms = RydAtom.([(0.0, 1.0), (1.0, 0.), (2.0, 0.0),\n    (1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\ngraph = unit_disk_graph(atoms, 1.5)\n\nconfig = [1, 1, 1, 0, 1, 1]\nviz_config(atoms, graph, config)\n\nto_independent_set!(config, graph)\nviz_config(atoms, graph, config)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.trotterize-Tuple{Real, Real, EaRydCore.AbstractTerm}","page":"References","title":"EaRydCore.trotterize","text":"trotterize([start::Real=0], stop::Real, h::AbstractTerm; nsteps::Int=1000)\n\nTrotterize time evolution of hamiltonian h. Each trotterize step uses the first value of the interval as the clock to get h(t), e.g when start time is 0.1 and stop time is 0.5 with 1000 steps, the first value of h will be h(0.1), then h(0.1 + dt) and so on.\n\nArguments\n\nstart: start time, a real number, default is zero.\nstop: stop time, a real number.\nh: the hamiltonian expression.\n\nKeyword Arguments\n\nnsteps: number of steps in the evolution.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.unit_disk_graph","page":"References","title":"EaRydCore.unit_disk_graph","text":"unit_disk_graph(atoms::AbstractVector{<:RydAtom}, radius=1)\n\nCreate a unit disk graph from atom positions atoms. It returns a Graphs.SimpleGraph instance.\n\natoms is vector of atoms positions.\nradius is the unit in the unit disk graph definition.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.update_term!","page":"References","title":"EaRydCore.update_term!","text":"update_term!(H, term[, space=fullspace])\n\nUpdate matrix H based on the given Hamiltonian term. This can be faster when the sparse structure of H is known (e.g H is a SparseMatrixCSC).\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydCore.write_atoms-Tuple{IO, AbstractVector{<:RydAtom}}","page":"References","title":"EaRydCore.write_atoms","text":"write_atoms(io::IO, atoms::AbstractVector{<:RydAtom})\n\nWrite a list of atom positions to stream io.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.write_atoms-Tuple{String, AbstractVector{<:RydAtom}}","page":"References","title":"EaRydCore.write_atoms","text":"write_atoms(filename::String, atoms::AbstractVector{<:RydAtom})\n\nWrite a list of atom positions to the file given by filename.\n\nExample\n\nThis saves the atom position generated from square_lattice to a file demo.atoms.\n\natoms = square_lattice(5, 0.8)\nwrite_atoms(\"demo.atoms\", atoms)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.write_subspace-Tuple{AbstractString, Subspace}","page":"References","title":"EaRydCore.write_subspace","text":"write_subspace(filename::AbstractString, s::Subspace)\n\nWrite Subspace to filename as human readable format.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydCore.write_subspace-Tuple{IO, Subspace}","page":"References","title":"EaRydCore.write_subspace","text":"write_subspace(io::IO, s::Subspace)\n\nWrite Subspace object s to IO as human readable format.\n\n\n\n\n\n","category":"method"},{"location":"ref/#YaoArrayRegister.zero_state","page":"References","title":"YaoArrayRegister.zero_state","text":"zero_state([T=ComplexF64], n::Int, subspace[, layout=ComplexLayout()])\n\nCreate a RydbergReg in zero state in given subspace.\n\nArguments\n\nT: optional, element type, default is ComplexF64.\nn: required, number of atoms (qubits).\nsubspace: required, the subspace of rydberg state.\nlayout: optional, memory layout, default is ComplexLayout.\n\nMemory Layout\n\nWhen the hamiltonian is a real hermitian, it can be more efficient to use the RealLayout over ComplexLayout which stores the complex -value state vector as as length(state)×2 matrix, the first column is the real component and the second column is the imaginary component.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydODE","page":"References","title":"EaRydODE","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [EaRydODE]","category":"page"},{"location":"ref/#EaRydODE.ODEEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Real, EaRydCore.AbstractTerm}} where P","page":"References","title":"EaRydODE.ODEEvolution","text":"ODEEvolution{P}(r::AbstractRegister, t::Real, h::AbstractTerm; kw...)\n\nRun the evolution for t μs, start from clock 0 μs, shorthand for\n\nODEEvolution{P}(r, (0, t), h; kw...)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydODE.ODEEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Tuple{Real, Real}, EaRydCore.AbstractTerm}} where P","page":"References","title":"EaRydODE.ODEEvolution","text":"ODEEvolution{P}(r::AbstractRegister, (start, stop), h::AbstractTerm; kw...) where {P <: AbstractFloat}\n\nCreate a ODEEvolution that defines the evolution of a hamiltonian h with time dependent parameters to evolve from start to stop using an ODE solver.\n\nArguments\n\nP: optional, a type parameter that sets the problem precision type, default is   the same as the Yao.datatype of given register.\nregister: required, the evolution problem register, can be a RydbergReg or an ArrayReg   from Yao.\n(start, stop): required, the evolution interval.\nh: required, the evolution hamiltonian.\n\nKeyword Arguments\n\nalgo: algorithm to use, default is Vern8, check DiffEq documentation for more details.\nprogress: print progress bar or not, this may effect the performance when problem scale is small, default is true.\nprogress_steps: steps to update the progress bar, default is 5.\nreltol: relative tolerance, default is 1e-8.\nabstol: absolute tolerance, default is 1e-8.\nnormalize_steps: steps to run normalization on the state, default is 5.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms","page":"References","title":"EaRydWaveforms","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [EaRydWaveforms]","category":"page"},{"location":"ref/#EaRydWaveforms.Waveform","page":"References","title":"EaRydWaveforms.Waveform","text":"Waveform{F, T <: Real}\n\nType for waveforms. Waveforms are defined as a function combiend with a real number duration.\n\nFields\n\nf: a callable object.\nduration: a real number defines the duration of this waveform.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydWaveforms.Waveform-Tuple{Any}","page":"References","title":"EaRydWaveforms.Waveform","text":"Waveform(f; duration::Real)\n\nCreate a Waveform object from callable f, the unit of duration is μs.\n\nExample\n\njulia> Waveform(duration=1.5) do t\n    2t+1\nend\n           ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n           ┌────────────────────────────────────────┐ \n         4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \nvalue (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         1 │⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           └────────────────────────────────────────┘ \n           ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.append-Tuple{Waveform, Vararg{Waveform}}","page":"References","title":"EaRydWaveforms.append","text":"append(wf::Waveform, wfs::Waveform...)\n\nAppend other waveforms to wf on time axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.constant-Tuple{}","page":"References","title":"EaRydWaveforms.constant","text":"constant(;duration::Real, value::Real)\n\nCreate a constant waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nvalue::Real: value of the constant waveform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.linear_ramp-Tuple{}","page":"References","title":"EaRydWaveforms.linear_ramp","text":"linear_ramp(;duration, start_value, stop_value)\n\nCreate a linear ramp waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nstart_value::Real: start value of the linear ramp.\nstop_value::Real: stop value of the linear ramp.\n\nExample\n\njulia> linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                1 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀3⠀ \n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.piecewise_constant-Tuple{}","page":"References","title":"EaRydWaveforms.piecewise_constant","text":"piecewise_constant(;clocks, values, duration=last(clocks))\n\nCreate a piecewise constant waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\nduration::Real: the duration of the entire waveform, default is the last clock.\n\nExample\n\njulia> piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1], duration=1.1)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢠⠒⠒⠒⠒⠒⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⣀⣀⣀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ \n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.piecewise_linear-Tuple{}","page":"References","title":"EaRydWaveforms.piecewise_linear","text":"piecewise_linear(;clocks, values)\n\nCreate a piecewise linear waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\n\nExample\n\njulia> piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 2.0, 2.0, 0.0])\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀│ \n                  │⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀│ \n                  │⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀│ \n                  │⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆│ \n                0 │⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀ \n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.sinusoidal-Tuple{}","page":"References","title":"EaRydWaveforms.sinusoidal","text":"sinusoidal(;duration::Real, amplitude::Real=one(start))\n\nCreate a sinusoidal waveform of the following expression.\n\namplitude * sin(t)\n\nKeyword Arguments\n\nduration: duration of the waveform.\namplitude: amplitude of the sin waveform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydWaveforms.smooth","page":"References","title":"EaRydWaveforms.smooth","text":"smooth([kernel=Kernel.gaussian], f; edge_pad_size::Int=length(f.clocks))\n\nKernel smoother function for piece-wise linear function/waveform via weighted moving average method.\n\nArguments\n\nkernel: the kernel function, default is Kernels.gaussian.\nf: a PiecewiseLinear function or a Waveform{<:PiecewiseLinear}.\n\nKeyword Arguments\n\nkernel_radius: radius of the kernel.\nedge_pad_size: the size of edge padding.\n\n\n\n\n\n","category":"function"},{"location":"ref/#EaRydWaveforms.smooth-Tuple{Any, Vector, Vector, Real}","page":"References","title":"EaRydWaveforms.smooth","text":"smooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)\n\nKernel smoother function via weighted moving average method. See also Kernel Smoother.\n\nTheory\n\nKernel function smoothing is a technique to define a smooth function f mathcalR^p  mathbfR from a set of discrete points by weighted averaging the neighboring points. It can be written as the following equation.\n\nY(X) = sum_i K(X X_i) Y_i  sum_i K(X X_i)\n\nwhere Y(X) is the smooth function by calculating the moving average of known data points X_i and Y_i. K is the kernel function, where K(fracX - X_ih_λ) decrease when the Euclidean norm X - X_i increase, h_λ is a parameter controls the radius of the kernel.\n\nAvailable Kernels\n\nThe following kernel functions are available via the Kernels module:\n\nbiweight; cosine; gaussian; include; logistic; parabolic; sigmoid; triangle; tricube; triweight; uniform\n\nArguments\n\nkernel: a Julia function that has method kernel(t::Real).\nXi::Vector: a list of inputs X_i.\nYi::Vector: a list of outputs Y_i.\nkernel_radius::Real: the radius of the kernel.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices","page":"References","title":"EaRydLattices","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [EaRydLattices]","category":"page"},{"location":"ref/#EaRydLattices.AtomList","page":"References","title":"EaRydLattices.AtomList","text":"AtomList{D, T} <: AbstractVector{NTuple{D, T}}\nAtomList(atoms::Vector{<:NTuple})\n\nA list of atoms in D dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.ChainLattice","page":"References","title":"EaRydLattices.ChainLattice","text":"EaRydLattices.ChainLattice <: AbstractLattice{1}\nEaRydLattices.ChainLattice()\n\nEaRydLattices.ChainLattice is a 1 dimensional lattice with:\n\nLattice vectors = ((1.0,),)\nLattice sites   = ((0.0,),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.DistanceGroup","page":"References","title":"EaRydLattices.DistanceGroup","text":"DistanceGroup\n\nThe vertices grouped by distances. One can use distancegroup[n] to get n-th nearest neighbors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.GeneralLattice","page":"References","title":"EaRydLattices.GeneralLattice","text":"GeneralLattice{D,K,T} <: AbstractLattice{D}\nGeneralLattice(vectors, sites)\n\nThe general lattice type for tiling the space. Type parameter D is the dimension, K is the number of sites in a unit cell and T is the data type for coordinates, e.g. Float64. Input arguments are\n\nvectors is a vector/tuple of D-tuple. Its length is D, it specifies the Bravais lattice vectors.\nsites is a vector/tuple of D-tuple. Its length is K, it specifies the sites inside a Bravais cell.\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.HoneycombLattice","page":"References","title":"EaRydLattices.HoneycombLattice","text":"EaRydLattices.HoneycombLattice <: AbstractLattice{2}\nEaRydLattices.HoneycombLattice()\n\nEaRydLattices.HoneycombLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.5, 0.2886751345948129))\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.KagomeLattice","page":"References","title":"EaRydLattices.KagomeLattice","text":"EaRydLattices.KagomeLattice <: AbstractLattice{2}\nEaRydLattices.KagomeLattice()\n\nEaRydLattices.KagomeLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.25, 0.4330127018922193), (0.75, 0.4330127018922193))\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.LiebLattice","page":"References","title":"EaRydLattices.LiebLattice","text":"EaRydLattices.LiebLattice <: AbstractLattice{2}\nEaRydLattices.LiebLattice()\n\nEaRydLattices.LiebLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0), (0.5, 0.0), (0.0, 0.5))\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.MaskedGrid","page":"References","title":"EaRydLattices.MaskedGrid","text":"MaskedGrid{T}\nMaskedGrid(xs, ys, mask)\n\nMasked square lattice contains 3 fields, the x-coordinates, y-coordinates and a mask. e.g. MaskedGrid([0.0, 1.0, 3.0], [0.0, 2.0,6.0], Bool[1 0 0; 0 1 1; 0 1 0]) specifies the following lattice:\n\n     y₁   y₂        y₃\n     ↓    ↓         ↓\nx₁ → ●    ⋅         ●\nx₂ → ⋅    ●         ●\n\nx₃ → ⋅    ●         ⋅\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.SquareLattice","page":"References","title":"EaRydLattices.SquareLattice","text":"EaRydLattices.SquareLattice <: AbstractLattice{2}\nEaRydLattices.SquareLattice()\n\nEaRydLattices.SquareLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.TriangularLattice","page":"References","title":"EaRydLattices.TriangularLattice","text":"EaRydLattices.TriangularLattice <: AbstractLattice{2}\nEaRydLattices.TriangularLattice()\n\nEaRydLattices.TriangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#EaRydLattices.clip_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{Tuple{T, T}, D}}} where {D, T}","page":"References","title":"EaRydLattices.clip_axes","text":"clip_axes(sites::AtomList{D, T}, bounds::Vararg{Tuple{T,T},D}) where {D, T}\nclip_axes(bounds...)\n\nRemove sites out of bounds, where bounds is specified by D D-tuples.\n\njulia> sites = [(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)]\n4-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> clip_axes(sites, (-5.0, 5.0), (-5.0, 5.0))\n2-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (3.0, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.collect_atoms-Tuple{MaskedGrid}","page":"References","title":"EaRydLattices.collect_atoms","text":"collect_atoms(maskedgrid::MaskedGrid)\n\nReturns an list of atoms in the maskedgrid in order.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.dimension-Union{Tuple{AbstractLattice{D}}, Tuple{D}} where D","page":"References","title":"EaRydLattices.dimension","text":"dimension(lattice)\n\nReturns the space dimension of target lattice. e.g. ChainLattice is a 1D lattice, hence returns 1.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D","page":"References","title":"EaRydLattices.generate_sites","text":"generate_sites(lattice::AbstractLattice{D}, repeats::Vararg{Int,D}; scale=1.0)\n\nReturns an AtomList instance by tiling the specified lattice. The tiling repeat the sites of the lattice m times along the first dimension, n times along the second dimension, and so on. scale is a real number that re-scales the lattice constant and atom locations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.grouped_nearest-Tuple{NearestNeighbors.KDTree, Int64, Int64}","page":"References","title":"EaRydLattices.grouped_nearest","text":"grouped_nearest(tree::KDTree, siteindex::Int, nsites::Int; atol=1e-8)\n\nFind the nsites closest vertices to siteindex, and group them by distance. Difference of the distances smaller than the atol (default is 1e-8) are treated as the same Returns a DistanceGroup instance.\n\njulia> atoms = generate_sites(HoneycombLattice(), 5, 5);\n\njulia> tree = make_kdtree(atoms)\nNearestNeighbors.KDTree{StaticArrays.SVector{2, Float64}, Distances.Euclidean, Float64}\n  Number of points: 50\n  Dimensions: 2\n  Metric: Distances.Euclidean(0.0)\n  Reordered: true\n\njulia> gn = grouped_nearest(tree, 23, 20)\nDistanceGroup([23, 14, 22, 24, 15, 13, 21, 25, 33, 31, 12, 16, 32, 4, 6, 34, 26, 17, 5, 41], [1, 2, 5, 11, 14, 18, 21])\n\njulia> gn[0]  # the 0-th nearest neighbor is defined by vertex itself\n1-element Vector{Int64}:\n 23\n\njulia> gn[1]  # nearest neighbors\n3-element Vector{Int64}:\n 14\n 22\n 24\n\njulia> gn[2]  # second nearest neighbors\n6-element Vector{Int64}:\n 15\n 13\n 21\n 25\n 33\n 31\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.img_atoms-Tuple{AtomList}","page":"References","title":"EaRydLattices.img_atoms","text":"img_atoms(atoms::AtomList;\n    colors=[\"black\", \"black\", ...], blockade_radius=0,\n    texts=[\"1\", \"2\", ...],\n    blockade_radius=0;\n    format=PNG,\n    blockade_style=\"none\",\n    bond_color=\"black\",\n    )\n\nPlots atoms with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> open(\"test.png\", \"w\") do f\n            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))\n       end\n\nThe format keyword argument can also be Compose.SVG or Compose.PDF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.img_maskedgrid-Tuple{MaskedGrid}","page":"References","title":"EaRydLattices.img_maskedgrid","text":"img_maskedgrid([io::Union{IO,AbstractString}, ]maskedgrid::MaskedGrid;\n    format=PNG,\n    blockade_radius = blockade_radius,\n    colors=fill(\"white\", count(maskedgrid.mask)))\n\nDraw a maskedgrid with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.lattice_sites-Tuple{GeneralLattice}","page":"References","title":"EaRydLattices.lattice_sites","text":"lattice_sites(lattice::AbstractLattice)\n\nReturns sites in a Bravais lattice unit cell as a Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.lattice_vectors-Tuple{GeneralLattice}","page":"References","title":"EaRydLattices.lattice_vectors","text":"lattice_vectors(lattice::AbstractLattice)\n\nReturns Bravais lattice vectors as a D-Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.make_grid-Union{Tuple{AtomList{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"References","title":"EaRydLattices.make_grid","text":"make_grid(sites::AtomList; atol=...)\n\nCreate a MaskedGrid from the sites. It is required by lattice preparation of Rydberg array. Because the grid will sort the sites by rows, we need atol (default value is 10 time sit data precision) determines up to what level of round off error, two atoms belong to the same row.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.make_kdtree-Union{Tuple{AtomList{D, T}}, Tuple{D}, Tuple{T}} where {T, D}","page":"References","title":"EaRydLattices.make_kdtree","text":"make_kdtree(atoms::AtomList{D,T}) where {T, D}\n\nReturns a KDTree instance from input atoms.\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.offset_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{T, D}}} where {D, T}","page":"References","title":"EaRydLattices.offset_axes","text":"offset_axes(sites::AtomList{D, T}, offsets::Vararg{T,D}) where {D, T}\noffset_axes(offsets...)\n\nOffset the sites by distance specified by offsets.\n\njulia> sites = [(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)]\n4-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> offset_axes(sites, 1.0, 3.0)\n4-element Vector{Tuple{Float64, Float64}}:\n (2.0, 5.0)\n (11.0, 6.0)\n (2.0, 15.0)\n (4.0, 8.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.random_dropout-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"References","title":"EaRydLattices.random_dropout","text":"random_dropout(sites::AtomList{D, T}, ratio::Real) where {D, T}\nrandom_dropout(ratio)\n\nRandomly drop out ratio * number of sites atoms from sites, where ratio ∈ [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydLattices.rescale_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"References","title":"EaRydLattices.rescale_axes","text":"rescale_axes(sites::AtomList{D, T}, scale::Real) where {D, T}\nrescale_axes(scale)\n\nRescale the sites by a constant scale.\n\njulia> sites = [(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)]\n4-element Vector{Tuple{Float64, Float64}}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> rescale_axes(sites, 2.0)\n4-element Vector{Tuple{Float64, Float64}}:\n (2.0, 4.0)\n (20.0, 6.0)\n (2.0, 24.0)\n (6.0, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#EaRydPlots","page":"References","title":"EaRydPlots","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [EaRydPlots]","category":"page"},{"location":"ref/#EaRydPlots.bitstring_histgram-Tuple{Any}","page":"References","title":"EaRydPlots.bitstring_histgram","text":"\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EaRyd","category":"page"},{"location":"#EaRyd","page":"Home","title":"EaRyd","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Coverage Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the QuEra Emulator for Rydberg System documentation page!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nEaRyd is a &nbsp;\n    <a href=\"https://julialang.org\">\n        <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">\n        Julia Language\n    </a>\n    &nbsp; package. To install EaRyd,\n    please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open\n    Julia's interactive session (known as REPL)</a> and press <kbd>]</kbd> key in the REPL to use the package mode, then type the following command\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"First add the QuEra Julia registry via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> registry add https://github.com/Happy-Diode/Miskatonic.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"For stable release","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add EaRyd","category":"page"},{"location":"","page":"Home","title":"Home","text":"For current master","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add EaRyd#master","category":"page"},{"location":"#Rydberg-System","page":"Home","title":"Rydberg System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our Rydberg Emulator simulate the following interacting Rydberg Hamiltonian, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracmathcalHhbar = sum_i fracOmega_i2 sigma_x^i - sum_i Delta_i n_i + sum_i  j V_ij n_i n_j","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here Delta_i are the detunings of the driving lasers from the Rydberg state;  sigma_x^i = g_irangle langle r_i + r_irangle langle g_i describes the coupling between the ground state g_irangle and the Rydberg state r_irangle of an atom at position i, driven at Rabi frequencey Omega_i;  n_i = r_irangle langle r_i, and V_ij = Cr_ij^6 is the interactions between atom i and j, where C is the interacting constant that depends on particular Rydberg atoms, and hbar is the reduced Plank's constant. ","category":"page"},{"location":"#Run-a-Simple-Emulation-of-Rydberg-System","page":"Home","title":"Run a Simple Emulation of Rydberg System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we will show a simple example about simulating quantum many-body dynamics governed by such a Hamiltonian. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start by loading the Emulator Module","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EaRyd","category":"page"},{"location":"","page":"Home","title":"Home","text":"As one can see from the Rydberg Hamiltonian, the interactions between Rydberg atoms depend on their positions. EaRyd provides several built-in lattice structures for specifying the atom positions. For instance, we can use the following codes to quickly generate a chain of 10 atoms in 1D ","category":"page"},{"location":"","page":"Home","title":"Home","text":"nsites = 10;\natoms = generate_sites(ChainLattice(), nsites, scale=5.72)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have set the distance between nearest neighbor atoms to be 5.72 mu m. Note that the default unit of length in EaRyd is mu m. Correspondingly, the default value for interacting constant C is 2π * 858386 MHz times mu m^6 for Rydberg atom ^87Rb and 70 s Rydberg state. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will set both Omega and Delta to be a constant. The default energy unit (also for Omega and Delta) is MHz in EaRyd. Since all the parameters specified, we can create a interacting Rydberg Hamiltonian by using rydberg_h, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = rydberg_h(atoms;C = 2π * 858386, Ω=4π, Δ=0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use the following code to create an initial state with all the atoms in the ground state by using zero_state","category":"page"},{"location":"","page":"Home","title":"Home","text":"init = zero_state(10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are interested in calculating the quench dynamics of Rydberg system starting with the above initial state and under the evolution of the defined Hamiltonian. Suppose we only want to get observable expectation values at the final time step, we can first create the problem and then directly emulate the problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob = ODEEvolution(init, 1.6, h)\nemulate!(prob)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we have choosen the ODE solver ODEEvolution and set the total evolution time to be 1.6 mu s (the default unit for time is mu s in EaRyd). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"After emulating the problem, we can measure the Rydberg density at each site for the final state ","category":"page"},{"location":"","page":"Home","title":"Home","text":"densities = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob.reg is the register storing the final state after the time-evolution. ","category":"page"},{"location":"#Looking-for-Help?","page":"Home","title":"Looking for Help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"check the slack channel #julia\nif not urgent, ask questions in discussions","category":"page"},{"location":"#Have-Suggestions-or-Interested-in-Contribution?","page":"Home","title":"Have Suggestions or Interested in Contribution?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"check the slack channel #q-emulator for meetings and discussions\nfile an issue to report a bug or request a feature","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"EditURL = \"https://github.com/Happy-Diode/EaRyd.jl/blob/master/examples/noise/main.jl\"","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"using EaRyd\nusing CairoMakie\nusing EaRydPlots","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"In this example, we examine the adiabatic preparation of a spin Hamiltonian with noise parameters to show the erro propagation feature.","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"We first prepare the adiabatic pulse sequence as two piecewise linear functions the first part considers Hamiltonian parameters with time-dependent global noise (where each atom site is subject to the same noise)","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"define the rabi waveform","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"Ω_src = 2.3 * 2 * pi","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"14.451326206513047","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"the noise strength can be specified by \\pm","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"Ω_max = Ω_src ± 0.001\nΩ = piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[0.0, Ω_max , Ω_max , 0])","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n               20 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⢰⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ ","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"define the noisy detuning waveform","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"U = Ω_src / 2.3 ± 0.001\nΔ = piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[-6*U, -6*U, 2*U , 2*U])","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n               20 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢉⡟⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n              -40 │⠒⠒⠒⠒⠒⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ ","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"We prepare a square lattice of 9 atoms create the atom positions","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"nx, ny = 3, 3\nnsites = nx*ny\n\natoms = generate_sites(SquareLattice(), nx, ny, scale=9.629)","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n     version=\"1.2\"\n     width=\"120mm\" height=\"120mm\" viewBox=\"0 0 120 120\"\n     stroke=\"none\"\n     fill=\"#000000\"\n     stroke-width=\"0.3\"\n     font-size=\"3.88\"\n>\n<defs>\n  <marker id=\"arrow\" markerWidth=\"15\" markerHeight=\"7\" refX=\"5\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n    <path d=\"M0,0 L15,3.5 L0,7 z\" stroke=\"context-stroke\" fill=\"context-stroke\"/>\n  </marker>\n</defs>\n<g fill=\"#000000\" font-size=\"3.53\" id=\"img-a79c5056-1\">\n  <g transform=\"translate(35,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(47.5,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4.81μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9.63μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(72.5,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">14.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,99)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">19.26μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">0.0μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,72.5)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4.81μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9.63μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,47.5)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">14.44μm</text>\n    </g>\n  </g>\n  <g transform=\"translate(17.5,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">19.26μm</text>\n    </g>\n  </g>\n</g>\n<g stroke-width=\"1.2\" fill=\"#FFFFFF\" stroke=\"#000000\" id=\"img-a79c5056-2\">\n  <g transform=\"translate(35,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,85)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(35,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,60)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(35,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <circle cx=\"0\" cy=\"0\" r=\"6\" class=\"primitive\"/>\n  </g>\n</g>\n<g fill=\"#000000\" font-size=\"5.64\" id=\"img-a79c5056-3\">\n  <g transform=\"translate(35,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">1</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">2</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,85)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">3</text>\n    </g>\n  </g>\n  <g transform=\"translate(35,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">4</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">5</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,60)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">6</text>\n    </g>\n  </g>\n  <g transform=\"translate(35,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">7</text>\n    </g>\n  </g>\n  <g transform=\"translate(60,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">8</text>\n    </g>\n  </g>\n  <g transform=\"translate(85,35)\">\n    <g class=\"primitive\">\n      <text text-anchor=\"middle\" dy=\"0.35em\">9</text>\n    </g>\n  </g>\n</g>\n</svg>\n","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"We construct the Rydberg Hamiltonian from the defined noisy rabi and detuning waveforms","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"h = rydberg_h(atoms; C=2 * pi * 858386, Δ, Ω)\n\nusing SparseArrays","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"We evolve the system from the zero state using the ODE solver to a final time t = 1.6 microseconds","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"prob = ODEEvolution(zero_state(9), 1.6±0.0, h)\nemulate!(prob) # run the time evolution directly","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"ODEEvolution{Measurement{Float64}}:\n  reg: ArrayReg{1, Complex{Measurement{Float64}}, Matrix{Complex{Measurement{Float64}}}}\n  reg storage: 32.000 KiB\n\n  timespan: (0.0 ± 0.0, 1.6 ± 0.0)\n  equation: \n    Schrödinger Equation:\n      Storage Size: 213.969 KiB\n      State Storage: Vector{Complex{Measurement{Float64}}}\n      Hamiltonian Storage: SparseArrays.SparseMatrixCSC{Measurement{Float64}, Int32}\n      Hamiltonian\n        Term 1\n         ∑(n=1:9) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n        Term 2\n         ∑(n=1:9) Waveform(_, 1.6)(t)/2 σ^x\n\n        Term 3\n         -∑(n=1:9) Waveform(_, 1.6)(t) n\n\n  options: \n    algo: Vern8(true)\n    progress: false\n    progress_steps: 5\n    progress_name: \"ODE\"\n    reltol: 1.0e-8\n    abstol: 1.0e-8\n    normalize_steps: 5\n    normalize_finally: true","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"We compute the Rydberg probability for each site, where each of the results contains an error bar","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"densities = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"9-element Vector{Measurement{Float64}}:\n 0.806538 ± 2.5e-5\n 0.422305 ± 5.5e-5\n 0.806538 ± 2.5e-5\n 0.422305 ± 5.5e-5\n 0.440222 ± 5.5e-5\n 0.422305 ± 5.5e-5\n 0.806538 ± 2.5e-5\n 0.422305 ± 5.5e-5\n 0.806538 ± 2.5e-5","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"the second part considers Hamiltonian parameters with time-dependent local noise (where each atom site is subject to independent noise)","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"each atom is subject to an indenpendent noise","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"Ω = map(1:9) do idx\n    piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[0.0, Ω_max, Ω_max , 0])\nend\n\nΔ = map(1:9) do idx\n    piecewise_linear(clocks=[0.0, 0.252, 1.052, 1.6], values=[-6*U, -6*U, 2*U , 2*U])\nend","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"9-element Vector{Waveform{EaRydWaveforms.PiecewiseLinear{Measurement{Float64}, Interpolations.Extrapolation{Measurement{Float64}, 1, Interpolations.GriddedInterpolation{Measurement{Float64}, 1, Measurement{Float64}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Float64}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Throw{Nothing}}}, Float64}}:\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)\n Waveform(_, 1.6)","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"define the Hamiltonian","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"h = rydberg_h(atoms; C=2 * pi * 858386, Δ, Ω)\nprob = ODEEvolution(zero_state(9), 1.6±0.0, h)\nemulate!(prob) # run the time evolution directly","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"ODEEvolution{Measurement{Float64}}:\n  reg: ArrayReg{1, Complex{Measurement{Float64}}, Matrix{Complex{Measurement{Float64}}}}\n  reg storage: 32.000 KiB\n\n  timespan: (0.0 ± 0.0, 1.6 ± 0.0)\n  equation: \n    Schrödinger Equation:\n      Storage Size: 213.969 KiB\n      State Storage: Vector{Complex{Measurement{Float64}}}\n      Hamiltonian Storage: SparseArrays.SparseMatrixCSC{Measurement{Float64}, Int32}\n      Hamiltonian\n        Term 1\n         ∑(n=1:9) 5.39e6/|r_i - r_j|^6 n_i n_j\n\n        Term 2\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x +\n         Waveform(_, 1.6)(t)/2 σ^x\n\n        Term 3\n         -∑(n=1:9) Waveform{EaRydWaveforms.PiecewiseLinear{Measurement{Float64}, Interpolations.Extrapolation{Measurement{Float64}, 1, Interpolations.GriddedInterpolation{Measurement{Float64}, 1, Measurement{Float64}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Float64}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Throw{Nothing}}}, Float64}[Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6), Waveform(_, 1.6)] n\n\n  options: \n    algo: Vern8(true)\n    progress: false\n    progress_steps: 5\n    progress_name: \"ODE\"\n    reltol: 1.0e-8\n    abstol: 1.0e-8\n    normalize_steps: 5\n    normalize_finally: true","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"measure the Rydberg density for each site","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"densities = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"9-element Vector{Measurement{Float64}}:\n 0.806538 ± 2.5e-5\n 0.422305 ± 5.5e-5\n 0.806538 ± 2.5e-5\n 0.422305 ± 5.5e-5\n 0.440222 ± 5.5e-5\n 0.422305 ± 5.5e-5\n 0.806538 ± 2.5e-5\n 0.422305 ± 5.5e-5\n 0.806538 ± 2.5e-5","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"","category":"page"},{"location":"tutorials/noise/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"julia/#The-Julia-Programming-Language","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"The EaRyd project is built in pure Julia programming language. Thus if you are not familiar with Julia, here is a quick start for basic Julia gramar, and a guide for learning more detailed and advanced Julia.","category":"page"},{"location":"julia/#Why-Julia?","page":"The Julia Programming Language","title":"Why Julia?","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Fast, as you might have heard about it, Julia is very fast, there are various benchmarks online.   It can even be used to write Basic Linear Algebra Subroutine (BLAS) to reach performance on par with   manually optimized assembly with C (check Octavian).\nGeneric, the language itself and its ecosystem are built to be generic, and the compiler can specialize   on generic methods automatically, thus you will find a lot things can be combined easily, and they will   just work, e.g plugin the Measurement number from    Measurement.jl into your ODE solver, you will get error propagation just work, plugin Tropical number into tensor contraction function, you can   solve optimization problems with tensor networks, and so on.\nDifferentiable, the language is differentiable, that means you can calculate the derivatives   using an automatic differentiation engine on the whole language. The current stable AD engine   is powered by Zygote, the next generation AD engine includes   Diffractor (check the video talk on ACM SIGPLAN),   Enzyme.\nExtensible, the language is designed to be compiler friendly, it supports staged programming   as well as compiler plugins. This makes supporting new hardware much easier. As a result, Julia   can support multiple different hardware, such as CUDA,   oneAPI, TPU and so on.\nEasy, with all these features, yet the language itself stays rather easy to learn. Let's go to   the quick start section to skim the syntax.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"info: Info\nMulti-stage programming (MSP) is a variety of metaprogramming in which compilation is divided into a series of intermediate phases, allowing typesafe run-time code generation. Statically defined types are used to verify that dynamically constructed types are valid and do not violate the type system. – Wikipedia","category":"page"},{"location":"julia/#Quick-Start","page":"The Julia Programming Language","title":"Quick Start","text":"","category":"section"},{"location":"julia/#Variables-and-Some-Basic-Types","page":"The Julia Programming Language","title":"Variables and Some Basic Types","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can define a variable similar to how you define it in Python, e.g we can define a x using = (assignment)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"x = 1","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"every variable has a type, you can check it using typeof","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(x)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"By default Julia displays the output of the last operation. (You can suppress the output by adding ; (a semicolon) at the end.)","category":"page"},{"location":"julia/#Functions","page":"The Julia Programming Language","title":"Functions","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can also define short-form, one-line functions using = (assignment) similar to how you write things mathematically.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f(x) = 2x","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Typing the function's name gives information about the function. To call it we must use parentheses:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f\nf(2)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For longer functions we use the following syntax with the function keyword and end:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"function g(x, y)\n\tz = x + y\n\treturn z^2\nend","category":"page"},{"location":"julia/#Control-Flows","page":"The Julia Programming Language","title":"Control Flows","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, there are for, if and while, they look like the following","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s = 0\nfor i in 1:10\n    s += 1\nend","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"we can now check the value of s by typing it again","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Here, 1:10 is a range representing the numbers from 1 to 10:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(1:10)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"the if else statement looks like the following","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if s < 10\n\t# do something\nelseif 10 < s < 13\n\t# do something\nelse\n\t# do something\nend","category":"page"},{"location":"julia/#Matrix-and-Array","page":"The Julia Programming Language","title":"Matrix and Array","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own Array type, if you use Python, it is similar to numpy.array in Python except:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"index starts from 1\nthe multi-dimensional index is column-wise","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"You can also have list comprehension:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[i for i in 1:10]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"it works for multi-dimensional case too:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[(i, j) for i in 1:10, j in 1:5]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"most functions follow the same convention as numpy or MATLAB, e.g you can create a random matrix using:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"rand(5, 5)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if you have question about using a function, you can always type question mark ? in your REPL following the function name","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> ?rand","category":"page"},{"location":"julia/#Package-Manager-and-Environments","page":"The Julia Programming Language","title":"Package Manager & Environments","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own package manager, you can use it as a normal package:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> using Pkg","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"to install a pacakge, you can use","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.add(\"Yao\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"to remove a pacakge, you can use","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.rm(\"Yao\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"All Julia program runs inside an environment, it is the global environment by default. It is usually recommended to run your notebook in a local environment, so we won't hit any version conflicts between different packages. ","category":"page"},{"location":"julia/#Resources","page":"The Julia Programming Language","title":"Resources","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For more resources just check the official website julialang.org/learning","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"<style>\n  iframe {\n    width: 1px;\n    min-width: 100%;\n    min-height: 1000px;\n  }\n</style>\n<iframe id=\"myIframe\" src=\"https://julialang.org/learning/\"></iframe>\n<script>\n  iFrameResize({ log: true }, '#myIframe')\n</script>","category":"page"}]
}
