var documenterSearchIndex = {"docs":
[{"location":"topics/blockade/#Rydberg-Blockade","page":"Rydberg Blockade","title":"Rydberg Blockade","text":"","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"You can copy the following line to your Julia REPL to install latest stable version this package.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add Bloqade","category":"page"},{"location":"install/#Build-System-Image-to-Accelerate-Start-up-Time","page":"Installation","title":"Build System Image to Accelerate Start-up Time","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Since Bloqade is a very large package, its loading time and time-to-first-emulation can be very long. You can build system images to save all the compilation results in a binary to accelerate its loading/compilation time.","category":"page"},{"location":"install/#Build-System-Image-Via-VSCode-Julia-Plugin-(Recommended)","page":"Installation","title":"Build System Image Via VSCode Julia Plugin (Recommended)","text":"","category":"section"},{"location":"install/#Build-System-Image-Via-PackageCompiler","page":"Installation","title":"Build System Image Via PackageCompiler","text":"","category":"section"},{"location":"install/#Try-Latest-Version-of-Bloqade","page":"Installation","title":"Try Latest Version of Bloqade","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Some users may want to try the latest version of Bloqade for bugfixes, new features etc. One can use git to clone the repo to try the latest version of the entire package. This requires one to setup the local project environment via dev. Please refer to #Contributing for more reference.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you only want to try the latest version of a specific Bloqade package, just add #master behind the package name, e.g","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add BloqadeExpr#master","category":"page"},{"location":"contrib/#Contributing","page":"Contributing Bloqade","title":"Contributing","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"If you are interested in contributing to this package, please consider going through this guide to help you smooth your developing workflow.","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"Contributing to documentation is always a good start to get familiar with the community and workflows.","category":"page"},{"location":"contrib/#Documentation","page":"Contributing Bloqade","title":"Documentation","text":"","category":"section"},{"location":"contrib/#Setup-Documentation","page":"Contributing Bloqade","title":"Setup Documentation","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"If you are editing the documentation, you can use the serve command","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run doc serve","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"to serve the documentation locally, and it will automatically update the served webpage while you editing. ","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"If you wish to just build the documentation, you can use build command, which will run the build","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run doc build","category":"page"},{"location":"contrib/#Light-weight-Documentation-Build","page":"Contributing Bloqade","title":"Light-weight Documentation Build","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"Due to the ancient technology used by Documenter, it cannot render single page while editing, thus causing the doc serve command to be very slow when editing. We provide a light-weight build setup to workaround this by removing all literate examples from the documentation. You can enable this by","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run doc build --light\n.ci/run doc serve --light","category":"page"},{"location":"contrib/#Setting-Up-Environments","page":"Contributing Bloqade","title":"Setting Up Environments","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"The Bloqade package itself is a meta-package that simply re-exports component packages lives in lib directory. Thus one will need to dev the corresponding component package to make sure they are using the master branch version while developing, you can always do this manually in Julia's Pkg mode via dev command, e.g in the Bloqade environment (the Bloqade/Project.toml file), one will need to run the following command","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"pkg> dev lib/BloqadeExpr lib/BloqadeKrylov lib/BloqadeLattices lib/BloqadeMIS lib/BloqadeODE lib/BloqadeWaveforms","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"this can be done automatically using the CLI tool introduced in the following.","category":"page"},{"location":"contrib/#Components","page":"Contributing Bloqade","title":"Components","text":"","category":"section"},{"location":"contrib/#The-CLI-Tool","page":"Contributing Bloqade","title":"The CLI Tool","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"There is a CLI tool in this repository at .ci/run that can help you simplify the workflow a lot. You can run .ci/run -h in your terminal to see the help message. or run .ci/run <command> -h to see the help message of each command. Here are some common examples of it.","category":"page"},{"location":"contrib/#Create-New-Examples","page":"Contributing Bloqade","title":"Create New Examples","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"create a new example project called my_new_examples in examples and setup the dependencies of Bloqade.","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run example create my_new_example","category":"page"},{"location":"contrib/#Build-Single-Example","page":"Contributing Bloqade","title":"Build Single Example","text":"","category":"section"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":"build a single example at build/my_example to jupyter notebook.","category":"page"},{"location":"contrib/","page":"Contributing Bloqade","title":"Contributing Bloqade","text":".ci/run example build my_example","category":"page"},{"location":"cuda/#CUDA-Acceleration","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"","category":"section"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"The emulator supports CUDA acceleration, to use CUDA acceleration, you will need NVIDIA graphic card.","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"Converting your CPU-based simulation to CUDA-based simulation is simple, just use the cu function from CUDA on the register object, which will convert the CPU-based register to a CUDA-based register, e.g","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"reg = zero_state(5)\ndreg = cu(reg) # device register","category":"page"},{"location":"cuda/","page":"CUDA Acceleration","title":"CUDA Acceleration","text":"other code in the emulator should adapt to CUDA automatically.","category":"page"},{"location":"topics/ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"topics/bravais/#bravais-lattice","page":"Bravais Lattice","title":"Bravais Lattice","text":"","category":"section"},{"location":"registers/#Registers","page":"Registers","title":"Registers","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"Bloqade follows the register interface in [Yao]. It uses register to  represent a device and its internal quantum state. As for simulators, the most used register types are ArrayReg and SubspaceArrayReg. They both uses a dense array to store the corresponding quantum state, except the later also stores a subspace object.","category":"page"},{"location":"registers/#Basic-Interfaces","page":"Registers","title":"Basic Interfaces","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"The ArrayReg comes from Yao, and SubspaceArrayReg is a  special register made for simulations in Rydberg blockade subspace. You can use zero_state to create a register with its internal state to be zero state 0000ranlge.","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"using Bloqade\nzero_state(5) # creates a 5-qubit register","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"to create more general product state, you can use product_state function","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"product_state(bit\"10011\")","category":"page"},{"location":"registers/","page":"Registers","title":"Registers","text":"where bit\"10011 is a special Julia string literal defined for bitstrings.","category":"page"},{"location":"registers/#Operations","page":"Registers","title":"Operations","text":"","category":"section"},{"location":"registers/","page":"Registers","title":"Registers","text":"You can perform various operations on registers via standard Yao  register interface, this includes applying operators using apply!, measure on the interal quantum state using measure! or calculate an expectation using expect.","category":"page"},{"location":"quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick-start/#Create-a-Hamiltonian","page":"Quick Start","title":"Create a Hamiltonian","text":"","category":"section"},{"location":"quick-start/#Define-Atom-Positions","page":"Quick Start","title":"Define Atom Positions","text":"","category":"section"},{"location":"quick-start/#Run-emulation","page":"Quick Start","title":"Run emulation","text":"","category":"section"},{"location":"quick-start/#Create-a-Lattice","page":"Quick Start","title":"Create a Lattice","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Creating a lattice is very simple in Bloqade, e.g we can create a square lattice as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using Bloqade\ngenerate_sites(SquareLattice(), 3, 3)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"this generates the atom positions on a 3times 3 square lattice using the generate_sites function.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"we support the following built-in lattice: SquareLattice, KagomeLattice, HoneycombLattice, and more. Please refer to Lattices for more detailed guide of lattice related operation.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"tips: Tips\nThe lattice in Bloqade is actually defined as general Bravis lattice. You can create your own by defining the corresponding lattice vector. Check Bravais Lattice","category":"page"},{"location":"quick-start/#Create-a-Waveform","page":"Quick Start","title":"Create a Waveform","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Bloqade gives users the flexibility to specify general waveform by inputing functions. The following code constracting a sinusoidal waveform with time duration of 4 pi","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"waveform = Waveform(t->2.2sin(t), duration=4π)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"We also support several built-in time-dependent waveforms, including piecewise_linear, piecewise_constant, linear_ramp, constant, sinusoidal. For example, we can create a piecewise linear waveform simply by one line below ","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"waveform = piecewise_linear(clocks=[0.0, 0.2, 0.5, 0.8, 1.0], values=[0.0, 1.5, 3.1, 3.1, 0.0])","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Please refer to Waveform for more detailed guide of waveform related operation.","category":"page"},{"location":"quick-start/#Create-a-Register","page":"Quick Start","title":"Create a Register","text":"","category":"section"},{"location":"hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Hamiltonian encodes essential physical properties of Rydberg systems. One can use a Hamiltonian to  understand the ground state properties of the corresponding Rydberg system and to generate interesting quantum dynamics.  The Rydberg Hamiltonian is generally specified by atom positions, Rabi frequencies and detunings. In Bloqade,  we can easily create a Hamiltonian by inputting these information, i.e. lattice and strengths of Rabi frequencies and detunings,  into the function rydberg_h. Furthermore, by inputing waveforms for the Rabi frequency and  detuning, we can easily generate time-dependent Hamiltonians. ","category":"page"},{"location":"hamiltonians/#Building-Time-Independent-Hamiltonians","page":"Hamiltonians","title":"Building Time-Independent Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"To specify the Hamiltonian, we first need to specify the atom positions, which determine the Rydberg intearctions strengths between pairs of atoms. Here we generate a square lattice by using the code below. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3, scale=6.3);","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Please refer to Lattice page for more details about generating lattice and relevant operations. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Then the Hamiltonian can be simply built by inputing the generated atom positions atoms and by specifying the strength of Rabi detuning Δ, Rabi frequency Ω, and laser phase ϕ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h0 = rydberg_h(atoms; Δ=1.2, Ω=1.1, ϕ=2.1)","category":"page"},{"location":"hamiltonians/#Building-Time-Dependent-Hamiltonians","page":"Hamiltonians","title":"Building Time-Dependent Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"One can also directly use waveforms (instead of contanst values of detuning, Rabi frequency, and laser phase) to build a time-dependent Hamiltonian.  First let us use the  generate_sites to create a list of atom coordinates. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"atoms = generate_sites(ChainLattice(), nsites, scale=5.72)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Then we generate time-dependent pulses for Omega and Delta by using  piecewise_linear. For details about how to build waveforms, please refer to the section Waveforms. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Ω1 = piecewise_linear(clocks=[0.0, 0.1, 2.1, 2.2], values=[0.0, 6.0, 6.0, 0]);\nΔ1 = piecewise_linear(clocks=[0.0, 0.6, 2.1, 2.2], values=[-10.1, -10.1, 10.1, 10.1]);","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The time-dependent Hamiltonian is easily generated by inputting the waveforms into the function rydberg_h","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h1 = rydberg_h(atoms; Δ=Δ1, Ω=Ω1)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"By specifying the time of h1, we can  acess the Hamiltonian at a particular time, e.g. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"ht= h1(0.5)","category":"page"},{"location":"hamiltonians/#Hamiltonian-Expressions","page":"Hamiltonians","title":"Hamiltonian Expressions","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Inside this package, a more general definition of hamiltonians are supported as Symbolic expressions, this gives users the flexiblity to define various different kind of Hamltonian by simply writing down the expression.","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Currently, there are currently 4 terms supported: RydInteract, XTerm, NTerm, ZTerm. Instead of using the function rydberg_h,  we can also explicitly add up these terms to compose a new hamiltonian, e.g","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using Bloqade\nh = XTerm(5, 1.0) + ZTerm(5, 1.0)","category":"page"},{"location":"hamiltonians/#Convert-Hamiltonian-to-Matrices","page":"Hamiltonians","title":"Convert Hamiltonian to Matrices","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"In order to better understand physical properties (such as engenstate properties and eigenvalue statistics) of a Rydberg system, we may want to diagonalize the corresponding Hamiltonian  matrices. In Bloqade, the Hamiltonian expression can be converted to a matrice via type conversion, e.g we can convert the above Hamiltonian to a SparseMatrixCSC","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using SparseArrays\nh_m = SparseMatrixCSC(ht)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"With strong interactions, only one Rydberg excitation is allowed within the Blockade regime (see blockade). In such a case, the allowed Hilbert space (called blockade subpace) for N atoms  is only part of full 2^N Hilbert space. In this case, it is better to work in the blockade subspace such that one can access larger systems.  One of the essential feature of Bloqade is to allow the users to also work in blockade subspace. Here, we can easily convert the Hamiltonian expression into a matrices in subspace basis. First, we can specify such a subspace by using function blockade_subspace, e.g. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"space = blockade_subspace(atoms, 7.5)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"The above code means that the blocakde subspace only includes states where there is only one Rydberg excitation  within the distance of 75 mu m. If we have a chain of atoms seperated by 572 mu m, the blocakde subspace  does not contains states with nearest-neighbour atoms being simutaniously excited. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Once we have defined the space, we can convert the Hamiltonain to matrice in subspace basis via the codes below","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"h_s= SparseMatrixCSC(ht, space)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"We can see that the size of the matrices in blockade susbpace is much smaller than that in the full space. ","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"After the conversion, the Hamiltonian can be diagonalized by using KrylovKit.eigsolve","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"using KrylovKit\nvals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR)","category":"page"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"where the vals and vecs store calculated eigenvalues and eigenvectors respectively. ","category":"page"},{"location":"mis/#Maximum-Independent-Set","page":"Maximum Independent Set","title":"Maximum Independent Set","text":"","category":"section"},{"location":"lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices/#Create-a-lattice","page":"Lattices","title":"Create a lattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"With Bloqade, we are going to be simulating the quantum evolution of information stored in neutral atoms. Present-day experimental platforms allow distribution of atoms in an organized lattice structure and even in  arbitrary shapes. This makes neutral atom a natural setup for quantum simulation of statistical models and quantum matter. With Bloqade, we support several built-in lattice structure and allow the users to specify atom positions by inputing coordinates.","category":"page"},{"location":"lattices/#Lattice-types","page":"Lattices","title":"Lattice types","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"A crystal lattice is completely determined by a set of Bravais lattice vectors (in unit of mu m) plus atom locations in a unit cell. A Bravais lattice is an infinite array of decrete points generated by a set of discrete translation operations described by","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"mathbfR = n_1 mathbfa_1 + n_2 mathbfa_2 + ldots + n_d mathbfa_d","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where d is the dimension of space, n_1 ldots n_d in Z are integers. The unit cell of a Bravais lattice is defined by specifing its lattice vectors (mathbfa_1 mathbfa_2 ldots mathbfa_d). To create a simple lattice, we just place one site at location (0.0, 0.0) in a unit cell. For example, to create a triangular lattice, we can specify its lattice vector to be (1.0, 0.0) and (0.5, 0.5*sqrt(3)).","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using Bloqade\ntriangular = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))], [(0.0, 0.0)])","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"For composite lattices, one should provide multiple sites as the second argument to specify their locations in a unitcell. For example, the honeycomb lattice can be defined by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"honeycomb = GeneralLattice([(1.0, 0.0), (0.5, 0.5*sqrt(3))],\n    [(0.0, 0.0), (0.5, 0.5/sqrt(3))])","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We provide a few shorthands for several useful lattices. One can use lattice_vectors and lattice_sites to access the lattice vectors and sites locations in a unit cell as described in the above section.","category":"page"},{"location":"lattices/#[ChainLattice](@ref)","page":"Lattices","title":"ChainLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"using Bloqade\n\nchain = ChainLattice()","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"img_atoms(generate_sites(chain, 10))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"note: Note\nYou can see the above visulization in one of the following editorsa VSCode editor,\na Jupyter notebook,\nor a Pluto notebook,But not in a Julia REPL that does not have a graphical display.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(chain)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(chain)","category":"page"},{"location":"lattices/#[SquareLattice](@ref)","page":"Lattices","title":"SquareLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"square = SquareLattice()\n\nimg_atoms(generate_sites(square, 10, 10))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Note that the index showing on sites are consistent with the index of qubits for performing computation.  In other words, if we want to do measurment or apply opearations on individual sites (qubits), we can refer the numbering on atoms for convienience.  For more details about how to generate Hamiltonian by using lattice as an argument, please see the section Hamiltonian.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(square)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(square)","category":"page"},{"location":"lattices/#[RectangularLattice](@ref)","page":"Lattices","title":"RectangularLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"rectangle = RectangularLattice(0.5)\n\nimg_atoms(generate_sites(rectangle, 5, 5))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(rectangle)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(rectangle)","category":"page"},{"location":"lattices/#[HoneycombLattice](@ref)","page":"Lattices","title":"HoneycombLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"honeycomb = HoneycombLattice()\n\nimg_atoms(generate_sites(honeycomb, 5, 5))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(honeycomb)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(honeycomb)","category":"page"},{"location":"lattices/#[TriangularLattice](@ref)","page":"Lattices","title":"TriangularLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"triangular = TriangularLattice()\n\nimg_atoms(generate_sites(triangular, 8, 8))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(triangular)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(triangular)","category":"page"},{"location":"lattices/#[LiebLattice](@ref)","page":"Lattices","title":"LiebLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lieb = LiebLattice()\n\nimg_atoms(generate_sites(lieb, 5, 5))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(lieb)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(lieb)","category":"page"},{"location":"lattices/#[KagomeLattice](@ref)","page":"Lattices","title":"KagomeLattice","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"kagome = KagomeLattice()\n\nimg_atoms(generate_sites(kagome, 5, 5))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_vectors(kagome)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"lattice_sites(kagome)","category":"page"},{"location":"lattices/#Generate-and-sort-sites","page":"Lattices","title":"Generate and sort sites","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Once we have defined certain lattice shapes (which have fixed lattice vectors and site positions), we can generate the atom positons by  specifying the number of atoms and the scale size of the lattice.  This is done by using the function generate_sites , which will return a AtomList instance containing the coordinates for each atoms. e.g.  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms = generate_sites(HoneycombLattice(), 3, 5; scale=4.5)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where scale defines the unit distance in experimental unit (mu m) of the lattice, and 3, 5 specifies the repetitions of unit cells in each lattice vector direction.  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"We also support different operations for the generated lattices. For instance,  one can apply predefined filters, e.g. rescale_axes, clip_axes, offset_axes, to manipulate atom locations.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"rescale_axes(atoms, 0.8)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"where the above operation rescales the coordinates of original sites by a factor of 0.8. ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The code below restricts the atoms sitting in window (0.0, 5.0), (0.0, 6.0) and throw aways those outside this regime. ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"clip_axes(atoms, (0.0, 5.0), (0.0, 6.0))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Further, we can shift the origin of atoms by some vector (5.0, 5.0) simply by typing the code","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"offset_axes(atoms, 5.0, 5.0)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"To sort the atoms by the their x-coordinates, one can convert these locations to a MaskedGrid representation of the atoms.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atoms_in_grid = make_grid(atoms)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Then one can get the sorted atoms by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"sorted_atoms = collect_atoms(atoms_in_grid)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"Note that the sorting has changed the index numbering of atoms. ","category":"page"},{"location":"lattices/#User-determined-arbitrary-lattices","page":"Lattices","title":"User-determined arbitrary lattices","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can also generate atoms located at arbitray positions by directly inputing the atoms' coordinates  ","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"atom_coordinate = AtomList([(0.0, 0.0), (0, 5), (0, 8), (5, 2), (6, 7), (9, 6)])","category":"page"},{"location":"lattices/#Query-neighbors","page":"Lattices","title":"Query neighbors","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can use make_kdtree to generate a k-d tree data type for efficient querying neighborhoods in low dimensional space.","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"tree = make_kdtree(sorted_atoms)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The return value is a KDTree instance, which is defined in package NearestNeigbors. One can use it to query the neighbors of an atom, e.g. one can find the 20 nearest neighbors of the 5-th site by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"neighbors = grouped_nearest(tree, 5, 20)","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"The return value is a DistanceGroup instance, and the indices of second nearest neighbors are","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"neighbors[2]","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"One can select and display these atoms with correct labeling by typing","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"img_atoms(sorted_atoms[neighbors[2]]; texts=string.(neighbors[2]))","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"It show the correct second nearest neigbors of site 5. One can check the docstring of img_atoms to know more about how to custom lattice visualization.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"CurrentModule = BloqadeWaveforms","category":"page"},{"location":"waveform/#Waveforms","page":"Waveforms","title":"Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms are essential ingredients for Rydberg quantum simulations. By controlling the waveforms of Omega and Delta, one can prepare ground states of certain target Hamiltonian and study non-equalibrium dynamics of time-dependent Hamiltonians. With Bloqade, we support several built-in waveforms and allow the users to specify waveforms by inputing functions. We also support different operations of waveforms, such as smoothing, slicing, and composing, et al. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"The generated waveforms can be directly used to build time-dependent Hamiltonians, see Hamiltonian. ","category":"page"},{"location":"waveform/#Creating-Waveforms","page":"Waveforms","title":"Creating Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In Bloqade, the waveforms are defined as Waveform object, which is a composition of a callable object and a real number duration.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade gives users the flexibility to specify general waveforms by inputing functions. The following code constracting a sinusoidal waveform with time duration of 4 pi","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"using Bloqade\nusing BloqadePlots\nwaveform = Waveform(t->2.2sin(t), duration=4π);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"We also support several built-in time-dependent waveforms, including piecewise_linear, piecewise_constant, linear_ramp, constant, sinusoidal. For example, the codes below create different waveform shapes simply by single lines ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_linear(clocks=[0.0, 0.2, 0.5, 0.8, 1.0], values=[0.0, 1.5, 3.1, 3.1, 0.0]); \ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1]); \ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform = linear_ramp(duration=0.5, start_value=0.0, stop_value=1.0);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform =  constant(duration=0.5, value=2.1);\ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"waveform =  sinusoidal(duration=4π, amplitude=2.2); \ndraw(waveform)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"In certain cases, users may have their own waveforms specified by a vector of clocks and a vector of signal strengths. To build a waveform from the two vectors, we can directly use the functions piecewise_linear or piecewise_constant, corresponding to different interpolations. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"a =  [i for i in 1:10]\nb = rand(10)\nwf1 = piecewise_linear(clocks=a; values=b)\nwf2 = piecewise_constant(clocks=a; values=b)","category":"page"},{"location":"waveform/#Operations-of-Waveforms","page":"Waveforms","title":"Operations of Waveforms","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade also supports several operations of the waveforms.  Waveforms can be sliced using the duration syntax start..stop, e.g","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"using BloqadeWaveform # hide\nwf = sinusoidal(duration=2.2);\nwf[1.1..1.5];\ndraw(wf)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Waveforms can be composed together via append","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf1 = Waveform(sin, duration=2.2)\nwf2 = linear_ramp(;start_value=0.0, stop_value=1.1, duration=0.5)\nwaveform = append(wf1, wf2)","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"where the waveform w2 is appended at the end of w1. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Sharp waveforms may result in bad performance in practice (e.g. for adibatic preparing a ground state of target Hamiltnonian), it is sometimes preferred to smoothen the waveform using the moving average methods, one can use the smooth function to create a smooth-ed wavefrom from a piecewise linear waveform.","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 3.0, 1.1, 2.2])\nswf = smooth(wf)","category":"page"},{"location":"waveform/#Waveform-Linear-Algebra","page":"Waveforms","title":"Waveform Linear Algebra","text":"","category":"section"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Bloqade also supports several linear algebra operations of waveforms. If two waveforms have the same duration, we can directly add up or subtract the strength of two waveforms, simply by using + or -. ","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf1 = linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0);\nwf2 = Waveform(sin, duration=2.2);\nwf3 = wf1 + wf2\nwf4 = wf1 - wf2","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"If we want to increase the strength of a waveform by some times, we can directly use *","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf = linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0);\nwf_t = 3 * wf","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"Such operation could also be broadcasted by using .*","category":"page"},{"location":"waveform/","page":"Waveforms","title":"Waveforms","text":"wf2, wf3 = [2.0, 3.0] .* wf1","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"CurrentModule = Bloqade","category":"page"},{"location":"emulation/#Emulation-of-Shordinger-Equation","page":"Emulation","title":"Emulation of Shordinger Equation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The dynamics of Rydberg system is described by a Shordinger Equation of a hamiltonian. There are two methods for solving this equation, one is via Krylov subspace projection for time independent hamiltonian, the other is ODE-basd solver.","category":"page"},{"location":"emulation/#Krylov-Based-Solver","page":"Emulation","title":"Krylov Based Solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The Krylov-based method expects time independent hamiltonians, one can define such evolution via KrylovEvolution object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"KrylovEvolution","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"tip: Tip\none can use trotterize function to discretize a time-dependent hamiltonian into a list of time indepdent hamiltonian to use  Krylov-based solver for time-dependent problem if preferred.","category":"page"},{"location":"emulation/#ODE-Based-Solver","page":"Emulation","title":"ODE Based Solver","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"The ODE-based method expects time-dependent hamiltonians, one can define such evolution via ODEEvolution object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ODEEvolution","category":"page"},{"location":"emulation/#Run-Emulation","page":"Emulation","title":"Run Emulation","text":"","category":"section"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"To run the emulation, you need to define the exact evolution and solver you would like to run with via either KrylovEvolution or ODEEvolution, then feed the corresponding object to emulate! function","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"emulate!","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"For example, we can simulate a constant hamiltonian","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"using Bloqade\natoms = generate_sites(SquareLattice(), 3, 3; scale=5.1)\nds = rand(3) # durations\nhs = [rydberg_h(atoms;Δ=2.0, Ω=1.0) for _ in 1:3]\nreg = zero_state(length(atoms)) # create fullspace register\nev = KrylovEvolution(reg, ds, hs)\nemulate!(ev)","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"Or if you would like to do some operation during the evolution, such as measure observables during the evolution, you can instead write the for loop","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"ev = KrylovEvolution(reg, ds, hs)\nfor info in ev\n    @info \"running emulation\" step=info.step duration=info.duration h=info.hamiltonian reg=info.reg\nend","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"You can use any function on the reg object.","category":"page"},{"location":"emulation/","page":"Emulation","title":"Emulation","text":"tip: Tip\nremember to make sure your operation does not mutate your state so that this won't effect the evolution itself, since the entire time evolution is simulated by keep mutating the state vector stored in reg which means do not use any function that has a ! in its name on the register info.reg unless you are certain about what you are doing.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#Bloqade","page":"References","title":"Bloqade","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [Bloqade]","category":"page"},{"location":"ref/#BloqadeODE","page":"References","title":"BloqadeODE","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [BloqadeODE]","category":"page"},{"location":"ref/#BloqadeODE.SchrodingerProblem","page":"References","title":"BloqadeODE.SchrodingerProblem","text":"struct SchrodingerProblem\nSchrodingerProblem(reg, tspan, hamiltonian; kw...)\n\nDefine a Schrodinger equation problem that uses ODE solver from OrdinaryDiffEq to solve the dynamics.\n\nArguments\n\nregister: required, the evolution problem register, can be a RydbergReg or an ArrayReg   from Yao.\ntspan: required, a (start, stop) tuple or a single number t, the single value form t is equivalent   to (zero(t), t).\nhamiltonian: required, the evolution hamiltonian, can be created via rydberg_h.\n\nCommon Keyword Arguments\n\nalgo: optional, algorithm to use, this only works for the emulate! interface.   for solve or integrator interface, one will need to specify the algorithm explicitly.\nprogress: print progress bar or not, this may effect the performance when problem scale is small, default is true.\nprogress_steps: steps to update the progress bar, default is 5.\nreltol: relative tolerance, default is 1e-8.\nabstol: absolute tolerance, default is 1e-8.\n\nFurther References\n\nFor more ODE options, please refer to Common Solver Options. The SchrodingerProblem type supports most of the standard DiffEq problem interface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeWaveforms","page":"References","title":"BloqadeWaveforms","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [BloqadeWaveforms]","category":"page"},{"location":"ref/#BloqadeWaveforms.Waveform","page":"References","title":"BloqadeWaveforms.Waveform","text":"Waveform{F, T <: Real}\n\nType for waveforms. Waveforms are defined as a function combiend with a real number duration.\n\nFields\n\nf: a callable object.\nduration: a real number defines the duration of this waveform.\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeWaveforms.Waveform-Tuple{Any}","page":"References","title":"BloqadeWaveforms.Waveform","text":"Waveform(f; duration::Real)\n\nCreate a Waveform object from callable f, the unit of duration is μs.\n\nExample\n\njulia> Waveform(duration=1.5) do t\n    2t+1\nend\n           ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n           ┌────────────────────────────────────────┐ \n         4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \nvalue (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           │⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         1 │⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n           └────────────────────────────────────────┘ \n           ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.append-Tuple{Waveform, Vararg{Waveform}}","page":"References","title":"BloqadeWaveforms.append","text":"append(wf::Waveform, wfs::Waveform...)\n\nAppend other waveforms to wf on time axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.constant-Tuple{}","page":"References","title":"BloqadeWaveforms.constant","text":"constant(;duration::Real, value::Real)\n\nCreate a constant waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nvalue::Real: value of the constant waveform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.linear_ramp-Tuple{}","page":"References","title":"BloqadeWaveforms.linear_ramp","text":"linear_ramp(;duration, start_value, stop_value)\n\nCreate a linear ramp waveform.\n\nKeyword Arguments\n\nduration::Real: duration of the whole waveform.\nstart_value::Real: start value of the linear ramp.\nstop_value::Real: stop value of the linear ramp.\n\nExample\n\njulia> linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                1 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀3⠀ \n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.piecewise_constant-Tuple{}","page":"References","title":"BloqadeWaveforms.piecewise_constant","text":"piecewise_constant(;clocks, values, duration=last(clocks))\n\nCreate a piecewise constant waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\nduration::Real: the duration of the entire waveform, default is the last clock.\n\nExample\n\njulia> piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1], duration=1.1)\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢠⠒⠒⠒⠒⠒⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                0 │⣀⣀⣀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ \n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.piecewise_linear-Tuple{}","page":"References","title":"BloqadeWaveforms.piecewise_linear","text":"piecewise_linear(;clocks, values)\n\nCreate a piecewise linear waveform.\n\nKeyword Arguments\n\nclocks::Vector{<:Real}: the list of clocks for the corresponding values.\nvalues::Vector{<:Real}: the list of values at each clock.\n\nExample\n\njulia> piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 2.0, 2.0, 0.0])\n                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n                  ┌────────────────────────────────────────┐ \n                2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀│ \n   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⠀⠀│ \n                  │⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀│ \n                  │⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀│ \n                  │⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀│ \n                  │⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆│ \n                0 │⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱│ \n                  └────────────────────────────────────────┘ \n                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀ \n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.sinusoidal-Tuple{}","page":"References","title":"BloqadeWaveforms.sinusoidal","text":"sinusoidal(;duration::Real, amplitude::Real=one(start))\n\nCreate a sinusoidal waveform of the following expression.\n\namplitude * sin(t)\n\nKeyword Arguments\n\nduration: duration of the waveform.\namplitude: amplitude of the sin waveform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeWaveforms.smooth","page":"References","title":"BloqadeWaveforms.smooth","text":"smooth([kernel=Kernel.gaussian], f; edge_pad_size::Int=length(f.clocks))\n\nKernel smoother function for piece-wise linear function/waveform via weighted moving average method.\n\nArguments\n\nkernel: the kernel function, default is Kernels.gaussian.\nf: a Union{PiecewiseLinear, PiecewiseConstant} function or a Waveform{<:Union{PiecewiseLinear, PiecewiseConstant}}.\n\nKeyword Arguments\n\nkernel_radius: radius of the kernel.\nedge_pad_size: the size of edge padding.\n\n\n\n\n\n","category":"function"},{"location":"ref/#BloqadeWaveforms.smooth-Tuple{Any, Vector, Vector, Real}","page":"References","title":"BloqadeWaveforms.smooth","text":"smooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)\n\nKernel smoother function via weighted moving average method. See also Kernel Smoother.\n\nTheory\n\nKernel function smoothing is a technique to define a smooth function f mathcalR^p  mathbfR from a set of discrete points by weighted averaging the neighboring points. It can be written as the following equation.\n\nY(X) = sum_i K(X X_i) Y_i  sum_i K(X X_i)\n\nwhere Y(X) is the smooth function by calculating the moving average of known data points X_i and Y_i. K is the kernel function, where K(fracX - X_ih_λ) decrease when the Euclidean norm X - X_i increase, h_λ is a parameter controls the radius of the kernel.\n\nAvailable Kernels\n\nThe following kernel functions are available via the Kernels module:\n\nbiweight; cosine; gaussian; include; logistic; parabolic; sigmoid; triangle; tricube; triweight; uniform\n\nArguments\n\nkernel: a Julia function that has method kernel(t::Real).\nXi::Vector: a list of inputs X_i.\nYi::Vector: a list of outputs Y_i.\nkernel_radius::Real: the radius of the kernel.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices","page":"References","title":"BloqadeLattices","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [BloqadeLattices]","category":"page"},{"location":"ref/#BloqadeLattices.AtomList","page":"References","title":"BloqadeLattices.AtomList","text":"AtomList{D, T} <: AbstractVector{NTuple{D, T}}\nAtomList(atoms::Vector{<:NTuple})\n\nA list of atoms in D dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.ChainLattice","page":"References","title":"BloqadeLattices.ChainLattice","text":"BloqadeLattices.ChainLattice <: AbstractLattice{1}\nBloqadeLattices.ChainLattice()\n\nBloqadeLattices.ChainLattice is a 1 dimensional lattice with:\n\nLattice vectors = ((1.0,),)\nLattice sites   = ((0.0,),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.DistanceGroup","page":"References","title":"BloqadeLattices.DistanceGroup","text":"DistanceGroup\n\nThe vertices grouped by distances. One can use distancegroup[n] to get n-th nearest neighbors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.GeneralLattice","page":"References","title":"BloqadeLattices.GeneralLattice","text":"GeneralLattice{D,K,T} <: AbstractLattice{D}\nGeneralLattice(vectors, sites)\n\nThe general lattice type for tiling the space. Type parameter D is the dimension, K is the number of sites in a unit cell and T is the data type for coordinates, e.g. Float64. Input arguments are\n\nvectors is a vector/tuple of D-tuple. Its length is D, it specifies the Bravais lattice vectors.\nsites is a vector/tuple of D-tuple. Its length is K, it specifies the sites inside a Bravais cell.\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.HoneycombLattice","page":"References","title":"BloqadeLattices.HoneycombLattice","text":"BloqadeLattices.HoneycombLattice <: AbstractLattice{2}\nBloqadeLattices.HoneycombLattice()\n\nBloqadeLattices.HoneycombLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.5, 0.2886751345948129))\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.KagomeLattice","page":"References","title":"BloqadeLattices.KagomeLattice","text":"BloqadeLattices.KagomeLattice <: AbstractLattice{2}\nBloqadeLattices.KagomeLattice()\n\nBloqadeLattices.KagomeLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0), (0.25, 0.4330127018922193), (0.75, 0.4330127018922193))\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.LiebLattice","page":"References","title":"BloqadeLattices.LiebLattice","text":"BloqadeLattices.LiebLattice <: AbstractLattice{2}\nBloqadeLattices.LiebLattice()\n\nBloqadeLattices.LiebLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0), (0.5, 0.0), (0.0, 0.5))\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.MaskedGrid","page":"References","title":"BloqadeLattices.MaskedGrid","text":"MaskedGrid{T}\nMaskedGrid(xs, ys, mask)\n\nMasked square lattice contains 3 fields, the x-coordinates, y-coordinates and a mask. e.g. MaskedGrid([0.0, 1.0, 3.0], [0.0, 2.0,6.0], Bool[1 0 0; 0 1 1; 0 1 0]) specifies the following lattice:\n\n     y₁   y₂        y₃\n     ↓    ↓         ↓\nx₁ → ●    ⋅         ●\nx₂ → ⋅    ●         ●\n\nx₃ → ⋅    ●         ⋅\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.RectangularLattice","page":"References","title":"BloqadeLattices.RectangularLattice","text":"RectangularLattice <: AbstractLattice{2}\nRectangularLattice(aspect_ratio::Real)\n\nRectangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, aspect_ratio)\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.SquareLattice","page":"References","title":"BloqadeLattices.SquareLattice","text":"BloqadeLattices.SquareLattice <: AbstractLattice{2}\nBloqadeLattices.SquareLattice()\n\nBloqadeLattices.SquareLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.0, 1.0))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.TriangularLattice","page":"References","title":"BloqadeLattices.TriangularLattice","text":"BloqadeLattices.TriangularLattice <: AbstractLattice{2}\nBloqadeLattices.TriangularLattice()\n\nBloqadeLattices.TriangularLattice is a 2 dimensional lattice with:\n\nLattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))\nLattice sites   = ((0.0, 0.0),)\n\n\n\n\n\n","category":"type"},{"location":"ref/#BloqadeLattices.clip_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{Tuple{T, T}, D}}} where {D, T}","page":"References","title":"BloqadeLattices.clip_axes","text":"clip_axes(sites::AtomList{D, T}, bounds::Vararg{Tuple{T,T},D}) where {D, T}\nclip_axes(bounds...)\n\nRemove sites out of bounds, where bounds is specified by D D-tuples.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> clip_axes(sites, (-5.0, 5.0), (-5.0, 5.0))\n2-element AtomList{2, Float64}:\n (1.0, 2.0)\n (3.0, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.collect_atoms-Tuple{MaskedGrid}","page":"References","title":"BloqadeLattices.collect_atoms","text":"collect_atoms(maskedgrid::MaskedGrid)\n\nReturns an list of atoms in the maskedgrid in order.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.dimension-Union{Tuple{AbstractLattice{D}}, Tuple{D}} where D","page":"References","title":"BloqadeLattices.dimension","text":"dimension(lattice)\n\nReturns the space dimension of target lattice. e.g. ChainLattice is a 1D lattice, hence returns 1.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D","page":"References","title":"BloqadeLattices.generate_sites","text":"generate_sites(lattice::AbstractLattice{D}, repeats::Vararg{Int,D}; scale=1.0)\n\nReturns an AtomList instance by tiling the specified lattice. The tiling repeat the sites of the lattice m times along the first dimension, n times along the second dimension, and so on. scale is a real number that re-scales the lattice constant and atom locations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.grouped_nearest-Tuple{NearestNeighbors.KDTree, Int64, Int64}","page":"References","title":"BloqadeLattices.grouped_nearest","text":"grouped_nearest(tree::KDTree, siteindex::Int, nsites::Int; atol=1e-8)\n\nFind the nsites closest vertices to siteindex, and group them by distance. Difference of the distances smaller than the atol (default is 1e-8) are treated as the same Returns a DistanceGroup instance.\n\njulia> atoms = generate_sites(HoneycombLattice(), 5, 5);\n\njulia> tree = make_kdtree(atoms)\nNearestNeighbors.KDTree{StaticArrays.SVector{2, Float64}, Distances.Euclidean, Float64}\n  Number of points: 50\n  Dimensions: 2\n  Metric: Distances.Euclidean(0.0)\n  Reordered: true\n\njulia> gn = grouped_nearest(tree, 23, 20)\nDistanceGroup([23, 14, 22, 24, 15, 13, 21, 25, 33, 31, 12, 16, 32, 4, 6, 34, 26, 17, 5, 41], [1, 2, 5, 11, 14, 18, 21])\n\njulia> gn[0]  # the 0-th nearest neighbor is defined by vertex itself\n1-element Vector{Int64}:\n 23\n\njulia> gn[1]  # nearest neighbors\n3-element Vector{Int64}:\n 14\n 22\n 24\n\njulia> gn[2]  # second nearest neighbors\n6-element Vector{Int64}:\n 15\n 13\n 21\n 25\n 33\n 31\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.img_atoms-Tuple{AtomList{2}}","page":"References","title":"BloqadeLattices.img_atoms","text":"img_atoms(atoms::AtomList;\n    colors=[\"black\", \"black\", ...],\n    blockade_radius=0,\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    io=nothing,\n    kwargs...\n    )\n\nPlots atoms with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> using Compose\n\njulia> open(\"test.png\", \"w\") do f\n            img_atoms(generate_sites(SquareLattice(), 5, 5); io=f, format=Compose.PNG)\n       end\n\nThe format keyword argument can also be Compose.SVG or Compose.PDF. Atoms within blockade_radius will be connected by bonds.\n\nOther Keyword Arguments\n\n# overall scaling\nscale::Float64 = 1.0\n\n# padding space\npad::Float64 = 1.5 \n\n# axes\naxes_text_color::String = \"black\"\naxes_text_fontsize::Float64 = 11.0\naxes_num_of_xticks = 5\naxes_num_of_yticks = 5\naxes_x_offset::Float64 = 0.1\naxes_y_offset::Float64 = 0.06\naxes_unit::String = \"μm\"\n\n# node\nnode_text_fontsize::Float64 = 5.0\nnode_text_color::String = \"black\"\nnode_stroke_color = \"black\"\nnode_stroke_linewidth = 0.03\nnode_fill_color = \"white\"\n# bond\nbond_color::String = \"black\"\nbond_linewidth::Float64 = 0.03\n# blockade\nblockade_style::String = \"none\"\nblockade_stroke_color::String = \"black\"\nblockade_fill_color::String = \"transparent\"\nblockade_fill_opacity::Float64 = 0.5\nblockade_stroke_linewidth = 0.03\n# image size in cm\nimage_size::Float64 = 12\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.img_maskedgrid-Tuple{MaskedGrid}","page":"References","title":"BloqadeLattices.img_maskedgrid","text":"img_maskedgrid(maskedgrid::MaskedGrid;\n    format=SVG,\n    io=nothing,\n    colors=nothing,\n    texts = nothing,\n    blockade_radius = 0,\n    kwargs...\n    )\n\nDraw a maskedgrid with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image.\n\nSee also the docstring of img_atoms for explanations of other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.lattice_sites-Tuple{GeneralLattice}","page":"References","title":"BloqadeLattices.lattice_sites","text":"lattice_sites(lattice::AbstractLattice)\n\nReturns sites in a Bravais lattice unit cell as a Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.lattice_vectors-Tuple{GeneralLattice}","page":"References","title":"BloqadeLattices.lattice_vectors","text":"lattice_vectors(lattice::AbstractLattice)\n\nReturns Bravais lattice vectors as a D-Tuple of D-Tuple, where D is the space dimension.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.make_grid-Union{Tuple{AtomList{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"References","title":"BloqadeLattices.make_grid","text":"make_grid(sites::AtomList; atol=...)\n\nCreate a MaskedGrid from the sites. It is required by lattice preparation of Rydberg array. Because the grid will sort the sites by rows, we need atol (default value is 10 time sit data precision) determines up to what level of round off error, two atoms belong to the same row.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.make_kdtree-Union{Tuple{AtomList{D, T}}, Tuple{D}, Tuple{T}} where {T, D}","page":"References","title":"BloqadeLattices.make_kdtree","text":"make_kdtree(atoms::AtomList{D,T}) where {T, D}\n\nReturns a KDTree instance defined in package NearestNeighbors from input atoms.\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.offset_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{T, D}}} where {D, T}","page":"References","title":"BloqadeLattices.offset_axes","text":"offset_axes(sites::AtomList{D, T}, offsets::Vararg{T,D}) where {D, T}\noffset_axes(offsets...)\n\nOffset the sites by distance specified by offsets.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> offset_axes(sites, 1.0, 3.0)\n4-element AtomList{2, Float64}:\n (2.0, 5.0)\n (11.0, 6.0)\n (2.0, 15.0)\n (4.0, 8.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.random_dropout-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"References","title":"BloqadeLattices.random_dropout","text":"random_dropout(sites::AtomList{D, T}, ratio::Real) where {D, T}\nrandom_dropout(ratio)\n\nRandomly drop out ratio * number of sites atoms from sites, where ratio ∈ [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadeLattices.rescale_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}","page":"References","title":"BloqadeLattices.rescale_axes","text":"rescale_axes(sites::AtomList{D, T}, scale::Real) where {D, T}\nrescale_axes(scale)\n\nRescale the sites by a constant scale.\n\njulia> sites = AtomList([(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)])\n4-element AtomList{2, Float64}:\n (1.0, 2.0)\n (10.0, 3.0)\n (1.0, 12.0)\n (3.0, 5.0)\n\njulia> rescale_axes(sites, 2.0)\n4-element AtomList{2, Float64}:\n (2.0, 4.0)\n (20.0, 6.0)\n (2.0, 24.0)\n (6.0, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"ref/#BloqadePlots","page":"References","title":"BloqadePlots","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [BloqadePlots]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Bloqade","category":"page"},{"location":"#Bloqade","page":"Home","title":"Bloqade","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Coverage Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation page for the QuEra Emulator for Rydberg System.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nBloqade is a &nbsp;\n    <a href=\"https://julialang.org\">\n        <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">\n        Julia Language\n    </a>\n    &nbsp; package. To install Bloqade,\n    please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open\n    Julia's interactive session (known as REPL)</a>, press <kbd>]</kbd> key in the REPL to use the package mode, and then type the following command\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"First add the QuEra Julia registry via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> registry add https://github.com/Happy-Diode/Miskatonic.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"For stable release","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bloqade","category":"page"},{"location":"","page":"Home","title":"Home","text":"For current master","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bloqade#master","category":"page"},{"location":"#What-does-the-Rydberg-Emulator-do?","page":"Home","title":"What does the Rydberg Emulator do?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Rydberg Emulator package simulates the time evolution of a quantum state under the Schrödinger equation where the Hamiltonian is the interacting Rydberg Hamiltonian mathcalH, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"i hbar dfracpartialpartial t  psi rangle = mathcalH  psi rangle  \n\nfracmathcalHhbar = sum_j fracOmega_j(t)2 left( e^i phi_j(t)   1_j rangle  langle r_j  + e^-i phi_j(t)   r_j rangle  langle 1_j  right) - sum_j Delta_j(t) n_j + sum_j  k V_jk n_j n_k","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here Omega_j, phi_j, and Delta_j  denote the Rabi frequency, laser phase, and the detuning of the driving laser field on atom (qubit) j coupling the two states   1_j rangle (ground state) and  r_j rangle (Rydberg state). The number operator n_j = r_jrangle langle r_j, and V_jk = Coverrightarrowmathbfr_j - overrightarrowmathbfr_k^6 describes the Rydberg interaction between atoms j and k where overrightarrowmathbfr_j denotes the position of the atom j; C is the Rydberg interaction constant that depends on the particular Rydberg state used. For the emulator, the default C = 2pi times 862690 text MHz μm^6 for r rangle = 70S_12 of the ^87Rb atoms. hbar is the reduced Planck's constant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting from the initial quantum state  psi_textini rangle, the emulator can simulate the time evolution of the quantum state under the time-dependent Hamiltonian mathcalH(t), given the atom positions, the time-dependent profiles for  Omega_j, phi_j and Delta_j. The emulator can then produce the real-time evolution of quantum state  psi(t) rangle and one can then measure different observables on such a state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default units for various quantities are ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quantity Default Unit\nLength μm\nTime μs\nOmega MHz\nphi rad\nDelta MHz","category":"page"},{"location":"#Run-a-Simple-Emulation-of-Rydberg-System","page":"Home","title":"Run a Simple Emulation of Rydberg System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here, we show a simple example of simulating quantum many-body dynamics governed by the Rydberg Hamiltonian. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start by loading the Emulator Module","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Bloqade","category":"page"},{"location":"","page":"Home","title":"Home","text":"As one can see from the Rydberg Hamiltonian, the interactions between Rydberg atoms depend on their positions. Bloqade provides several built-in Lattices structures for specifying the atom positions. For instance, we can use the following codes to quickly generate a chain of 10 atoms in 1D: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"nsites = 10;\natoms = generate_sites(ChainLattice(), nsites, scale = 5.74)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have set the distance between nearest neighbor atoms to be 5.74 μm. Note that the default unit of length is μm as shown in the table above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's set both Omega and Delta to be constants. Since all the parameters are specified, we can now create an interacting Rydberg Hamiltonian by using rydberg_h, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = rydberg_h(atoms; Ω = 2π * 4, Δ = 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For creating more complicated waveforms for Omega and Delta and the supported utilities, please refer to the Waveforms page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's create an initial state with all the atoms in the ground state by using zero_state","category":"page"},{"location":"","page":"Home","title":"Home","text":"reg = zero_state(10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are interested in measuring observables of the final quantum state of the Rydberg system starting from the initial state and evolving under the Rydberg Hamiltonian over some time duration. We can first create the problem and then directly emulate the time evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob = SchrodingerProblem(reg, 1.6, h)\nintegrator = init(prob, Vern8());\nemulate!(prob);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we have chosen the ODE solver ODEEvolution and set the total evolution time to be 1.6 μs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After simulating the time evolution and get the final state, we can measure the Rydberg population at each site for the final state ","category":"page"},{"location":"","page":"Home","title":"Home","text":"rydberg_populations = map(1:nsites) do i\n    real(expect(put(nsites, i=>Op.n), prob.reg))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob.reg is the register storing the final state after the time evolution.","category":"page"},{"location":"#Looking-for-Help?","page":"Home","title":"Looking for Help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"check the slack channel #julia\nif not urgent, ask questions in discussions","category":"page"},{"location":"#Have-Suggestions-or-Interested-in-Contribution?","page":"Home","title":"Have Suggestions or Interested in Contribution?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"check the slack channel #q-emulator for meetings and discussions\nfile an issue to report a bug or request a feature","category":"page"},{"location":"julia/#The-Julia-Programming-Language","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"The Bloqade project is built in pure Julia programming language. Thus if you are not familiar with Julia, here is a quick start for basic Julia gramar, and a guide for learning more detailed and advanced Julia.","category":"page"},{"location":"julia/#Why-Julia?","page":"The Julia Programming Language","title":"Why Julia?","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Fast, as you might have heard about it, Julia is very fast, there are various benchmarks online.   It can even be used to write Basic Linear Algebra Subroutine (BLAS) to reach performance on par with   manually optimized assembly with C (check Octavian).\nGeneric, the language itself and its ecosystem are built to be generic, and the compiler can specialize   on generic methods automatically, thus you will find a lot things can be combined easily, and they will   just work, e.g plugin the Measurement number from    Measurement.jl into your ODE solver, you will get error propagation just work, plugin Tropical number into tensor contraction function, you can   solve optimization problems with tensor networks, and so on.\nDifferentiable, the language is differentiable, that means you can calculate the derivatives   using an automatic differentiation engine on the whole language. The current stable AD engine   is powered by Zygote, the next generation AD engine includes   Diffractor (check the video talk on ACM SIGPLAN),   Enzyme.\nExtensible, the language is designed to be compiler friendly, it supports staged programming   as well as compiler plugins. This makes supporting new hardware much easier. As a result, Julia   can support multiple different hardware, such as CUDA,   oneAPI, TPU and so on.\nEasy, with all these features, yet the language itself stays rather easy to learn. Let's go to   the quick start section to skim the syntax.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"info: Info\nMulti-stage programming (MSP) is a variety of metaprogramming in which compilation is divided into a series of intermediate phases, allowing typesafe run-time code generation. Statically defined types are used to verify that dynamically constructed types are valid and do not violate the type system. – Wikipedia","category":"page"},{"location":"julia/#Quick-Start","page":"The Julia Programming Language","title":"Quick Start","text":"","category":"section"},{"location":"julia/#Variables-and-Some-Basic-Types","page":"The Julia Programming Language","title":"Variables and Some Basic Types","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can define a variable similar to how you define it in Python, e.g we can define a x using = (assignment)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"x = 1","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"every variable has a type, you can check it using typeof","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(x)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"By default Julia displays the output of the last operation. (You can suppress the output by adding ; (a semicolon) at the end.)","category":"page"},{"location":"julia/#Functions","page":"The Julia Programming Language","title":"Functions","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, you can also define short-form, one-line functions using = (assignment) similar to how you write things mathematically.","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f(x) = 2x","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Typing the function's name gives information about the function. To call it we must use parentheses:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"f\nf(2)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For longer functions we use the following syntax with the function keyword and end:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"function g(x, y)\n\tz = x + y\n\treturn z^2\nend","category":"page"},{"location":"julia/#Control-Flows","page":"The Julia Programming Language","title":"Control Flows","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"In Julia, there are for, if and while, they look like the following","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s = 0\nfor i in 1:10\n    s += 1\nend","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"we can now check the value of s by typing it again","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"s","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Here, 1:10 is a range representing the numbers from 1 to 10:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"typeof(1:10)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"the if else statement looks like the following","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if s < 10\n\t# do something\nelseif 10 < s < 13\n\t# do something\nelse\n\t# do something\nend","category":"page"},{"location":"julia/#Matrix-and-Array","page":"The Julia Programming Language","title":"Matrix and Array","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own Array type, if you use Python, it is similar to numpy.array in Python except:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"index starts from 1\nthe multi-dimensional index is column-wise","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"You can also have list comprehension:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[i for i in 1:10]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"it works for multi-dimensional case too:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"[(i, j) for i in 1:10, j in 1:5]","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"most functions follow the same convention as numpy or MATLAB, e.g you can create a random matrix using:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"rand(5, 5)","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"if you have question about using a function, you can always type question mark ? in your REPL following the function name","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> ?rand","category":"page"},{"location":"julia/#Package-Manager-and-Environments","page":"The Julia Programming Language","title":"Package Manager & Environments","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"Julia carries its own package manager, you can use it as a normal package:","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> using Pkg","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"to install a pacakge, you can use","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.add(\"Yao\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"to remove a pacakge, you can use","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"julia> Pkg.rm(\"Yao\")","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"All Julia program runs inside an environment, it is the global environment by default. It is usually recommended to run your notebook in a local environment, so we won't hit any version conflicts between different packages. ","category":"page"},{"location":"julia/#Resources","page":"The Julia Programming Language","title":"Resources","text":"","category":"section"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"For more resources just check the official website julialang.org/learning","category":"page"},{"location":"julia/","page":"The Julia Programming Language","title":"The Julia Programming Language","text":"<style>\n  iframe {\n    width: 1px;\n    min-width: 100%;\n    min-height: 1000px;\n  }\n</style>\n<iframe id=\"myIframe\" src=\"https://julialang.org/learning/\"></iframe>\n<script>\n  iFrameResize({ log: true }, '#myIframe')\n</script>","category":"page"}]
}
