<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Emulation · Bloqade.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Happy-Diode.github.io/Bloqade.jl/emulation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bloqade.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../registers/">Registers</a></li><li class="is-active"><a class="tocitem" href>Emulation</a><ul class="internal"><li><a class="tocitem" href="#Run-ODE-based-Emulation"><span>Run ODE-based Emulation</span></a></li><li><a class="tocitem" href="#Choosing-ODE-solver"><span>Choosing ODE solver</span></a></li><li><a class="tocitem" href="#Adaptive-Steps-in-ODE-solver"><span>Adaptive Steps in ODE solver</span></a></li><li><a class="tocitem" href="#Run-Krylov-based-Emulation"><span>Run Krylov-based Emulation</span></a></li><li><a class="tocitem" href="#Krylov-vs-ODE-solver"><span>Krylov vs ODE solver</span></a></li></ul></li><li><a class="tocitem" href="../subspace/">Working with Subspace</a></li><li><a class="tocitem" href="../observables/">Observables</a></li><li><a class="tocitem" href="../mis/">Maximum Independent Set</a></li><li><a class="tocitem" href="../cuda/">CUDA Acceleration</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/adiabatic/main/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/noise/main/">Adiabatic Preparation with Sensitivity Analysis</a></li><li><a class="tocitem" href="../tutorials/quantum-scar/main/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/ring/main/">Ring Emulation</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../topics/blockade/">Rydberg Blockade</a></li><li><a class="tocitem" href="../topics/bravais/">Bravais Lattice</a></li><li><a class="tocitem" href="../topics/ad/">Automatic Differentiation</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing Bloqade</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Emulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Emulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Happy-Diode/Bloqade.jl/blob/master/docs/src/emulation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="emulation"><a class="docs-heading-anchor" href="#emulation">Emulation of Shordinger Equation</a><a id="emulation-1"></a><a class="docs-heading-anchor-permalink" href="#emulation" title="Permalink"></a></h1><p>After we create the Rydberg Hamiltonian and Register storing the quantum information, we can  emulate the quantum many-body dynamics. The coherent dynamics of the system is governed by Schrodinger Equation. The emulation interface of Bloqade is designed as  define-and-run style.  With Bloqade, we have two major types of emulation:</p><ul><li>ODE solver based emulation for most of the problems.</li><li>Krylov based emulation for piecewise constant problems or QAOA-like problem.</li></ul><h3 id="Define-the-ODE-Emulation-Problem"><a class="docs-heading-anchor" href="#Define-the-ODE-Emulation-Problem">Define the ODE Emulation Problem</a><a id="Define-the-ODE-Emulation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-ODE-Emulation-Problem" title="Permalink"></a></h3><p>ODE solver is the major backend we uses for most of the exact quantum  dynamics simulation. The ODE solvers for Bloqade are powered by the <a href="https://diffeq.sciml.ai/">DiffEq.jl package</a>.</p><p>Bloqade provides a special problem type <a href="#BloqadeODE.SchrodingerProblem"><code>SchrodingerProblem</code></a> that supports most of the  <a href="https://diffeq.sciml.ai/stable/basics/integrator/">integrator interface</a> of <code>DiffEq</code>, and most of <a href="https://diffeq.sciml.ai/stable/basics/common_solver_opts/">the solver options</a>. Here we will introduce common use cases of the integrator and solver options. For more advanced usage of the solver, please refer to the above link.</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeODE.SchrodingerProblem" href="#BloqadeODE.SchrodingerProblem"><code>BloqadeODE.SchrodingerProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SchrodingerProblem
SchrodingerProblem(reg, tspan, hamiltonian; kw...)</code></pre><p>Define a Schrodinger equation problem that uses ODE solver from <code>OrdinaryDiffEq</code> to solve the dynamics.</p><p><strong>Arguments</strong></p><ul><li><code>register</code>: required, the evolution problem register, can be a <a href="../registers/#YaoSubspaceArrayReg.SubspaceArrayReg"><code>SubspaceArrayReg</code></a> or an <code>ArrayReg</code>   from <code>Yao</code>.</li><li><code>tspan</code>: required, a <code>(start, stop)</code> tuple or a single number <code>t</code>, the single value form <code>t</code> is equivalent   to <code>(zero(t), t)</code>.</li><li><code>hamiltonian</code>: required, the evolution hamiltonian, can be created via <a href="../hamiltonians/#BloqadeExpr.rydberg_h"><code>rydberg_h</code></a>.</li></ul><p><strong>Common Keyword Arguments</strong></p><ul><li><code>algo</code>: optional, algorithm to use, this only works for the <code>emulate!</code> interface.   for <code>solve</code> or integrator interface, one will need to specify the algorithm explicitly.</li><li><code>progress</code>: print progress bar or not, this may effect the performance when problem scale is small, default is <code>true</code>.</li><li><code>progress_steps</code>: steps to update the progress bar, default is <code>5</code>.</li><li><code>reltol</code>: relative tolerance, default is 1e-8.</li><li><code>abstol</code>: absolute tolerance, default is 1e-8.</li></ul><p><strong>Further References</strong></p><p>For more ODE options, please refer to <a href="https://diffeq.sciml.ai/stable/basics/common_solver_opts/">Common Solver Options</a>. The <code>SchrodingerProblem</code> type supports most of the standard DiffEq problem interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/Bloqade.jl/blob/fd978f65c1cc21a49d3b5c881eab23549d1177e9/lib/BloqadeODE/src/problem.jl#L35-L63">source</a></section></article><h2 id="Run-ODE-based-Emulation"><a class="docs-heading-anchor" href="#Run-ODE-based-Emulation">Run ODE-based Emulation</a><a id="Run-ODE-based-Emulation-1"></a><a class="docs-heading-anchor-permalink" href="#Run-ODE-based-Emulation" title="Permalink"></a></h2><p>To run the emulation, you need to define the exact evolution and solver you would like to run with via <a href="#BloqadeODE.SchrodingerProblem"><code>BloqadeODE.SchrodingerProblem</code></a>, then feed the corresponding object to <code>emulate!</code> function</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeExpr.emulate!" href="#BloqadeExpr.emulate!"><code>BloqadeExpr.emulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emulate!(prob)</code></pre><p>Run emulation of a given problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/Bloqade.jl/blob/fd978f65c1cc21a49d3b5c881eab23549d1177e9/lib/BloqadeExpr/src/interface.jl#L8-L12">source</a></section></article><p>For example, we can simulate quantum dynamics of a time-dependent Hamiltonian by the following codes</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Bloqade</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(SquareLattice(), 3, 3; scale=5.1);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; clocks = [0.0, 0.1, 0.2, 0.3, 0.4];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; wf = piecewise_constant(;clocks, values=[1.0, 2.0, 3.0, 4.0]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = rydberg_h(atoms; Δ=2.0, Ω=wf); # create the Hamiltonian</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = zero_state(length(atoms)); # create fullspace register</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ev = SchrodingerProblem(reg, 0.3, h)</code><code class="nohighlight hljs ansi" style="display:block;">SchrodingerProblem:
  register info:
    type: ArrayReg{2, ComplexF64, Matrix{ComplexF64}}
    storage size: 8 bytes

  time span (μs): (0.0, 0.3)

  equation:
    storage size: 76.016 KiB
    expression:
nqubits: 9
+
├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j
├─ [+] Ω(t) ⋅ ∑ σ^x_i
└─ [-] 2.0 ⋅ ∑ n_i


  options:
    save_everystep: false
    save_start: false
    save_on: false
    dense: false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; emulate!(ev)</code><code class="nohighlight hljs ansi" style="display:block;">SchrodingerProblem:
  register info:
    type: ArrayReg{2, ComplexF64, Matrix{ComplexF64}}
    storage size: 8 bytes

  time span (μs): (0.0, 0.3)

  equation:
    storage size: 76.016 KiB
    expression:
nqubits: 9
+
├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j
├─ [+] Ω(t) ⋅ ∑ σ^x_i
└─ [-] 2.0 ⋅ ∑ n_i


  options:
    save_everystep: false
    save_start: false
    save_on: false
    dense: false</code></pre><p>With the <code>emulate!</code>, the quantum state stored in <code>reg</code> has been updated to the state after the time-evolution. </p><p>In case you want to do operations during the real-time evolution, such as measuring observables, you can instead using the integrator interface with <code>for</code> loop and with <code>TimeChoiceIterator</code> on your desired clocks, e.g</p><pre><code class="language-julia hljs">integrator = init(ev, Vern8())
for _ in TimeChoiceIterator(integrator, [0.1, 0.25])
    ev.reg # state at selected time
    @show measure(ev.reg)[] # measure the state at each time
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(measure(ev.reg))[] = 000000000 ₍₂₎
(measure(ev.reg))[] = 000000001 ₍₂₎</code></pre><p>You can use any function on the <code>reg</code> object.  For calculating observables,  please see the <a href="../observables/#Observables">Observables</a> section.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Remember to make sure your operation does not mutate your state so that this won&#39;t effect the evolution itself, since the entire time evolution is simulated by keep mutating the state vector stored in <code>reg</code> which means do not use any function that has a <code>!</code> in its name on the register <code>info.reg</code> unless you are certain about what you are doing.</p></div></div><h2 id="Choosing-ODE-solver"><a class="docs-heading-anchor" href="#Choosing-ODE-solver">Choosing ODE solver</a><a id="Choosing-ODE-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-ODE-solver" title="Permalink"></a></h2><p>One of the most powerful aspect of Julia ecosystem is the DiffEq ecosystem that implements lots of different solvers. These solvers have different trade-offs. Since simulating many-body Schrodinger equation has some special properties comparing to a general ODE problem, we will discuss some general heurestics in this section on how to choose a good ODE solver and how to check if your emulation converges. Because many-body Schrodinger equation&#39;s stiffness is unknown, we will not be using stiff problem solver, but using non-stiff problem algorithm or auto-switching algorithm.</p><p>Most of the cases one can use <code>VCABM</code> solver for large system simulation. However, this method requires more memory which can be a bottleneck when utilizing GPUs.</p><p>The <code>Vern</code> family is another set of solvers that is good for many-body Schrodinger equation, such as <code>Vern6</code>, <code>Vern7</code> and <code>Vern8</code>, they also have relatively good memory usage when utilize GPUs.</p><p>For more detailed list of solvers please refer to <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Full-List-of-Methods">DiffEq:Full list of solvers</a>. For more detailed explaination on ODE solvers please refer to <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Recommended-Methods">DiffEq:Recommended Methods</a>.</p><p>If you come from MATLAB or Python, you may expecting to compare the same method that you use in MATLAB or Python, you can find the corresponding solvers in Julia in <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Translations-from-MATLAB/Python/R">DiffEq:Translation from MATLAB/Python/R</a>.</p><h2 id="Adaptive-Steps-in-ODE-solver"><a class="docs-heading-anchor" href="#Adaptive-Steps-in-ODE-solver">Adaptive Steps in ODE solver</a><a id="Adaptive-Steps-in-ODE-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Steps-in-ODE-solver" title="Permalink"></a></h2><p>Our ODE solver uses adaptive steps by default. It provides a huge speedup comparing to standard fixed step methods (see <a href="#">our benchmark here</a>). However, if one expects to retreive results during the time evolution, e.g plotting Rydberg density changes with the time, fixed step method should be preferred otherwise the ODE solver will give constant results between each step</p><p>(add @Johnason&#39;s plot on ring emulation here) (add a few examples of how to turn on or turn off the adaptive)</p><p>On the other hand, if one only expects the final state of the evolution, or the interval between each chosen clock is much larger than maximum step size, adaptive step is preferred.</p><h3 id="Define-Krylov-Emulation-Problem"><a class="docs-heading-anchor" href="#Define-Krylov-Emulation-Problem">Define Krylov Emulation Problem</a><a id="Define-Krylov-Emulation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Krylov-Emulation-Problem" title="Permalink"></a></h3><p>The Krylov-based method expects time independent Hamiltonians, one can define such evolution via <a href="#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a> object.</p><article class="docstring"><header><a class="docstring-binding" id="BloqadeKrylov.KrylovEvolution" href="#BloqadeKrylov.KrylovEvolution"><code>BloqadeKrylov.KrylovEvolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct KrylovEvolution
KrylovEvolution(reg::AbstractRegister, clocks, h; kw...)</code></pre><p>Create a <code>KrylovEvolution</code> object that describes a time evolution using Krylov subspace methods.</p><p><strong>Arguments</strong></p><ul><li><code>reg</code>: a register, should be a subtype of <code>AbstractRegister</code>.</li><li><code>clocks</code>: the clocks of this time evolution at each step.</li><li><code>h</code>: a hamiltonian expression.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>progress</code>: show progress bar, default is <code>false</code>.</li><li><code>progress_name</code>: progress bar name, default is <code>&quot;emulating&quot;</code>.</li><li><code>normalize_step</code>: normalize the state every <code>normalize_step</code>.</li><li><code>normalize_finally</code>: wether normalize the state in the end of evolution, default is <code>true</code>.</li><li><code>tol</code>: tolerance of the Krylov method, default is <code>1e-7</code></li></ul><p><strong>Examples</strong></p><p>The following is the simplest way of using <code>KrylovEvolution</code> via <a href="#BloqadeExpr.emulate!"><code>emulate!</code></a>. For more advanced usage, please refer to documentation page <a href="#emulation">Emulation</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Bloqade

julia&gt; r = zero_state(5)
ArrayReg{2, ComplexF64, Array...}
    active qudits: 5/5
    nlevel: 2

julia&gt; atoms = [(i, ) for i in 1:5]
5-element Vector{Tuple{Int64}}:
 (1,)
 (2,)
 (3,)
 (4,)
 (5,)

julia&gt; h = rydberg_h(atoms; Ω=sin)
nqubits: 5
+
├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j
└─ [+] Ω(t) ⋅ ∑ σ^x_i


julia&gt; prob = KrylovEvolution(r, 0.0:1e-2:0.1, h);

julia&gt; emulate!(prob); # run the emulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/Bloqade.jl/blob/fd978f65c1cc21a49d3b5c881eab23549d1177e9/lib/BloqadeKrylov/src/emulate.jl#L15-L69">source</a></section></article><h2 id="Run-Krylov-based-Emulation"><a class="docs-heading-anchor" href="#Run-Krylov-based-Emulation">Run Krylov-based Emulation</a><a id="Run-Krylov-based-Emulation-1"></a><a class="docs-heading-anchor-permalink" href="#Run-Krylov-based-Emulation" title="Permalink"></a></h2><p>We can run the Krylov-based emulation in a similar way using <a href="#BloqadeExpr.emulate!"><code>emulate!</code></a></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; emulate!(KrylovEvolution(reg, clocks, h))</code><code class="nohighlight hljs ansi" style="display:block;">KrylovEvolution{ArrayReg{2, ComplexF64, Matrix{ComplexF64}}, Float64, BloqadeExpr.Hamiltonian{Tuple{BloqadeExpr.var&quot;#121#124&quot;{Waveform{BloqadeWaveforms.PiecewiseConstant{Float64}, Float64}}, typeof(one)}, Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, LinearAlgebra.Diagonal{Float64, Vector{Float64}}}}}(ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2, 0.0, [0.1, 0.1, 0.09999999999999998, 0.10000000000000003], BloqadeExpr.Hamiltonian{Tuple{BloqadeExpr.var&quot;#121#124&quot;{Waveform{BloqadeWaveforms.PiecewiseConstant{Float64}, Float64}}, typeof(one)}, Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, LinearAlgebra.Diagonal{Float64, Vector{Float64}}}}((BloqadeExpr.var&quot;#121#124&quot;{Waveform{BloqadeWaveforms.PiecewiseConstant{Float64}, Float64}}(Waveform(_, 0.4)), one), (sparse([2, 3, 5, 9, 17, 33, 65, 129, 257, 1  …  512, 256, 384, 448, 480, 496, 504, 508, 510, 511], [1, 1, 1, 1, 1, 1, 1, 1, 1, 2  …  511, 512, 512, 512, 512, 512, 512, 512, 512, 512], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 512, 512), [0.0 0.0 … 0.0 0.0; 0.0 -2.0 … 0.0 0.0; … ; 0.0 0.0 … 3368.625412778115 0.0; 0.0 0.0 … 0.0 4036.3769071142156])), BloqadeKrylov.KrylovOptions(false, 1, &quot;emulating&quot;, 5, true, 1.0e-7))</code></pre><p>However, as its name points out, the Krylov-based emulation is not a standard ODE problem that DiffEq  supports, thus it does not support the ODE problem interface, but a more gate-like interface, e.g the object <code>KrylovEvolution</code> is iterable</p><pre><code class="language-julia hljs">for (step, reg, duration) in KrylovEvolution(reg, clocks, h)
    @show step
    @show reg
    @show duration
    println(&quot;==========&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">step = 1
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.1
==========
step = 2
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.1
==========
step = 3
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.09999999999999998
==========
step = 4
reg = ArrayReg{2, ComplexF64, Array...}
    active qubits: 9/9
    nlevel: 2
duration = 0.10000000000000003
==========</code></pre><h2 id="Krylov-vs-ODE-solver"><a class="docs-heading-anchor" href="#Krylov-vs-ODE-solver">Krylov vs ODE solver</a><a id="Krylov-vs-ODE-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-vs-ODE-solver" title="Permalink"></a></h2><p>The <a href="#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a> uses Krylov subspace methods to simulate the time evolution as discrete time-independent time evolution operators <span>$\\exp(i\Delta t_i H(t))$</span>, where <span>$\Delta t_i$</span> is the duration of time-independent Hamiltonian <span>$H(t)$</span> at time <span>$t$</span>. This method is more efficient when the evolution itself is a discrete evolution, e.g QAOA, <a href="../waveform/#BloqadeWaveforms.piecewise_constant"><code>piecewise_constant</code></a> waveform. As for other cases, ODE solvers are usually more efficient than <a href="#BloqadeKrylov.KrylovEvolution"><code>KrylovEvolution</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../registers/">« Registers</a><a class="docs-footer-nextpage" href="../subspace/">Working with Subspace »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Friday 15 April 2022 04:08">Friday 15 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
