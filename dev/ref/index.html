<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · EaRyd.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Happy-Diode.github.io/EaRyd.jl/ref/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">EaRyd.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><a class="tocitem" href="../registry/">Setting Up Company Registry</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/quantum-scar/">Quantum Scar</a></li><li><a class="tocitem" href="../tutorials/adiabatic/">Adiabatic Evolution</a></li><li><a class="tocitem" href="../tutorials/qaoa/">Quantum Approximate Optimization Algorithm</a></li></ul></li><li class="is-active"><a class="tocitem" href>References</a><ul class="internal"><li><a class="tocitem" href="#EaRyd"><span>EaRyd</span></a></li><li><a class="tocitem" href="#EaRydCore"><span>EaRydCore</span></a></li><li><a class="tocitem" href="#EaRydODE"><span>EaRydODE</span></a></li><li><a class="tocitem" href="#EaRydWaveforms"><span>EaRydWaveforms</span></a></li><li><a class="tocitem" href="#EaRydLattices"><span>EaRydLattices</span></a></li><li><a class="tocitem" href="#EaRydPlots"><span>EaRydPlots</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Happy-Diode/EaRyd.jl/blob/master/docs/src/ref.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><h2 id="EaRyd"><a class="docs-heading-anchor" href="#EaRyd">EaRyd</a><a id="EaRyd-1"></a><a class="docs-heading-anchor-permalink" href="#EaRyd" title="Permalink"></a></h2><h2 id="EaRydCore"><a class="docs-heading-anchor" href="#EaRydCore">EaRydCore</a><a id="EaRydCore-1"></a><a class="docs-heading-anchor-permalink" href="#EaRydCore" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.fullspace" href="#EaRydCore.fullspace"><code>EaRydCore.fullspace</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">fullspace</code></pre><p>A constant for the <a href="#EaRydCore.FullSpace"><code>FullSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.AbstractAtom" href="#EaRydCore.AbstractAtom"><code>EaRydCore.AbstractAtom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAtom</code></pre><p>Abstract type for atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.AbstractSpace" href="#EaRydCore.AbstractSpace"><code>EaRydCore.AbstractSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSpace</code></pre><p>Abstract type for spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.AbstractTerm" href="#EaRydCore.AbstractTerm"><code>EaRydCore.AbstractTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTerm</code></pre><p>Abstract term for hamiltonian terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.Atom2D" href="#EaRydCore.Atom2D"><code>EaRydCore.Atom2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Atom2D{T} = RydAtom{2,T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.FullSpace" href="#EaRydCore.FullSpace"><code>EaRydCore.FullSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FullSpace &lt;: AbstractSpace</code></pre><p>A trait for the full space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.KrylovEmulationCache" href="#EaRydCore.KrylovEmulationCache"><code>EaRydCore.KrylovEmulationCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KrylovEmulationCache{C}</code></pre><p>Cache type for the discrete emulation, type variable <code>C</code> is the actual matrix type for the hamiltonian storage.</p><p>When we do Krylov subspace based time evolution emulation with a sequence of hamiltonians of similar terms, e.g all the hamiltonians are <code>RydInteract + XTerm + ZTerm</code>, the sparse structure will be the same, thus we can re-use the sparse matrix generated for the first hamiltonian again via <a href="#EaRydCore.update_term!"><code>update_term!</code></a> in the following calculation to reduce the memory usage and speed up the emulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/emulate/types.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.KrylovEmulationCache-Union{Tuple{Ti}, Tuple{Tv}, Tuple{EaRydCore.AbstractTerm, EaRydCore.AbstractSpace}} where {Tv, Ti}" href="#EaRydCore.KrylovEmulationCache-Union{Tuple{Ti}, Tuple{Tv}, Tuple{EaRydCore.AbstractTerm, EaRydCore.AbstractSpace}} where {Tv, Ti}"><code>EaRydCore.KrylovEmulationCache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KrylovEmulationCache{Tv, Ti}(hs[, s::AbstractSpace=fullspace])</code></pre><p>Create a <code>KrylovEmulationCache</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: element type of the storage.</li><li><code>hs</code>: a Hamiltonian expression term or a list of Hamiltonians.</li><li><code>s</code>: space type, default is <a href="#EaRydCore.fullspace"><code>fullspace</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/emulate/types.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.KrylovEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Vector{&lt;:Real}, Vector{&lt;:EaRydCore.AbstractTerm}}} where P" href="#EaRydCore.KrylovEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Vector{&lt;:Real}, Vector{&lt;:EaRydCore.AbstractTerm}}} where P"><code>EaRydCore.KrylovEvolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KrylovEvolution{P}(register, durations, hs; kw...)</code></pre><p>Create a <code>KrylovEvolution</code> object that emulates a list of hamiltonians at discrete time steps using Krylov subspace method, or trotterize a continuous function with <code>dt</code> then run the trotterize integrator on it.</p><p><strong>Arguments</strong></p><ul><li><code>P</code>: optional, a type parameter that sets the problem precision type, default is   the same as the <code>Yao.datatype</code> of given <code>register</code>.</li><li><code>register</code>: required, the evolution problem register, can be a <a href="#EaRydCore.RydbergReg-Tuple{AbstractMatrix{&lt;:Real}, Subspace}"><code>RydbergReg</code></a> or an <code>ArrayReg</code>   from <code>Yao</code>.</li><li><code>durations</code>: required, the evolution durations of each hamiltonian, should be a list of real numbers.</li><li><code>hs</code>: required, the evolution hamiltonian, a list of hamiltonians with constant parameters.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>cache</code>: discrete solver cache, see also <a href="#EaRydCore.KrylovEmulationCache"><code>KrylovEmulationCache</code></a>.</li><li><code>normalize_step::Int</code>: run normalization per <code>normalize_step</code>, default is <code>5</code>.</li><li><code>normalize_finally::Bool</code>: normalize the state after the entire emulation ends, default is <code>true</code>.</li><li><code>progress::Bool</code>: show progress bar, default is <code>false</code>.</li><li><code>progress_step::Int</code>: update the progress bar per <code>progress_step</code>, default is <code>1</code>.</li><li><code>progress_name::String</code>: the printed name on progress bar, default is <code>&quot;emulating&quot;</code>.</li><li><code>dt::Real</code>: the time step of trotterization if <code>ts</code> is specified as   a <code>Real</code> number and <code>hs</code> is a time dependent hamiltonian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/emulate/types.jl#L62-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.NTerm" href="#EaRydCore.NTerm"><code>EaRydCore.NTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NTerm{Delta} &lt;: AbstractTerm
NTerm(nsites, Δs::Delta)</code></pre><p>Type for N term</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ_i n_i\]</p><p><strong>Parameters</strong></p><ul><li><code>Δs</code>: the detuning parameter, the default unit is <code>MHz</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L170-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.NTerm-Tuple{AbstractVector}" href="#EaRydCore.NTerm-Tuple{AbstractVector}"><code>EaRydCore.NTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NTerm(Δs::AbstractVector)</code></pre><p>Create a simple <code>NTerm</code> from given <code>Δs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.RydAtom" href="#EaRydCore.RydAtom"><code>EaRydCore.RydAtom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RydAtom{N,T} &lt;: AbstractAtom</code></pre><p>Position of one Rydberg atom.</p><pre><code class="nohighlight hljs">RydAtom(locs::NTuple{N, T})</code></pre><p>Create a position of one Rydberg atom. The default unit is <code>μm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.RydAtom-Tuple" href="#EaRydCore.RydAtom-Tuple"><code>EaRydCore.RydAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RydAtom(locations...)</code></pre><p>Create a <code>RydAtom</code> from given locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.RydAtom-Tuple{AbstractVector}" href="#EaRydCore.RydAtom-Tuple{AbstractVector}"><code>EaRydCore.RydAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RydAtom(locations::Vector)</code></pre><p>Create a <code>RydAtom</code> from given list of locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.RydInteract" href="#EaRydCore.RydInteract"><code>EaRydCore.RydInteract</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RydInteract{T&lt;:Number, AtomList &lt;: AbstractVector{&lt;:RydAtom}} &lt;: AbstractTerm
RydInteract(atoms::AbstractVector{&lt;:RydAtom}, C::Number)</code></pre><p>Type for Rydberg interactive term.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_{i, j} \frac{C}{|r_i - r_j|^6} n_i n_j\]</p><p><strong>Parameters</strong></p><ul><li><code>atoms</code>: a list of atom positions, must be type <code>RydAtom</code>, default unit is <code>μm</code>.</li><li><code>C</code>: the interaction strength, default unit is <code>MHz⋅μm^6</code>. default value is <code>2π * 858386 * MHz*µm^6</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L67-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.RydbergReg-Tuple{AbstractMatrix{&lt;:Real}, Subspace}" href="#EaRydCore.RydbergReg-Tuple{AbstractMatrix{&lt;:Real}, Subspace}"><code>EaRydCore.RydbergReg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RydbergReg(state::AbstractMatrix, subspace::Subspace)</code></pre><p>Create a <code>RydbergReg</code> from real value storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/register.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.RydbergReg-Union{Tuple{N}, Tuple{AbstractVector, Subspace}} where N" href="#EaRydCore.RydbergReg-Union{Tuple{N}, Tuple{AbstractVector, Subspace}} where N"><code>EaRydCore.RydbergReg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RydbergReg(state::AbstractVector, subspace::Subspace)</code></pre><p>Create a <code>RydbergReg</code> from state vector and its corresponding subspace of <code>natoms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/register.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.Subspace" href="#EaRydCore.Subspace"><code>EaRydCore.Subspace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Subspace{S &lt;: AbstractVector{Int}} &lt;: AbstractSpace</code></pre><p>A <code>Dict</code>-like object stores the mapping between subspace and full space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.Subspace-Tuple{Int64, AbstractVector{Int64}}" href="#EaRydCore.Subspace-Tuple{Int64, AbstractVector{Int64}}"><code>EaRydCore.Subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Subspace(nqubits::Int, subspace_v::AbstractVector{Int})</code></pre><p>Create a Subspace from given list of subspace indices in the corresponding full space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.XTerm" href="#EaRydCore.XTerm"><code>EaRydCore.XTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XTerm{Omega, Phi} &lt;: AbstractTerm
XTerm(nsites::Int, Ωs::Omega, ϕs::Phi)</code></pre><p>Type for X term.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_{i} Ω_i (e^{iϕ_i} |0⟩_i⟨1| + e^{-iϕ_i}|1⟩_i⟨0|)\]</p><p><strong>Parameters</strong></p><ul><li><code>Ω</code>: rabi-frequency, the default unit for <code>Ωs</code> is <code>MHz</code></li><li><code>ϕs</code> phase, has no unit (or <code>NoUnits</code> in <code>Unitful</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L100-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.XTerm-Tuple{AbstractVector, AbstractVector}" href="#EaRydCore.XTerm-Tuple{AbstractVector, AbstractVector}"><code>EaRydCore.XTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XTerm(Ωs::AbstractVector, ϕs::AbstractVector)</code></pre><p>Create the <code>XTerm</code> from given <code>Ωs</code> and <code>ϕs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.XTerm-Tuple{AbstractVector, Any}" href="#EaRydCore.XTerm-Tuple{AbstractVector, Any}"><code>EaRydCore.XTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XTerm(Ωs::AbstractVector, ϕs::Number)</code></pre><p>Create the <code>XTerm</code> from given <code>Ωs</code> and <code>ϕs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.XTerm-Tuple{AbstractVector}" href="#EaRydCore.XTerm-Tuple{AbstractVector}"><code>EaRydCore.XTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XTerm(n::Int, Ωs::AbstractVector)</code></pre><p>Create a simple <code>XTerm</code> from given <code>Ωs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.XTerm-Tuple{Any, AbstractVector}" href="#EaRydCore.XTerm-Tuple{Any, AbstractVector}"><code>EaRydCore.XTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XTerm(Ωs::Number, ϕs::AbstractVector)</code></pre><p>Create the <code>XTerm</code> from given <code>Ωs</code> and <code>ϕs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.XTerm-Tuple{Int64, Any}" href="#EaRydCore.XTerm-Tuple{Int64, Any}"><code>EaRydCore.XTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XTerm(n::Int, Ω::Number)</code></pre><p>Create a simple <code>XTerm</code> from given number of atoms <code>n</code> and <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.ZTerm" href="#EaRydCore.ZTerm"><code>EaRydCore.ZTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZTerm{Delta} &lt;: AbstractTerm
ZTerm(nsites, Δs::Delta)</code></pre><p>Type for Z term.</p><p><strong>Expression</strong></p><p class="math-container">\[\sum_i Δ_iσ_i^z\]</p><p><strong>Parameters</strong></p><ul><li><code>Δs</code>: the detuning parameter, the default unit is <code>MHz</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L138-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.ZTerm-Tuple{AbstractVector}" href="#EaRydCore.ZTerm-Tuple{AbstractVector}"><code>EaRydCore.ZTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ZTerm(Δs::AbstractVector)</code></pre><p>Create a simple <code>ZTerm</code> from given <code>Δs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.add_random_vertices" href="#EaRydCore.add_random_vertices"><code>EaRydCore.add_random_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_random_vertices([rng=GLOBAL_RNG], config::AbstractVector, graph::AbstractGraph, ntrials::Int = 10)</code></pre><p>Add vertices randomly to given configuration for <code>ntrials</code> times and pick the one that has largest <a href="#EaRydCore.count_vertices-Tuple{Integer}"><code>count_vertices</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: optional, Random Number Generator.</li><li><code>config</code>: configuration to tweak.</li><li><code>graph</code>: problem graph.</li><li><code>ntrials</code>: number of trials to use, default is <code>10</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L247-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.anyone-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#EaRydCore.anyone-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>EaRydCore.anyone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anyone(index::Integer, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if any masked position of index is 1.</p><p><strong>Example</strong></p><p><code>true</code> if any masked positions is 1.</p><pre><code class="language-julia-repl hljs">julia&gt; anyone(0b1011, 0b1001)
true
julia&gt; anyone(0b1011, 0b1100)
true
julia&gt; anyone(0b1011, 0b0100)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/bsubspace.jl#L33-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.blockade_subspace" href="#EaRydCore.blockade_subspace"><code>EaRydCore.blockade_subspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blockade_subspace(atoms[, radius=1.0])</code></pre><p>Create a blockade approximation subspace from given atom positions and radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.bmask" href="#EaRydCore.bmask"><code>EaRydCore.bmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bmask(::Type{T}) where T &lt;: Integer -&gt; zero(T)
bmask([T::Type], positions::Int...) -&gt; T
bmask([T::Type], range::UnitRange{Int}) -&gt; T</code></pre><p>Return an integer mask of type <code>T</code> where <code>1</code> is the position masked according to <code>positions</code> or <code>range</code>. Directly use <code>T</code> will return an empty mask <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/bsubspace.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.count_vertices-Tuple{Integer}" href="#EaRydCore.count_vertices-Tuple{Integer}"><code>EaRydCore.count_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_vertices(config::Integer)</code></pre><p>counter the number of vertices in a spin configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.create_subspace_from_mis-Tuple{Int64, AbstractVector}" href="#EaRydCore.create_subspace_from_mis-Tuple{Int64, AbstractVector}"><code>EaRydCore.create_subspace_from_mis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_subspace_from_mis(n::Int, mis::AbstractVector)</code></pre><p>Create <code>Subspace</code> from given list of maximal cliques/maximal independent set.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: number of vertices of the graph.</li><li><code>mis</code>: the list of maximal independent set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L112-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.distance-Tuple{RydAtom, RydAtom}" href="#EaRydCore.distance-Tuple{RydAtom, RydAtom}"><code>EaRydCore.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(a::RydAtom, b::RydAtom)</code></pre><p>Return the distance between two Rydberg atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.emulate!" href="#EaRydCore.emulate!"><code>EaRydCore.emulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emulate!(evolution)</code></pre><p>Run emulation on given evolution object. See also <a href="#EaRydCore.KrylovEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Vector{&lt;:Real}, Vector{&lt;:EaRydCore.AbstractTerm}}} where P"><code>KrylovEvolution</code></a>, or <a href="@ref"><code>ContinousEvolution</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>evolution</code>: the evolution object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/emulate/interface.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.emulate_step!" href="#EaRydCore.emulate_step!"><code>EaRydCore.emulate_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emulate_step!(prob::KrylovEvolution, step::Int=1)</code></pre><p>Run single step evolution at given <code>step</code> index for a discrete evolution (Krylov-based).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/emulate/interface.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.exact_solve_mis-Tuple{Graphs.AbstractGraph}" href="#EaRydCore.exact_solve_mis-Tuple{Graphs.AbstractGraph}"><code>EaRydCore.exact_solve_mis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exact_solve_mis(g::AbstractGraph)</code></pre><p>Return the exact MIS size of a graph <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.expmv-Union{Tuple{T}, Tuple{Number, Any, Vector{T}}} where T" href="#EaRydCore.expmv-Union{Tuple{T}, Tuple{Number, Any, Vector{T}}} where T"><code>EaRydCore.expmv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expmv(t, A, vec; [tol], [m], [norm], [anorm])</code></pre><p>Calculate matrix exponential acting on some vector, <span>$w = e^{tA}v$</span>, using the Krylov subspace approximation. See R.B. Sidje, ACM Trans. Math. Softw., 24(1):130-156, 1998 and http://www.maths.uq.edu.au/expokit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/expmv.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.getterm" href="#EaRydCore.getterm"><code>EaRydCore.getterm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getterm(terms, k, k_site)</code></pre><p>Get the value of k-th local term in <code>terms</code> given the site configuration as <code>k_site</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L515-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.gibbs_loss-Tuple{Any, Real}" href="#EaRydCore.gibbs_loss-Tuple{Any, Real}"><code>EaRydCore.gibbs_loss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gibbs_loss([f], reg_or_samples, α::Real)</code></pre><p>The Gibbs loss for maximum independent set defined as</p><p class="math-container">\[L = -1/α \log(\langle ψ|\exp(α \sum(n))|ψ\rangle),\]</p><p>where <code>n</code> is the vertex set size.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: optional, postprocessing callback function <code>f(config) -&gt; config</code>.   The input <code>config</code> is an integer of type <code>Int</code>, the output   <code>config</code> can be a type supports <a href="#EaRydCore.count_vertices-Tuple{Integer}"><code>count_vertices</code></a>   e.g, an <code>AbstractVector</code> or an <code>Integer</code>.</li><li><code>reg_or_samples</code> can be a register (<code>Yao.ArrayReg</code> or <a href="#EaRydCore.RydbergReg-Tuple{AbstractMatrix{&lt;:Real}, Subspace}"><code>RydbergReg</code></a>)   or a list of measurement result (config) in <code>AbstractVector</code>.</li><li><code>α::Real</code>: the parameter of Gibbs loss.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L126-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.independent_set_probabilities" href="#EaRydCore.independent_set_probabilities"><code>EaRydCore.independent_set_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">independent_set_probabilities([f], reg::Yao.AbstractRegister, graph_or_mis)</code></pre><p>Calculate the probabilities of independent sets with given postprocessing function <code>f(config) -&gt; config</code>. The default postprocessing function <code>f</code> will only reduce all configurations to independent set.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: optional, postprocessing function, default is <a href="@ref"><code>to_independent_set</code></a>.</li><li><code>reg</code>: required, the register object.</li><li><code>graph_or_mis</code>: a problem graph or the MIS size of the problem   graph (can be calculated via <a href="#EaRydCore.exact_solve_mis-Tuple{Graphs.AbstractGraph}"><code>exact_solve_mis</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L315-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.independent_set_subspace-Tuple{Graphs.SimpleGraphs.SimpleGraph}" href="#EaRydCore.independent_set_subspace-Tuple{Graphs.SimpleGraphs.SimpleGraph}"><code>EaRydCore.independent_set_subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">independent_set_subspace(graph)</code></pre><p>Create a subspace from given graph&#39;s maximal independent set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/subspace.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.is_independent_set-Tuple{Any, Graphs.AbstractGraph}" href="#EaRydCore.is_independent_set-Tuple{Any, Graphs.AbstractGraph}"><code>EaRydCore.is_independent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_independent_set(config, graph::AbstractGraph)</code></pre><p>Return <code>true</code> if <code>config</code> is an independent set of graph. <code>config</code> can be a <code>BitStr</code>, a vector, or any iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.is_time_dependent-Tuple{Hamiltonian}" href="#EaRydCore.is_time_dependent-Tuple{Hamiltonian}"><code>EaRydCore.is_time_dependent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_time_dependent(h::Hamiltonian)</code></pre><p>Check if a hamiltonian is time-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L861-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer" href="#EaRydCore.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>EaRydCore.ismatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismatch(index::Integer, mask::Integer, target::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if bits at positions masked by <code>mask</code> equal to <code>1</code> are equal to <code>target</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; n = 0b11001; mask = 0b10100; target = 0b10000;

julia&gt; ismatch(n, mask, target)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/bsubspace.jl#L49-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.mean_rydberg" href="#EaRydCore.mean_rydberg"><code>EaRydCore.mean_rydberg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mean_rydberg([f], reg_or_samples)</code></pre><p>Mean size of vertex set.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: optional, postprocessing callback function <code>f(config) -&gt; config</code>.   The input <code>config</code> is an integer of type <code>Int</code>, the output   <code>config</code> can be a type supports <a href="#EaRydCore.count_vertices-Tuple{Integer}"><code>count_vertices</code></a>   e.g, an <code>AbstractVector</code> or an <code>Integer</code>.</li><li><code>reg_or_samples</code> can be a register (<code>Yao.ArrayReg</code> or <a href="#EaRydCore.RydbergReg-Tuple{AbstractMatrix{&lt;:Real}, Subspace}"><code>RydbergReg</code></a>)   or a list of measurement result (config) in <code>AbstractVector</code>.</li></ul><p><strong>Example</strong></p><p>To implement the postprocessing protocal in MIS experiment:</p><ol><li>calculating <code>mean_rydberg</code> by first reducing the configuration</li></ol><p>to independent set using <a href="@ref"><code>to_independent_set</code></a></p><ol><li>randomly adding vertices then pick the largest <a href="#EaRydCore.count_vertices-Tuple{Integer}"><code>count_vertices</code></a></li></ol><p>using <a href="#EaRydCore.add_random_vertices"><code>add_random_vertices</code></a>.</p><pre><code class="language-julia hljs">mean_rydberg(r) do config
    config = to_independent_set(config, graph)
    add_random_vertices(config, graph, 10)
    return config
end</code></pre><p>Or one can also just add vertice by atom order</p><pre><code class="language-julia hljs">mean_rydberg(r) do config
    config = to_independent_set(config, graph)
    add_vertices!(config, graph)
    return config
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L9-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}" href="#EaRydCore.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}"><code>EaRydCore.mis_postprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mis_postprocessing(config, graph::AbstractGraph; ntrials::Int=10)</code></pre><p>The postprocessing protocal used in Harvard.</p><p><strong>Arguments</strong></p><ul><li><code>config</code>: configuration to postprocess.</li><li><code>graph</code>: the problem graph.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ntrials</code>: number of trials to use.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L357-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.mis_postprocessing-Tuple{Graphs.AbstractGraph}" href="#EaRydCore.mis_postprocessing-Tuple{Graphs.AbstractGraph}"><code>EaRydCore.mis_postprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mis_postprocessing(graph::AbstractGraph; ntrials::Int = 10)</code></pre><p>Curried version of <a href="#EaRydCore.mis_postprocessing-Tuple{Any, Graphs.AbstractGraph}"><code>mis_postprocessing</code></a>.</p><p><strong>Example</strong></p><p>to calculate <code>mean_rydberg</code> loss with postprocessing used in Harvard experiment.</p><pre><code class="language-julia hljs">mean_rydberg(mis_postprocessing(graph), reg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L377-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.nsites" href="#EaRydCore.nsites"><code>EaRydCore.nsites</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsites(term)</code></pre><p>Return the number of sites of given Hamiltonian term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}" href="#EaRydCore.num_mis_violation-Tuple{Any, Graphs.AbstractGraph, Int64}"><code>EaRydCore.num_mis_violation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_mis_violation(config, graph::AbstractGraph, i::Int)</code></pre><p>Calculate the number of MIS violations for <code>i</code>-th vertex in <code>graph</code> and configuration <code>config</code>. The <code>config</code> should be a subtype of <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.rand_atoms-Tuple{Int64, Float64}" href="#EaRydCore.rand_atoms-Tuple{Int64, Float64}"><code>EaRydCore.rand_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_atoms(n::Int, ρ::Float64; ndims::Int=2)</code></pre><p>Create a random atom position of <code>n</code> atoms and with density <code>ρ</code> in <code>ndims</code> space. The size of the box is <span>$L^ndims$</span>, where the linear dimension <span>$L = (n/ρ)^(1/ndims)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.rand_unit_disk_graph-Tuple{Int64, Real}" href="#EaRydCore.rand_unit_disk_graph-Tuple{Int64, Real}"><code>EaRydCore.rand_unit_disk_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_unit_disk_graph(natoms::Int, ρ::Real)</code></pre><p>Generate a random disk graph.</p><ul><li><code>ρ</code> is defined as <code>n</code>/L^2, where L is the box size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/unit_disk.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.read_atoms-Tuple{String, Vararg{Any}}" href="#EaRydCore.read_atoms-Tuple{String, Vararg{Any}}"><code>EaRydCore.read_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_atoms(filename[, T=Int])</code></pre><p>Read atom positions from file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.read_atoms-Union{Tuple{T}, Tuple{IO, Type{T}}} where T" href="#EaRydCore.read_atoms-Union{Tuple{T}, Tuple{IO, Type{T}}} where T"><code>EaRydCore.read_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_atoms(io::IO[, T=Int])</code></pre><p>Read atom positions from stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.read_subspace-Tuple{AbstractString}" href="#EaRydCore.read_subspace-Tuple{AbstractString}"><code>EaRydCore.read_subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_subspace(filename::AbstractString)</code></pre><p>Read <code>Subspace</code> from a file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.read_subspace-Tuple{IO}" href="#EaRydCore.read_subspace-Tuple{IO}"><code>EaRydCore.read_subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_subspace(io::IO)</code></pre><p>Read <code>Subspace</code> from given <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.rydatoms-Tuple{AbstractMatrix}" href="#EaRydCore.rydatoms-Tuple{AbstractMatrix}"><code>EaRydCore.rydatoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rydatoms(::AbstractMatrix)</code></pre><p>Create a list of <a href="#EaRydCore.RydAtom"><code>RydAtom</code></a>s from a nx2 location matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.rydberg_h-Tuple{Any}" href="#EaRydCore.rydberg_h-Tuple{Any}"><code>EaRydCore.rydberg_h</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rydberg_h(atoms; [C=2π * 858386 * MHz*µm^6], Ω[, ϕ, Δ])</code></pre><p>Create a rydberg hamiltonian</p><p class="math-container">\[∑ \frac{C}{|r_i - r_j|^6} n_i n_j + \frac{Ω}{2} σ_x - Δ σ_n\]</p><p>shorthand for</p><pre><code class="language-julia hljs">RydInteract(C, atoms) + XTerm(length(atoms), Ω, ϕ) + ZTerm(length(atoms), Δ)</code></pre><p><strong>Arguments</strong></p><ul><li><code>atoms</code>: a collection of atom positions</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>C</code>: optional, default unit is <code>MHz*µm^6</code>, interation parameter,   see also <a href="#EaRydCore.RydInteract"><code>RydInteract</code></a>.</li><li><code>Ω</code>: required, default unit is <code>MHz</code>, Rabi frequencies, see <a href="#EaRydCore.XTerm"><code>XTerm</code></a>.</li><li><code>Δ</code>: optional, default unit is <code>MHz</code>, detuning parameter, see <a href="#EaRydCore.NTerm"><code>NTerm</code></a>.</li><li><code>ϕ</code>: optional, does not have unit, the phase, see <a href="#EaRydCore.XTerm"><code>XTerm</code></a>.</li></ul><div class="admonition is-category-tips"><header class="admonition-header">Tips</header><div class="admonition-body"><p>The parameters of Hamiltonian have their own default units to match hardware, one can use <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.jl</code></a> to specify their units explicitly. If the units are specified explicitly, they will be converted to default units automatically.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using EaRyd

julia&gt; atoms = generate_sites(SquareLattice(), 3, 3);

julia&gt; rydberg_h(atoms; Δ=1.2, Ω=1.1)
Hamiltonian
  Term 1
   ∑(n=1:9) 1.1/2 σ^x

  Term 2
   -∑(n=1:9) 1.2 n

  Term 3
   ∑(n=1:9) 686.0/|r_i - r_j|^6 n_i n_j</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rydberg_h(atoms; Δ=1.2, Ω=1.1, ϕ=2.1)
Hamiltonian
  Term 1
   ∑(n=1:9) 1.1/2 (e^{2.1i}|0)⟨1| + e^{-2.1i}|1⟩⟨0|)

  Term 2
   -∑(n=1:9) 1.2 n

  Term 3
   ∑(n=1:9) 686.0/|r_i - r_j|^6 n_i n_j</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L753-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.set_zero_state!" href="#EaRydCore.set_zero_state!"><code>EaRydCore.set_zero_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_zero_state!(register)</code></pre><p>Set the given register to |00...00⟩.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/register.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.simple_rydberg-Tuple{Int64, Number}" href="#EaRydCore.simple_rydberg-Tuple{Int64, Number}"><code>EaRydCore.simple_rydberg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simple_rydberg(n::Int, ϕ::Number)</code></pre><p>Create a simple rydberg hamiltonian that has only <a href="#EaRydCore.XTerm"><code>XTerm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L737-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.sort_atoms!-Tuple{Vector{&lt;:RydAtom}}" href="#EaRydCore.sort_atoms!-Tuple{Vector{&lt;:RydAtom}}"><code>EaRydCore.sort_atoms!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_atoms!(atoms; by=nothing)</code></pre><p>Sort a list of atom positions. Sort by coordinates if <code>by</code> is <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.square_lattice-Tuple{Int64, Float64}" href="#EaRydCore.square_lattice-Tuple{Int64, Float64}"><code>EaRydCore.square_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_lattice(n::Int, ff::Float64)</code></pre><p>Create a list of Rydberg atoms on a square lattice with given size <code>n</code> and filling factor <code>ff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/atoms.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.term_value" href="#EaRydCore.term_value"><code>EaRydCore.term_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">term_value(term, lhs, rhs, col, row)</code></pre><p>Return the value of given term at <code>H[col, row]</code> with left basis <code>lhs</code> and right basis <code>rhs</code>. For full space, <code>lhs = col - 1</code> and <code>rhs = row - 1</code>, for subspace, <code>lhs = subspace_v[col]</code> and <code>rhs = subspace_v[row]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L677-L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}" href="#EaRydCore.to_independent_set!-Tuple{AbstractVector, Graphs.AbstractGraph}"><code>EaRydCore.to_independent_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_independent_set!(config::AbstractVector, graph::AbstractGraph)</code></pre><p>Eliminate vertices in <code>config</code> so that remaining vertices do not have connected edges. This algorithm is a naive vertex elimination that does not nesesarily give the maximum possible vertex set.</p><pre><code class="language- hljs"># run the following code in Atom/VSCode
atoms = RydAtom.([(0.0, 1.0), (1.0, 0.), (2.0, 0.0),
    (1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])
graph = unit_disk_graph(atoms, 1.5)

config = [1, 1, 1, 0, 1, 1]
viz_config(atoms, graph, config)

to_independent_set!(config, graph)
viz_config(atoms, graph, config)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/mis.jl#L187-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.trotterize-Tuple{Real, Real, EaRydCore.AbstractTerm}" href="#EaRydCore.trotterize-Tuple{Real, Real, EaRydCore.AbstractTerm}"><code>EaRydCore.trotterize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trotterize([start::Real=0], stop::Real, h::AbstractTerm; nsteps::Int=1000)</code></pre><p>Trotterize time evolution of hamiltonian <code>h</code>. Each trotterize step uses the first value of the interval as the clock to get <code>h(t)</code>, e.g when start time is <code>0.1</code> and stop time is <code>0.5</code> with <code>1000</code> steps, the first value of <code>h</code> will be <code>h(0.1)</code>, then <code>h(0.1 + dt)</code> and so on.</p><p><strong>Arguments</strong></p><ul><li><code>start</code>: start time, a real number, default is zero.</li><li><code>stop</code>: stop time, a real number.</li><li><code>h</code>: the hamiltonian expression.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>nsteps</code>: number of steps in the evolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/emulate/interface.jl#L58-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.unit_disk_graph" href="#EaRydCore.unit_disk_graph"><code>EaRydCore.unit_disk_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unit_disk_graph(atoms::AbstractVector{&lt;:RydAtom}, radius=1)</code></pre><p>Create a unit disk graph from atom positions <code>atoms</code>. It returns a <code>Graphs.SimpleGraph</code> instance.</p><ul><li><code>atoms</code> is vector of atoms positions.</li><li><code>radius</code> is the unit in the unit disk graph definition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/unit_disk.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.update_term!" href="#EaRydCore.update_term!"><code>EaRydCore.update_term!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_term!(H, term[, space=fullspace])</code></pre><p>Update matrix <code>H</code> based on the given Hamiltonian term. This can be faster when the sparse structure of <code>H</code> is known (e.g <code>H</code> is a <code>SparseMatrixCSC</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/hamiltonian.jl#L639-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.write_atoms-Tuple{IO, AbstractVector{&lt;:RydAtom}}" href="#EaRydCore.write_atoms-Tuple{IO, AbstractVector{&lt;:RydAtom}}"><code>EaRydCore.write_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_atoms(io::IO, atoms::AbstractVector{&lt;:RydAtom})</code></pre><p>Write a list of atom positions to stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.write_atoms-Tuple{String, AbstractVector{&lt;:RydAtom}}" href="#EaRydCore.write_atoms-Tuple{String, AbstractVector{&lt;:RydAtom}}"><code>EaRydCore.write_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_atoms(filename::String, atoms::AbstractVector{&lt;:RydAtom})</code></pre><p>Write a list of atom positions to the file given by <code>filename</code>.</p><p><strong>Example</strong></p><p>This saves the atom position generated from <a href="#EaRydCore.square_lattice-Tuple{Int64, Float64}"><code>square_lattice</code></a> to a file <code>demo.atoms</code>.</p><pre><code class="language-julia hljs">atoms = square_lattice(5, 0.8)
write_atoms(&quot;demo.atoms&quot;, atoms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L180-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.write_subspace-Tuple{AbstractString, Subspace}" href="#EaRydCore.write_subspace-Tuple{AbstractString, Subspace}"><code>EaRydCore.write_subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_subspace(filename::AbstractString, s::Subspace)</code></pre><p>Write <code>Subspace</code> to <code>filename</code> as human readable format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydCore.write_subspace-Tuple{IO, Subspace}" href="#EaRydCore.write_subspace-Tuple{IO, Subspace}"><code>EaRydCore.write_subspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_subspace(io::IO, s::Subspace)</code></pre><p>Write <code>Subspace</code> object <code>s</code> to <code>IO</code> as human readable format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/serialize.jl#L224-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.zero_state" href="#YaoArrayRegister.zero_state"><code>YaoArrayRegister.zero_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zero_state([T=ComplexF64], n::Int, subspace[, layout=ComplexLayout()])</code></pre><p>Create a <code>RydbergReg</code> in zero state in given subspace.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: optional, element type, default is <code>ComplexF64</code>.</li><li><code>n</code>: required, number of atoms (qubits).</li><li><code>subspace</code>: required, the subspace of rydberg state.</li><li><code>layout</code>: optional, memory layout, default is <code>ComplexLayout</code>.</li></ul><p><strong>Memory Layout</strong></p><p>When the hamiltonian is a real hermitian, it can be more efficient to use the <code>RealLayout</code> over <code>ComplexLayout</code> which stores the complex -value state vector as as <code>length(state)×2</code> matrix, the first column is the real component and the second column is the imaginary component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydCore/src/register.jl#L77-L95">source</a></section></article><h2 id="EaRydODE"><a class="docs-heading-anchor" href="#EaRydODE">EaRydODE</a><a id="EaRydODE-1"></a><a class="docs-heading-anchor-permalink" href="#EaRydODE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EaRydODE.ODEEvolution" href="#EaRydODE.ODEEvolution"><code>EaRydODE.ODEEvolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODEEvolution{P}</code></pre><p>Problem type for hamiltonian with time dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydODE/src/EaRydODE.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydODE.ODEEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Real, EaRydCore.AbstractTerm}} where P" href="#EaRydODE.ODEEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Real, EaRydCore.AbstractTerm}} where P"><code>EaRydODE.ODEEvolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ODEEvolution{P}(r::AbstractRegister, t::Real, h::AbstractTerm; kw...)</code></pre><p>Run the evolution for <code>t</code> μs, start from clock 0 μs, shorthand for</p><pre><code class="language-julia hljs">ODEEvolution{P}(r, (0, t), h; kw...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydODE/src/EaRydODE.jl#L148-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydODE.ODEEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Tuple{Real, Real}, EaRydCore.AbstractTerm}} where P" href="#EaRydODE.ODEEvolution-Union{Tuple{P}, Tuple{AbstractRegister, Tuple{Real, Real}, EaRydCore.AbstractTerm}} where P"><code>EaRydODE.ODEEvolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ODEEvolution{P}(r::AbstractRegister, (start, stop), h::AbstractTerm; kw...) where {P &lt;: AbstractFloat}</code></pre><p>Create a <code>ODEEvolution</code> that defines the evolution of a hamiltonian <code>h</code> with time dependent parameters to evolve from <code>start</code> to <code>stop</code> using an ODE solver.</p><p><strong>Arguments</strong></p><ul><li><code>P</code>: optional, a type parameter that sets the problem precision type, default is   the same as the <code>Yao.datatype</code> of given <code>register</code>.</li><li><code>register</code>: required, the evolution problem register, can be a <a href="#EaRydCore.RydbergReg-Tuple{AbstractMatrix{&lt;:Real}, Subspace}"><code>RydbergReg</code></a> or an <code>ArrayReg</code>   from <code>Yao</code>.</li><li><code>(start, stop)</code>: required, the evolution interval.</li><li><code>h</code>: required, the evolution hamiltonian.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>algo</code>: algorithm to use, default is <code>Vern8</code>, check DiffEq documentation for more details.</li><li><code>progress</code>: print progress bar or not, this may effect the performance when problem scale is small, default is <code>true</code>.</li><li><code>progress_steps</code>: steps to update the progress bar, default is <code>5</code>.</li><li><code>reltol</code>: relative tolerance, default is 1e-8.</li><li><code>abstol</code>: absolute tolerance, default is 1e-8.</li><li><code>normalize_steps</code>: steps to run normalization on the state, default is <code>5</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydODE/src/EaRydODE.jl#L161-L184">source</a></section></article><h2 id="EaRydWaveforms"><a class="docs-heading-anchor" href="#EaRydWaveforms">EaRydWaveforms</a><a id="EaRydWaveforms-1"></a><a class="docs-heading-anchor-permalink" href="#EaRydWaveforms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.append-Tuple{Waveform, Vararg{Waveform}}" href="#EaRydWaveforms.append-Tuple{Waveform, Vararg{Waveform}}"><code>EaRydWaveforms.append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append(wf::Waveform, wfs::Waveform...)</code></pre><p>Append other waveforms to <code>wf</code> on time axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/waveform.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.constant-Tuple{}" href="#EaRydWaveforms.constant-Tuple{}"><code>EaRydWaveforms.constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant(;duration::Real, value::Real)</code></pre><p>Create a constant waveform.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>duration::Real</code>: duration of the whole waveform.</li><li><code>value::Real</code>: value of the constant waveform.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/waveform.jl#L268-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.linear_ramp-Tuple{}" href="#EaRydWaveforms.linear_ramp-Tuple{}"><code>EaRydWaveforms.linear_ramp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_ramp(;duration, start_value, stop_value)</code></pre><p>Create a linear ramp waveform.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>duration::Real</code>: duration of the whole waveform.</li><li><code>start_value::Real</code>: start value of the linear ramp.</li><li><code>stop_value::Real</code>: stop value of the linear ramp.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; linear_ramp(;duration=2.2, start_value=0.0, stop_value=1.0)
                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
                  ┌────────────────────────────────────────┐ 
                1 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                0 │⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  └────────────────────────────────────────┘ 
                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀3⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/waveform.jl#L226-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.piecewise_constant-Tuple{}" href="#EaRydWaveforms.piecewise_constant-Tuple{}"><code>EaRydWaveforms.piecewise_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_constant(;clocks, values, duration=last(clocks))</code></pre><p>Create a piecewise constant waveform.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>clocks::Vector{&lt;:Real}</code>: the list of clocks for the corresponding values.</li><li><code>values::Vector{&lt;:Real}</code>: the list of values at each clock.</li><li><code>duration::Real</code>: the duration of the entire waveform, default is the last clock.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; piecewise_constant(clocks=[0.0, 0.2, 0.5], values=[0.0, 1.5, 3.1], duration=1.1)
                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
                  ┌────────────────────────────────────────┐ 
                4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⢠⠒⠒⠒⠒⠒⠚⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                0 │⣀⣀⣀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  └────────────────────────────────────────┘ 
                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀2⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/waveform.jl#L178-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.piecewise_linear-Tuple{}" href="#EaRydWaveforms.piecewise_linear-Tuple{}"><code>EaRydWaveforms.piecewise_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise_linear(;clocks, values)</code></pre><p>Create a piecewise linear waveform.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>clocks::Vector{&lt;:Real}</code>: the list of clocks for the corresponding values.</li><li><code>values::Vector{&lt;:Real}</code>: the list of values at each clock.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; piecewise_linear(clocks=[0.0, 2.0, 3.0, 4.0], values=[0.0, 2.0, 2.0, 0.0])
                  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Waveform{_, Float64}⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ 
                  ┌────────────────────────────────────────┐ 
                2 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⠀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀⠀⠀⠀⠀│ 
   value (rad/µs) │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢧⠀⠀⠀│ 
                  │⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡄⠀⠀│ 
                  │⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⡀⠀│ 
                  │⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀│ 
                  │⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆│ 
                0 │⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱│ 
                  └────────────────────────────────────────┘ 
                  ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀clock (μs)⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀4⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/waveform.jl#L137-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.sinusoidal-Tuple{}" href="#EaRydWaveforms.sinusoidal-Tuple{}"><code>EaRydWaveforms.sinusoidal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sinusoidal(;duration::Real, amplitude::Real=zero(start))</code></pre><p>Create a sinusoidal waveform of the following expression.</p><pre><code class="language-julia hljs">amplitude * sin(t)</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>duration</code>: duration of the waveform.</li><li><code>amplitude</code>: amplitude of the sin waveform.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/waveform.jl#L284-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.smooth" href="#EaRydWaveforms.smooth"><code>EaRydWaveforms.smooth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smooth([kernel=Kernel.gaussian], f; edge_pad_size::Int=length(f.clocks))</code></pre><p>Kernel smoother function for piece-wise linear function/waveform via weighted moving average method.</p><p><strong>Arguments</strong></p><ul><li><code>kernel</code>: the kernel function, default is <a href="@ref"><code>Kernels.gaussian</code></a>.</li><li><code>f</code>: a <a href="@ref"><code>PiecewiseLinear</code></a> function or a <a href="@ref"><code>Waveform{&lt;:PiecewiseLinear}</code></a>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kernel_radius</code>: radius of the kernel.</li><li><code>edge_pad_size</code>: the size of edge padding.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/smooth.jl#L53-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydWaveforms.smooth-Tuple{Any, Vector, Vector, Real}" href="#EaRydWaveforms.smooth-Tuple{Any, Vector, Vector, Real}"><code>EaRydWaveforms.smooth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth(kernel, Xi::Vector, Yi::Vector, kernel_radius::Real)</code></pre><p>Kernel smoother function via weighted moving average method. See also <a href="https://en.wikipedia.org/wiki/Kernel_smoother">Kernel Smoother</a>.</p><p><strong>Theory</strong></p><p>Kernel function smoothing is a technique to define a smooth function <span>$f: \mathcal{R}^p → \mathbf{R}$</span> from a set of discrete points by weighted averaging the neighboring points. It can be written as the following equation.</p><p class="math-container">\[Ŷ(X) = \sum_i K(X, X_i) Y_i / \sum_i K(X, X_i)\]</p><p>where <span>$Ŷ(X)$</span> is the smooth function by calculating the moving average of known data points <span>$X_i$</span> and <span>$Y_i$</span>. <code>K</code> is the kernel function, where <span>$K(\frac{||X - X_i||}{h_λ})$</span> decrease when the Euclidean norm <span>$||X - X_i||$</span> increase, <span>$h_λ$</span> is a parameter controls the radius of the kernel.</p><p><strong>Available Kernels</strong></p><p>The following kernel functions are available via the <a href="@ref"><code>Kernels</code></a> module:</p><p><a href="@ref"><code>biweight</code></a>; <a href="@ref"><code>cosine</code></a>; <a href="@ref"><code>gaussian</code></a>; <a href="@ref"><code>include</code></a>; <a href="@ref"><code>logistic</code></a>; <a href="@ref"><code>parabolic</code></a>; <a href="@ref"><code>sigmoid</code></a>; <a href="@ref"><code>triangle</code></a>; <a href="@ref"><code>tricube</code></a>; <a href="@ref"><code>triweight</code></a>; <a href="@ref"><code>uniform</code></a></p><p><strong>Arguments</strong></p><ul><li><code>kernel</code>: a Julia function that has method <code>kernel(t::Real)</code>.</li><li><code>Xi::Vector</code>: a list of inputs <code>X_i</code>.</li><li><code>Yi::Vector</code>: a list of outputs <code>Y_i</code>.</li><li><code>kernel_radius::Real</code>: the radius of the kernel.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydWaveforms/src/smooth.jl#L88-L125">source</a></section></article><h2 id="EaRydLattices"><a class="docs-heading-anchor" href="#EaRydLattices">EaRydLattices</a><a id="EaRydLattices-1"></a><a class="docs-heading-anchor-permalink" href="#EaRydLattices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.AtomList" href="#EaRydLattices.AtomList"><code>EaRydLattices.AtomList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AtomList{D, T} &lt;: AbstractVector{NTuple{D, T}}
AtomList(atoms::Vector{&lt;:NTuple})</code></pre><p>A list of atoms in <code>D</code> dimensional space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.ChainLattice" href="#EaRydLattices.ChainLattice"><code>EaRydLattices.ChainLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EaRydLattices.ChainLattice &lt;: AbstractLattice{1}
EaRydLattices.ChainLattice()</code></pre><p>EaRydLattices.ChainLattice is a 1 dimensional lattice with:</p><ul><li>Lattice vectors = ((1.0,),)</li><li>Lattice sites   = ((0.0,),)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L295-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.DistanceGroup" href="#EaRydLattices.DistanceGroup"><code>EaRydLattices.DistanceGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistanceGroup</code></pre><p>The vertices grouped by distances. One can use <code>distancegroup[n]</code> to get <code>n</code>-th nearest neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/neighbors.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.GeneralLattice" href="#EaRydLattices.GeneralLattice"><code>EaRydLattices.GeneralLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralLattice{D,K,T} &lt;: AbstractLattice{D}
GeneralLattice(vectors, sites)</code></pre><p>The general lattice type for tiling the space. Type parameter <code>D</code> is the dimension, <code>K</code> is the number of sites in a unit cell and <code>T</code> is the data type for coordinates, e.g. <code>Float64</code>. Input arguments are</p><ul><li><code>vectors</code> is a vector/tuple of D-tuple. Its length is D, it specifies the Bravais lattice vectors.</li><li><code>sites</code> is a vector/tuple of D-tuple. Its length is K, it specifies the sites inside a Bravais cell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.HoneycombLattice" href="#EaRydLattices.HoneycombLattice"><code>EaRydLattices.HoneycombLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EaRydLattices.HoneycombLattice &lt;: AbstractLattice{2}
EaRydLattices.HoneycombLattice()</code></pre><p>EaRydLattices.HoneycombLattice is a 2 dimensional lattice with:</p><ul><li>Lattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))</li><li>Lattice sites   = ((0.0, 0.0), (0.5, 0.2886751345948129))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L298-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.KagomeLattice" href="#EaRydLattices.KagomeLattice"><code>EaRydLattices.KagomeLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EaRydLattices.KagomeLattice &lt;: AbstractLattice{2}
EaRydLattices.KagomeLattice()</code></pre><p>EaRydLattices.KagomeLattice is a 2 dimensional lattice with:</p><ul><li>Lattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))</li><li>Lattice sites   = ((0.0, 0.0), (0.25, 0.4330127018922193), (0.75, 0.4330127018922193))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.LiebLattice" href="#EaRydLattices.LiebLattice"><code>EaRydLattices.LiebLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EaRydLattices.LiebLattice &lt;: AbstractLattice{2}
EaRydLattices.LiebLattice()</code></pre><p>EaRydLattices.LiebLattice is a 2 dimensional lattice with:</p><ul><li>Lattice vectors = ((1.0, 0.0), (0.0, 1.0))</li><li>Lattice sites   = ((0.0, 0.0), (0.5, 0.0), (0.0, 0.5))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L296-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.MaskedGrid" href="#EaRydLattices.MaskedGrid"><code>EaRydLattices.MaskedGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaskedGrid{T}
MaskedGrid(xs, ys, mask)</code></pre><p>Masked square lattice contains 3 fields, the x-coordinates, y-coordinates and a mask. e.g. <code>MaskedGrid([0.0, 1.0, 3.0], [0.0, 2.0,6.0], Bool[1 0 0; 0 1 1; 0 1 0])</code> specifies the following lattice:</p><pre><code class="nohighlight hljs">     y₁   y₂        y₃
     ↓    ↓         ↓
x₁ → ●    ⋅         ●
x₂ → ⋅    ●         ●

x₃ → ⋅    ●         ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L211-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.SquareLattice" href="#EaRydLattices.SquareLattice"><code>EaRydLattices.SquareLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EaRydLattices.SquareLattice &lt;: AbstractLattice{2}
EaRydLattices.SquareLattice()</code></pre><p>EaRydLattices.SquareLattice is a 2 dimensional lattice with:</p><ul><li>Lattice vectors = ((1.0, 0.0), (0.0, 1.0))</li><li>Lattice sites   = ((0.0, 0.0),)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L293-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.TriangularLattice" href="#EaRydLattices.TriangularLattice"><code>EaRydLattices.TriangularLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EaRydLattices.TriangularLattice &lt;: AbstractLattice{2}
EaRydLattices.TriangularLattice()</code></pre><p>EaRydLattices.TriangularLattice is a 2 dimensional lattice with:</p><ul><li>Lattice vectors = ((1.0, 0.0), (0.5, 0.8660254037844386))</li><li>Lattice sites   = ((0.0, 0.0),)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L294-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.clip_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{Tuple{T, T}, D}}} where {D, T}" href="#EaRydLattices.clip_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{Tuple{T, T}, D}}} where {D, T}"><code>EaRydLattices.clip_axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clip_axes(sites::AtomList{D, T}, bounds::Vararg{Tuple{T,T},D}) where {D, T}
clip_axes(bounds...)</code></pre><p>Remove sites out of <code>bounds</code>, where <code>bounds</code> is specified by D D-tuples.</p><pre><code class="language-julia-repl hljs">julia&gt; sites = [(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)]
4-element Vector{Tuple{Float64, Float64}}:
 (1.0, 2.0)
 (10.0, 3.0)
 (1.0, 12.0)
 (3.0, 5.0)

julia&gt; clip_axes(sites, (-5.0, 5.0), (-5.0, 5.0))
2-element Vector{Tuple{Float64, Float64}}:
 (1.0, 2.0)
 (3.0, 5.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L180-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.collect_atoms-Tuple{MaskedGrid}" href="#EaRydLattices.collect_atoms-Tuple{MaskedGrid}"><code>EaRydLattices.collect_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_atoms(maskedgrid::MaskedGrid)</code></pre><p>Returns an list of atoms in the <code>maskedgrid</code> in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.dimension-Union{Tuple{AbstractLattice{D}}, Tuple{D}} where D" href="#EaRydLattices.dimension-Union{Tuple{AbstractLattice{D}}, Tuple{D}} where D"><code>EaRydLattices.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimension(lattice)</code></pre><p>Returns the space dimension of target lattice. e.g. <a href="#EaRydLattices.ChainLattice"><code>ChainLattice</code></a> is a 1D lattice, hence returns 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D" href="#EaRydLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D"><code>EaRydLattices.generate_sites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_sites(lattice::AbstractLattice{D}, repeats::Vararg{Int,D}; scale=1.0)</code></pre><p>Returns an <a href="#EaRydLattices.AtomList"><code>AtomList</code></a> instance by tiling the specified <code>lattice</code>. The tiling repeat the <code>sites</code> of the lattice <code>m</code> times along the first dimension, <code>n</code> times along the second dimension, and so on. <code>scale</code> is a real number that re-scales the lattice constant and atom locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.grouped_nearest-Tuple{NearestNeighbors.KDTree, Int64, Int64}" href="#EaRydLattices.grouped_nearest-Tuple{NearestNeighbors.KDTree, Int64, Int64}"><code>EaRydLattices.grouped_nearest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grouped_nearest(tree::KDTree, siteindex::Int, nsites::Int; atol=1e-8)</code></pre><p>Find the <code>nsites</code> closest vertices to <code>siteindex</code>, and group them by distance. Difference of the distances smaller than the <code>atol</code> (default is <code>1e-8</code>) are treated as the same Returns a <a href="#EaRydLattices.DistanceGroup"><code>DistanceGroup</code></a> instance.</p><pre><code class="language-julia-repl hljs">julia&gt; atoms = generate_sites(HoneycombLattice(), 5, 5);

julia&gt; tree = make_kdtree(atoms)
NearestNeighbors.KDTree{StaticArrays.SVector{2, Float64}, Distances.Euclidean, Float64}
  Number of points: 50
  Dimensions: 2
  Metric: Distances.Euclidean(0.0)
  Reordered: true

julia&gt; gn = grouped_nearest(tree, 23, 20)
DistanceGroup([23, 14, 22, 24, 15, 13, 21, 25, 33, 31, 12, 16, 32, 4, 6, 34, 26, 17, 5, 41], [1, 2, 5, 11, 14, 18, 21])

julia&gt; gn[0]  # the 0-th nearest neighbor is defined by vertex itself
1-element Vector{Int64}:
 23

julia&gt; gn[1]  # nearest neighbors
3-element Vector{Int64}:
 14
 22
 24

julia&gt; gn[2]  # second nearest neighbors
6-element Vector{Int64}:
 15
 13
 21
 25
 33
 31</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/neighbors.jl#L54-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.img_atoms-Tuple{AtomList}" href="#EaRydLattices.img_atoms-Tuple{AtomList}"><code>EaRydLattices.img_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">img_atoms(atoms::AtomList;
    colors=[&quot;black&quot;, &quot;black&quot;, ...], blockade_radius=0,
    texts=[&quot;1&quot;, &quot;2&quot;, ...],
    blockade_radius=0;
    format=PNG,
    blockade_style=&quot;none&quot;,
    bond_color=&quot;black&quot;,
    )</code></pre><p>Plots <code>atoms</code> with colors specified by <code>colors</code> and texts specified by <code>texts</code>. You will need a <code>VSCode</code>, <code>Pluto</code> notebook or <code>Jupyter</code> notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try</p><pre><code class="language-julia hljs">julia&gt; open(&quot;test.png&quot;, &quot;w&quot;) do f
            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))
       end</code></pre><p>The <code>format</code> keyword argument can also be <code>Compose.SVG</code> or <code>Compose.PDF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/visualize.jl#L38-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.img_maskedgrid-Tuple{MaskedGrid}" href="#EaRydLattices.img_maskedgrid-Tuple{MaskedGrid}"><code>EaRydLattices.img_maskedgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">img_maskedgrid([io::Union{IO,AbstractString}, ]maskedgrid::MaskedGrid;
    format=PNG,
    blockade_radius = blockade_radius,
    colors=fill(&quot;white&quot;, count(maskedgrid.mask)))</code></pre><p>Draw a <code>maskedgrid</code> with colors specified by <code>colors</code> and texts specified by <code>texts</code>. You will need a <code>VSCode</code>, <code>Pluto</code> notebook or <code>Jupyter</code> notebook to show the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/visualize.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.lattice_sites-Tuple{GeneralLattice}" href="#EaRydLattices.lattice_sites-Tuple{GeneralLattice}"><code>EaRydLattices.lattice_sites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_sites(lattice::AbstractLattice)</code></pre><p>Returns sites in a Bravais lattice unit cell as a Tuple of D-Tuple, where D is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.lattice_vectors-Tuple{GeneralLattice}" href="#EaRydLattices.lattice_vectors-Tuple{GeneralLattice}"><code>EaRydLattices.lattice_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_vectors(lattice::AbstractLattice)</code></pre><p>Returns Bravais lattice vectors as a D-Tuple of D-Tuple, where D is the space dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.make_grid-Union{Tuple{AtomList{D, T}}, Tuple{T}, Tuple{D}} where {D, T}" href="#EaRydLattices.make_grid-Union{Tuple{AtomList{D, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>EaRydLattices.make_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_grid(sites::AtomList; atol=...)</code></pre><p>Create a <a href="#EaRydLattices.MaskedGrid"><code>MaskedGrid</code></a> from the sites. It is required by lattice preparation of Rydberg array. Because the grid will sort the sites by rows, we need <code>atol</code> (default value is 10 time sit data precision) determines up to what level of round off error, two atoms belong to the same row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L234-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.make_kdtree-Union{Tuple{AtomList{D, T}}, Tuple{D}, Tuple{T}} where {T, D}" href="#EaRydLattices.make_kdtree-Union{Tuple{AtomList{D, T}}, Tuple{D}, Tuple{T}} where {T, D}"><code>EaRydLattices.make_kdtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_kdtree(atoms::AtomList{D,T}) where {T, D}</code></pre><p>Returns a <a href="@ref"><code>KDTree</code></a> instance from input <code>atoms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/neighbors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.offset_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{T, D}}} where {D, T}" href="#EaRydLattices.offset_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Vararg{T, D}}} where {D, T}"><code>EaRydLattices.offset_axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offset_axes(sites::AtomList{D, T}, offsets::Vararg{T,D}) where {D, T}
offset_axes(offsets...)</code></pre><p>Offset the <code>sites</code> by distance specified by <code>offsets</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; sites = [(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)]
4-element Vector{Tuple{Float64, Float64}}:
 (1.0, 2.0)
 (10.0, 3.0)
 (1.0, 12.0)
 (3.0, 5.0)

julia&gt; offset_axes(sites, 1.0, 3.0)
4-element Vector{Tuple{Float64, Float64}}:
 (2.0, 5.0)
 (11.0, 6.0)
 (2.0, 15.0)
 (4.0, 8.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L115-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.random_dropout-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}" href="#EaRydLattices.random_dropout-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}"><code>EaRydLattices.random_dropout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_dropout(sites::AtomList{D, T}, ratio::Real) where {D, T}
random_dropout(ratio)</code></pre><p>Randomly drop out <code>ratio * number of sites</code> atoms from <code>sites</code>, where <code>ratio</code> ∈ [0, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EaRydLattices.rescale_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}" href="#EaRydLattices.rescale_axes-Union{Tuple{T}, Tuple{D}, Tuple{AtomList{D, T}, Real}} where {D, T}"><code>EaRydLattices.rescale_axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale_axes(sites::AtomList{D, T}, scale::Real) where {D, T}
rescale_axes(scale)</code></pre><p>Rescale the <code>sites</code> by a constant <code>scale</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; sites = [(1.0, 2.0), (10.0, 3.0), (1.0, 12.0), (3.0, 5.0)]
4-element Vector{Tuple{Float64, Float64}}:
 (1.0, 2.0)
 (10.0, 3.0)
 (1.0, 12.0)
 (3.0, 5.0)

julia&gt; rescale_axes(sites, 2.0)
4-element Vector{Tuple{Float64, Float64}}:
 (2.0, 4.0)
 (20.0, 6.0)
 (2.0, 24.0)
 (6.0, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydLattices/src/lattice.jl#L142-L163">source</a></section></article><h2 id="EaRydPlots"><a class="docs-heading-anchor" href="#EaRydPlots">EaRydPlots</a><a id="EaRydPlots-1"></a><a class="docs-heading-anchor-permalink" href="#EaRydPlots" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EaRydPlots.bitstring_histgram-Tuple{ArrayReg}" href="#EaRydPlots.bitstring_histgram-Tuple{ArrayReg}"><code>EaRydPlots.bitstring_histgram</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/EaRyd.jl/blob/38789072699a390b0843cb9694b9b756e9b8d597/lib/EaRydPlots/src/bitstring_hist.jl#L27">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/qaoa/">« Quantum Approximate Optimization Algorithm</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 24 January 2022 07:01">Monday 24 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
