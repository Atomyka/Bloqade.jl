<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hamiltonians · EaRyd.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Happy-Diode.github.io/EaRyd.jl/hamiltonians/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">EaRyd.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../julia/">The Julia Programming Language</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../waveform/">Waveforms</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li class="is-active"><a class="tocitem" href>Hamiltonians</a><ul class="internal"><li><a class="tocitem" href="#Building-Time-Independent-Hamiltonians"><span>Building Time-Independent Hamiltonians</span></a></li><li><a class="tocitem" href="#Building-Time-Dependent-Hamiltonians"><span>Building Time-Dependent Hamiltonians</span></a></li><li><a class="tocitem" href="#Hamiltonian-Expressions"><span>Hamiltonian Expressions</span></a></li><li><a class="tocitem" href="#Convert-Hamiltonian-to-Matrices"><span>Convert Hamiltonian to Matrices</span></a></li></ul></li><li><a class="tocitem" href="../emulation/">Emulation</a></li><li><a class="tocitem" href="../cuda/">CUDA Acceleration</a></li></ul></li><li><span class="tocitem">Advanced Topics</span><ul><li><a class="tocitem" href="../topics/blockade/">Rydberg Blockade</a></li><li><a class="tocitem" href="../topics/bravais/">Bravais Lattice</a></li><li><a class="tocitem" href="../topics/ad/">Automatic Differentiation</a></li></ul></li><li><a class="tocitem" href="../contrib/">Contributing EaRyd</a></li><li><a class="tocitem" href="../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Hamiltonians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hamiltonians</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Happy-Diode/EaRyd.jl/blob/master/docs/src/hamiltonians.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h1><p>Hamiltonian encodes essential physical properties of Rydberg systems. One can use a Hamiltonian to  understand the ground state properties of the corresponding Rydberg system and to generate interesting quantum dynamics.  The Rydberg Hamiltonian is generally specified by atom positions, Rabi frequencies and detunings. In EaRyd,  we can easily create a Hamiltonian by inputting these information, i.e. lattice and strengths of Rabi frequencies and detunings,  into the function <a href="@ref"><code>rydberg_h</code></a>. Furthermore, by inputing waveforms for the Rabi frequency and  detuning, we can easily generate time-dependent Hamiltonians. </p><h2 id="Building-Time-Independent-Hamiltonians"><a class="docs-heading-anchor" href="#Building-Time-Independent-Hamiltonians">Building Time-Independent Hamiltonians</a><a id="Building-Time-Independent-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Time-Independent-Hamiltonians" title="Permalink"></a></h2><p>To specify the Hamiltonian, we first need to specify the atom positions, which determine the Rydberg intearctions strengths between pairs of atoms. Here we generate a square lattice by using the code below. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using EaRyd</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(SquareLattice(), 3, 3, scale=6.3);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Please refer to <a href="@ref">Lattice</a> page for more details about generating lattice and relevant operations. </p><p>Then the Hamiltonian can be simply built by inputing the generated atom positions <code>atoms</code> and by specifying the strength of Rabi detuning <code>Δ</code>, Rabi frequency <code>Ω</code>, and laser phase <code>ϕ</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h0 = rydberg_h(atoms; Δ=1.2, Ω=1.1, ϕ=2.1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 9
+
├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j
├─ [+] 0.55 ⋅ ∑ e^{2.1 ⋅ im} |0⟩⟨1| + e^{-2.1 ⋅ im} |1⟩⟨0|
└─ [-] 1.2 ⋅ ∑ n_i</code></pre><h2 id="Building-Time-Dependent-Hamiltonians"><a class="docs-heading-anchor" href="#Building-Time-Dependent-Hamiltonians">Building Time-Dependent Hamiltonians</a><a id="Building-Time-Dependent-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Time-Dependent-Hamiltonians" title="Permalink"></a></h2><p>One can also directly use waveforms (instead of contanst values of detuning, Rabi frequency, and laser phase) to build a time-dependent Hamiltonian.  First let us use the  <a href="../ref/#EaRydLattices.generate_sites-Union{Tuple{D}, Tuple{AbstractLattice{D}, Vararg{Int64, D}}} where D"><code>generate_sites</code></a> to create a list of atom coordinates. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; atoms = generate_sites(ChainLattice(), nsites, scale=5.72)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: nsites not defined</code></pre><p>Then we generate time-dependent pulses for <span>$\Omega$</span> and <span>$\Delta$</span> by using  <a href="../ref/#EaRydWaveforms.piecewise_linear-Tuple{}"><code>piecewise_linear</code></a>. For details about how to build waveforms, please refer to the section <a href="../waveform/#Waveforms">Waveforms</a>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ω1 = piecewise_linear(clocks=[0.0, 0.1, 2.1, 2.2], values=[0.0, 6.0, 6.0, 0]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Δ1 = piecewise_linear(clocks=[0.0, 0.6, 2.1, 2.2], values=[-10.1, -10.1, 10.1, 10.1]);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>The time-dependent Hamiltonian is easily generated by inputting the waveforms into the function <a href="@ref"><code>rydberg_h</code></a></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h1 = rydberg_h(atoms; Δ=Δ1, Ω=Ω1)</code><code class="nohighlight hljs ansi" style="display:block;">nqubits: 9
+
├─ [+] ∑ 5.42e6/|r_i-r_j|^6 n_i n_j
├─ [+] Ω(t) ⋅ ∑ σ^x_i
└─ [-] Δ(t) ⋅ ∑ n_i</code></pre><p>By specifying the time of <code>h1</code>, we can  acess the Hamiltonian at a particular time, e.g. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ht= h1(0.5)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: objects of type YaoBlocks.Add{2} are not callable</code></pre><h2 id="Hamiltonian-Expressions"><a class="docs-heading-anchor" href="#Hamiltonian-Expressions">Hamiltonian Expressions</a><a id="Hamiltonian-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-Expressions" title="Permalink"></a></h2><p>Inside this package, a more general definition of hamiltonians are supported as Symbolic expressions, this gives users the flexiblity to define various different kind of Hamltonian by simply writing down the expression.</p><p>Currently, there are currently 4 terms supported: <a href="@ref"><code>RydInteract</code></a>, <a href="@ref"><code>XTerm</code></a>, <a href="@ref"><code>NTerm</code></a>, <a href="@ref"><code>ZTerm</code></a>. Instead of using the function <a href="@ref"><code>rydberg_h</code></a>,  we can also explicitly add up these terms to compose a new hamiltonian, e.g</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using EaRyd</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = XTerm(5, 1.0) + ZTerm(5, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: XTerm not defined</code></pre><h2 id="Convert-Hamiltonian-to-Matrices"><a class="docs-heading-anchor" href="#Convert-Hamiltonian-to-Matrices">Convert Hamiltonian to Matrices</a><a id="Convert-Hamiltonian-to-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-Hamiltonian-to-Matrices" title="Permalink"></a></h2><p>In order to better understand physical properties (such as engenstate properties and eigenvalue statistics) of a Rydberg system, we may want to diagonalize the corresponding Hamiltonian  matrices. In EaRyd, the Hamiltonian expression can be converted to a matrice via type conversion, e.g we can convert the above Hamiltonian to a <code>SparseMatrixCSC</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_m = SparseMatrixCSC(ht)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: ht not defined</code></pre><p>With strong interactions, only one Rydberg excitation is allowed within the Blockade regime (see <a href="@ref">blockade</a>). In such a case, the allowed Hilbert space (called blockade subpace) for <span>$N$</span> atoms  is only part of full <span>$2^N$</span> Hilbert space. In this case, it is better to work in the blockade subspace such that one can access larger systems.  One of the essential feature of EaRyd is to allow the users to also work in blockade subspace. Here, we can easily convert the Hamiltonian expression into a matrices in subspace basis. First, we can specify such a subspace by using function <a href="@ref"><code>blockade_subspace</code></a>, e.g. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; space = blockade_subspace(atoms, 7.5)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: blockade_subspace not defined</code></pre><p>The above code means that the blocakde subspace only includes states where there is only one Rydberg excitation  within the distance of <span>$7.5 \mu m$</span>. If we have a chain of atoms seperated by <span>$5.72 \mu m$</span>, the blocakde subspace  does not contains states with nearest-neighbour atoms being simutaniously excited. </p><p>Once we have defined the space, we can convert the Hamiltonain to matrice in subspace basis via the codes below</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h_s= SparseMatrixCSC(ht, space)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: ht not defined</code></pre><p>We can see that the size of the matrices in blockade susbpace is much smaller than that in the full space. </p><p>After the conversion, the Hamiltonian can be diagonalized by using <code>KrylovKit.eigsolve</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using KrylovKit</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vals, vecs, info = KrylovKit.eigsolve(h_m,  1, :SR)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: h_m not defined</code></pre><p>where the <code>vals</code> and <code>vecs</code> store calculated eigenvalues and eigenvectors respectively. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lattices/">« Lattices</a><a class="docs-footer-nextpage" href="../emulation/">Emulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 11 April 2022 07:19">Monday 11 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
